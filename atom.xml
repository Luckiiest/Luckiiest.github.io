<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luckiiest Blog</title>
  
  <subtitle>Choose a gesture to allow yourself to live irreplaceable.</subtitle>
  <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/"/>
  <updated>2022-07-28T07:25:40.151Z</updated>
  <id>https://github.com/Luckiiest/Luckiiest.github.io.git/</id>
  
  <author>
    <name>Luckiiest</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微机原理</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/07/21/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/07/21/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</id>
    <published>2022-07-21T01:21:43.000Z</published>
    <updated>2022-07-28T07:25:40.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微机原理"><a href="#微机原理" class="headerlink" title="微机原理"></a>微机原理</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="微机发展概况"><a href="#微机发展概况" class="headerlink" title="微机发展概况"></a>微机发展概况</h3><ul><li><strong>电子计算机</strong><ul><li>第一代：1946年 电子管 30吨 176㎡ 5000次/s 18000支电子管 6000个继电器 功率150KW 48万美元 </li><li>第二代：1958 晶体管</li><li>第三代：1965 <code>SSI/MSI</code></li><li>第四代：1970 <code>LSI/VLSI</code>（微型计算机）</li><li>第五代：具有人工智能（推理/判断/决策/学习/联想）</li></ul></li><li><strong>微型计算机（第四代）</strong><ul><li>第一代：<code>1971</code> <code>Intel</code> <code>4004/8008</code>   <code>4/8位机</code>   <code>10~15us</code></li><li>第二代：<code>1973</code> <code>8080/Z80/M6800/8085</code> <code>8位</code>     <code>1~2us</code></li><li>第三代：<code>1978</code> <code>8086/M68000/80286</code>   <code>16位</code>     <code>0.5us</code></li><li>第四代：<code>1983</code> <code>80386/486</code>           <code>32位</code>     <code>&lt;0.1us</code></li><li>第五代：<code>1993</code> <code>Pentium/P2/P3/P4</code>    <code>32/64位</code>  <code>fclk&gt;2Ghz</code></li><li>第六代：<code>2006</code> <code>酷睿(core)双核/四核/八核......</code></li></ul></li><li><strong>8086(微型计算机第三代)</strong><ul><li><code>Intel 8086/8088 CPU</code></li><li><code>128Kb RAM</code></li><li><code>5&#39;&#39;360kb或720软驱</code></li><li><code>5MB硬盘</code></li></ul></li><li><strong>80286(微型计算机第三代)</strong><ul><li><code>Intel 80286 CPU</code></li><li><code>3.5英寸1.44MB软盘</code></li><li><code>270万条指令/s</code></li><li><code>集成134000个晶体管</code></li></ul></li><li><strong>80386/486/Pentium/Pro…(微型计算机第四、五代)</strong><ul><li>Intel第一枚32位处理器：80386</li><li>120万晶体管：486</li><li>300多万晶体管1亿条指令/s：<code>Pentium</code></li><li>550多万晶体管4.4亿条指令/s：<code>Pentium Pro</code></li></ul></li><li><strong>计算机第一定理：摩尔定律</strong><ul><li>继承电率的集成度每18个月翻一番，既每18个月芯片能力增长一倍</li><li>晶体管的数量每两年增加一倍</li></ul></li><li><strong>16位机是32/64位机的区别</strong><ul><li>16位机是32/64位机的基础</li><li>8086系列向上兼容</li><li>16位基础–&gt;32/64位拓展</li></ul></li></ul><h3 id="微机应用领域"><a href="#微机应用领域" class="headerlink" title="微机应用领域"></a>微机应用领域</h3><ul><li>科学计算：数/理/化/天文/气象/工程…</li><li>信息处理：OA/MIS/图文声像多媒体…</li><li>自动控制：厂矿企业/军事工业/CIMS</li><li>智能仪器仪表：单片机(MCU)/DSP/ARM类产品</li><li>网络通讯：无线，光纤，卫星通讯/Internet…</li><li>计算机辅助系统：CAD/CAM/CAPP/CAI…</li><li>人工智能：智能机器人/机器视觉/深度学习</li><li>各个领域，无处不在</li></ul><h3 id="微机系统的概念"><a href="#微机系统的概念" class="headerlink" title="微机系统的概念"></a>微机系统的概念</h3><ul><li>硬件<ul><li>微型计算机<ul><li>CPU：运算器，控制器，寄存器组</li><li>存储器：ROM/RAM</li><li>I/O接口：并行/串行，简单/可编程…</li><li>总线：AB、DB、CB</li></ul></li><li>外部设备<ul><li>I/O设备：键盘，鼠标/CRT，PRN</li><li>外存储器：软盘/硬盘/光盘/U盘…</li></ul></li></ul></li><li>软件<ul><li>系统软件：操作系统/编译/汇编/监控程序…</li><li>应用软件：MIS/CAD/CAI/MILL/APP…</li><li>程序设计语言：机器/汇编/高级语言</li></ul></li></ul><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul><li><p>计算机的结构</p><ul><li>冯·诺依曼结构</li><li>五箱结构<ul><li>输入设备、存储器、输出设备、控制器、运算器</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211439855.png" alt="image-20220721143935477"></li></ul></li></ul></li><li><p>总线的类型</p><ul><li><p>内部总线/外部总线</p></li><li><p>局部总线/系统总线</p></li><li><p>地址总线（AB）：单向/三态，决定寻址容量</p></li><li><p>数据总线（DB）：双向/三态，决定传输能力</p></li><li><p>控制总线（CB）：有入有出</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211453436.png" alt="image-20220721144423692"></p></li><li><p>微机总线标准</p><ul><li>各模块间的互联标准/传输协议<ul><li>如：PC总线/ISA/EISA/MCA/PCI等</li></ul></li><li>微机系统模块化：符合总线标准的各种模块（如：显示卡、网卡、多功能卡等）可任意插拔、方便拓展</li></ul></li></ul></li><li><p>单片机</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211500036.png" alt="image-20220721150017876"></p><h2 id="8086系统结构"><a href="#8086系统结构" class="headerlink" title="8086系统结构"></a>8086系统结构</h2><ul><li>8086CPU<ul><li>DB：16条，16位微处理器</li><li>AB：20条，直接寻址空间，2^20=1MB</li><li>时钟频率：5MHz~10MHz</li><li>可与8087/8089组成多机系统</li><li>40引脚/双列直插/HMOS工艺</li></ul></li><li>8088CPU<ul><li>准16位CPU。DB：内部16位/外部8位</li></ul></li><li>8086/8088CPU特点<ul><li>引脚复用：引脚功能复用/总线分时复用</li><li>可控三态结构</li><li>单总线，累加器结构</li></ul></li></ul><h3 id="8086CPU结构"><a href="#8086CPU结构" class="headerlink" title="8086CPU结构"></a>8086CPU结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211541664.png" alt="image-20220721154150460"></p><h4 id="两大部件"><a href="#两大部件" class="headerlink" title="两大部件"></a>两大部件</h4><ul><li><p><strong>总线接口部件BIU</strong></p><ul><li>负责对外</li><li>作用：CPU与外部（存储器,I/O）的接口，对外提供16位DB，20位AB</li><li>功能：地址形成，取指令，指令排队，读/写操作数和总线控制</li><li>组成：<ul><li>段地址寄存器(16位)：<code>CS：代码段</code>、<code>DS：数据段</code>、<code>ES：附加段</code>、<code>SS：堆栈段</code></li><li>指令指针寄存器IP(16位)：存放下一条待执行指令的偏移地址</li><li>物理地址加法器：由段地址与偏移地址形成20位实际地址</li><li>指令队列寄存器：预存6字节指令码（先进先出）</li><li>总线控制逻辑：发总线控制信号，存储器、I/O读/写信号</li></ul></li></ul></li><li><p><strong>指令执行部件EU</strong></p><ul><li><p>负责对内</p></li><li><p>功能：从指令队列中取指令、译码、执行</p></li><li><p>组成：</p><ul><li>ALU：完成算数/逻辑运算</li><li>FLAGS：存放运算结果的特征</li><li>寄存器组：通用(AX，BX，CX，DX)/专用（SI,DI,SP,BP）</li><li>EU控制器：取指令、时序控制</li></ul></li><li><p>8位机执行过程</p><ul><li><p><code>| 取指 | 执行 | 取指 | 执行 | 取指 | 执行 |</code> </p></li><li><p>从外部存储器取指令</p></li></ul></li><li><p>8086执行过程</p><ul><li><code>| 取指 | 取指 | 取指 | 取指 | 取指 | 取指 | </code> BIU完成</li><li><code>| 等待 | 执行 | 执行 | 执行 | 执行 | 执行 |</code> EU完成</li><li>并行工作</li><li>流水线结构</li><li>执行指令的同时预取下一条指令</li></ul></li></ul></li></ul><h4 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h4><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211748463.png" alt="image-20220721174839199"></p><ul><li><p><strong>专用寄存器</strong></p><ul><li><p>段寄存器（16位）</p><ul><li>1MB空间分为若干个逻辑段</li><li>存储单元20位实际地址（即：物理地址）由两部分组成：段基址（存放在段寄存器中）和段内偏移地址</li><li><code>物理地址 = 段基址左移4位(乘以16) + 段内偏移地址</code></li></ul></li><li><p>指令指针IP（16位）</p><ul><li>存放下一条待执行指令在先行代码段中的偏移地址，控制指令序列的流程</li></ul></li><li><p>标志寄存器FLAGS（程序状态字PSW，16位）</p><ul><li><p>存放运算结果的状态和控制标志，每一位有特定的含义</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211726904.png" alt="image-20220721172634096"></p></li><li><p><code>AF</code>：辅助进位标志（低4位）有/无半进(借)位</p></li><li><p><code>SF</code>：符号标志，结果为负/正</p></li><li><p><code>ZF</code>：零标志，结果为0/非0（运算结果非0的话指0，是0的话指1）</p></li><li><p><code>PF</code>：奇偶标志，结果低字节有偶数个1/奇数个1</p></li><li><p><code>CF</code>：进位标志，有/无进(借)位（反应无符号数是否超范围，溢出）</p><ul><li>8位无符号数范围：0~255</li><li>反应无符号数是否超范围（溢出）</li></ul></li><li><p><code>OF</code>：溢出标志，溢出/无溢出（OF=Cy最高+Cy次高）（反应带符号数是否超范围,溢出）</p><ul><li>8位带符号数范围：<code>-128~+127</code></li><li>反应有符号数是否超范围</li></ul></li><li><p><code>DF</code>：方向标志，地址自动减/增</p></li><li><p><code>IF</code>：中断标志，中断允许/禁止</p></li><li><p><code>TF</code>：单步标志，单步允许/禁止</p></li></ul></li></ul></li></ul><h3 id="8086-8088CPU引脚及功能"><a href="#8086-8088CPU引脚及功能" class="headerlink" title="8086/8088CPU引脚及功能"></a>8086/8088CPU引脚及功能</h3><blockquote><p>40引脚，双列直插</p></blockquote><ul><li><p>两种工作模式</p><ul><li><p>最小模式：单机系统中所有控制信号，全部由8086直接提供</p></li><li><p>最大模式：多处理器系统系统中控制信号由总线控制器8288提供</p></li></ul></li></ul><h4 id="40引脚，双列直插"><a href="#40引脚，双列直插" class="headerlink" title="40引脚，双列直插"></a>40引脚，双列直插</h4><ul><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207221527404.png" alt="image-20220722152717125"></p></li><li><p><code>AD15~AD0（地址/数据总线）</code></p><ul><li>分时复用<ul><li>传送地址时，三态输出，单向</li><li>传送数据时，三台输入/输入，双向</li></ul></li><li>总线周期T1：输出地址—&gt;外部锁存器；T2~T4：传送数据中断/总线保持响应:高阻</li></ul></li><li><p><code>A19/S6~A16/S3（地址/状态线）</code></p><ul><li>三态，输出，分时复用</li><li>T1：输出地址（访问I/O时:0000）—&gt;外部锁存器</li><li>T2~T4：做状态线</li><li>S6=0：表明8086当前连在总线上；S5：IF当前状态；S4,S3组合：指明当前使用的段（ES/SS/CS/DS）</li></ul></li><li><p><code>BHE/S7（高8位数据总线允许/状态线）</code></p><ul><li>分时复用，需锁存</li><li>T1：输出BHE（0/1:高/低8位数据有效）</li></ul></li><li><p><code>ALE（地址锁存允许）</code></p><ul><li>输出，高有效，作9292的选通信号</li><li>解决地址/数据复用：T1:ALE=1，CPU发地址—&gt;外部锁存器，ALE下降沿锁存地址，此后传输数据</li></ul></li><li><p><code>RD（读选通）</code></p><ul><li>RD=0，读存储器或I/O（与M/IO配合）</li></ul></li><li><p><code>WR（写选通）</code></p><ul><li>WR=0，写存储器或I/O（与M/IO配合）</li></ul></li><li><p><code>M/IO（存储器或I/O端口选择）</code></p><ul><li>1/0：CPU访问存储器/访问I/O</li></ul></li><li><p><code>INTR（可屏蔽中断请求输入）</code></p><ul><li>CPU每条指令最后一个T状态测试INTR</li><li>如INTR=1，表明外设有中断请求，若此时允许中断(1F=1)，则CPU执行完先行指令后响应中断；否则(1F=0)，CPU不予理睬</li></ul></li><li><p><code>INTA（中断响应）</code></p><ul><li>作为INTR的回答信号</li><li>中断响应时，CPU发出两个INTA负脉冲，第一个通知外设已响应其请求，第二个脉冲外设收到后，向DB放置中断类型号。</li></ul></li><li><p><code>NMI（非屏蔽中断请求）</code></p><ul><li>上升沿有效</li><li>不能由软件屏蔽（与IF状态无关）</li><li>常用于处理最紧急事件</li></ul></li><li><p><code>DEN（数据允许）</code></p><ul><li>做数据收发器8286的输出允许信号</li><li>8286：总线收发器，用于增加总线驱动能力</li></ul></li><li><p><code>DT/R（数据发送/接收控制）</code></p><ul><li>控制8286的数据传输方向</li><li>DT/R=0：CPU读，即接收</li><li>DT/R=1：CPU写，即发送</li></ul></li><li><p><code>RESET（复位）</code></p><ul><li>高电平（&gt;=4T时钟）使CPU复位（CS=FFFFH，其他寄存器=0）</li><li>复位后，CPU从FFFF0H单元开始执行程序</li></ul></li><li><p><code>CLK（时钟信号）</code></p><ul><li>由8284时钟发生器提供的基本定时脉冲</li><li>8086：5~10MHz</li></ul></li><li><p><code>MN/MK（最小/最大模式选择：1/0）</code></p></li><li><p><code>READY（准备就绪）</code></p><ul><li>CPU检测到READY=0，则在T4状态前自动插入若干个Tw，直至READY=1</li><li>保证告诉CPU与低速外设时许的配合</li></ul></li><li><p><code>TEST（测试信号的输入）</code></p><ul><li>CPU执行WAIT指令时测试TEST，若为1，等待；若为0，向下执行</li><li>可使CPU与外部硬件同步</li></ul></li><li><p><code>HOLD（总线保持请求）</code></p><ul><li>输入，高有效</li><li>系统其他部件要求占用总线</li></ul></li><li><p><code>HLDA（总线保持响应）</code></p><ul><li>输出，高有效</li><li>HOLD的会打信号。当其他部件发HOLD=1，CPU则发HLDA=1应答，随后让出三总线控制权(高阻)，申请不见随即获得BUS控制权。此后，HOLD=HLDA=1，直至BUS使用完毕，HOLD=0，CPU重获BUS控制权，并使HLDA=0</li></ul></li><li><p><code>Vcc、GND（+5V供电）</code></p></li></ul><h4 id="最大模式引脚定义"><a href="#最大模式引脚定义" class="headerlink" title="最大模式引脚定义"></a>最大模式引脚定义</h4><p>除224~31引脚外，其余与最小模式相同</p><ul><li><p>S2，S1，S0（总线周期状态）</p><ul><li>最小模式：CPU直接产生RD，WR，M/IO等各种控制信号</li><li>最大模式：CPU发S2 S1 S0—&gt;总线控制器8288—&gt;译码产生各种控制信号</li></ul></li><li><p>LOCK（总线封锁信号）</p><ul><li>LOCK=0，CPU禁止其他部件占用总线</li><li>指令前缀LOCK可使指令执行时LOCK=0</li><li>CPU发两个INTA之间自动使LOCK=0</li></ul></li><li><p>RQ/GT0,RQ/GT1（总线请求/应答）</p><ul><li>请求/应答一条线完成</li><li>可与两个CPU相连，前者优先权高</li></ul></li><li><p>QS1，QS0（指令队列状态信号）</p><ul><li>10：队列空</li><li>01/11：从队列取第一字节/取后续字节</li></ul></li><li><table><thead><tr><th>S2 S1 S0</th><th>操作</th></tr></thead><tbody><tr><td>0 0 0</td><td>发中断响应信号</td></tr><tr><td>0 0 1</td><td>读I/O口</td></tr><tr><td>0 1 0</td><td>写I/O口</td></tr><tr><td>0 1 1</td><td>暂停</td></tr><tr><td>1 0 0</td><td>取指令</td></tr><tr><td>1 0 1</td><td>读存储器</td></tr><tr><td>1 1 0</td><td>写存储器</td></tr><tr><td>1 1 1</td><td>无效</td></tr></tbody></table></li></ul><h4 id="8088与8086CPU区别"><a href="#8088与8086CPU区别" class="headerlink" title="8088与8086CPU区别"></a>8088与8086CPU区别</h4><ul><li>8086：16位机<ul><li>内部、外部DB宽度均为16位</li></ul></li><li>8088：准16位机<ul><li>内部DB宽度16位，外部8位</li><li>8088指令队列长度位4字节</li><li>不同引脚定义<ul><li>AD15<del>8改为A5</del>8</li><li>M/IO改为IO/M</li><li>BHE改为SSO</li></ul></li><li>总线周期状态如表所示</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241629201.png" alt="image-20220722162905559"></p><h3 id="8086存储器组织"><a href="#8086存储器组织" class="headerlink" title="8086存储器组织"></a>8086存储器组织</h3><h4 id="存储器组织"><a href="#存储器组织" class="headerlink" title="存储器组织"></a>存储器组织</h4><ul><li>存储器地址的分段<ul><li>8086由20条地址线<ul><li>寻址空间2^20=1MB（00000H~FFFFFH）</li></ul></li><li>CPU内部寄存器16位<ul><li>不能直接提供20位地址</li><li>解决办法采用分段技术</li><li>将1M空间分成若干个段，每个段&lt;=64K，每个段的段内地址即可用16位表示</li><li>段起始地址应能被16整除，既：地址的最低4位为0</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241629604.png" alt="image-20220722163639278"></li></ul></li></ul></li><li>物理地址<ul><li>即20位实际地址，又称为绝对地址</li><li><code>物理地址=段基址左移4位+段内偏移地址</code></li></ul></li><li>逻辑地址<ul><li>由两个16位地址构成，短地址：段内偏移地址</li></ul></li><li>方便重定位<ul><li>数据块搬家时只需修改段地址</li></ul></li><li>一个物理地址可以对应不同的逻辑地址<ul><li>如：12345H，1200H:0345，1234:0005H，1231：0035</li></ul></li><li>每个段的起始地点能被16整除（对于实模式8086）<ul><li>如：10200H，25010H，12A60H，3F9C0H</li></ul></li></ul><h4 id="存储器分体结构"><a href="#存储器分体结构" class="headerlink" title="存储器分体结构"></a>存储器分体结构</h4><ul><li><p>8086 1MB空间分为两个存储体</p><ul><li>奇地址存储体：与DB高8位相连</li><li>偶地址存储体：与DB低8位相连</li></ul></li><li><table><thead><tr><th>BHE A0</th><th>操作</th><th>DB</th></tr></thead><tbody><tr><td>0 0</td><td>从偶地址起读/写一个字</td><td>AD15-0</td></tr><tr><td>0 1</td><td>从奇地址单元读/写一个字节</td><td>AD15-8</td></tr><tr><td>1 0</td><td>从偶地址单元读/写一个字节</td><td>AD7~0</td></tr><tr><td>1 1</td><td>无效</td><td></td></tr><tr><td>0 1   1 0</td><td>从奇地址起读/写一个字（分两次完成）</td><td>AD15-8  AD7~0</td></tr></tbody></table></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207240959990.png"></p></li><li><p>对准存放：从偶地址开始存放字数据</p></li><li><p>8088 1MB看出一个整体，不用BHE，A0选择，一次只能一个字节</p></li></ul><h4 id="堆栈的概念"><a href="#堆栈的概念" class="headerlink" title="堆栈的概念"></a>堆栈的概念</h4><ul><li>堆栈：存储器中开辟的一个区域,存放需暂时保存的数据。</li><li>存取数据的原则：先进后出/后进先出;一次传送16位/一个字</li><li>有关寄存器：<ul><li>SS:存放段基址;</li><li>SP:堆栈指针,始终指向栈顶</li></ul></li><li>地址增长方式：向上增长，即:地址由高到低增长</li><li>堆栈段可在1M空间内任意浮s动</li><li>堆栈操作:<ul><li>PUSH：压入，SP-2-&gt;SP，低8位-&gt;(SP)，高8位-&gt;(SP+1)</li><li>POP：弹出,依次弹出低8位、高8位，SP+2-&gt;SP</li></ul></li></ul><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241513062.png"></p><ul><li><p>地址锁存器—74LS373</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241513052.png"></p></li><li><p>作用：锁存地址，实现地址/数据的分时复用</p></li></ul></li></ul><h4 id="CPU时序"><a href="#CPU时序" class="headerlink" title="CPU时序"></a>CPU时序</h4><ul><li>典型总线时序简介</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241638639.png" alt="image-20220724163855806"></p><ul><li>系统复位与启动<ul><li>RESET引脚加高电平（&gt;=4T时钟），系统即复位</li><li>复位后的状态：<ul><li>FLAGS=0，CS=FFFFH，IP=0000H</li><li>DS=ES=SS=0000H</li><li>指令队列=0</li><li>其他REG=0</li></ul></li><li>思考，8086程序的第一条指令应放在何处？</li></ul></li></ul><h2 id="8086指令系统"><a href="#8086指令系统" class="headerlink" title="8086指令系统"></a>8086指令系统</h2><ul><li>程序：指令的有序集合</li><li>每种CPU都有各自的指令系统</li><li>指令格式<ul><li><code>操作码 操作数; 注释</code></li><li>操作码：要求CPU作何种操作，（不可少，用助记符表示，有确定的机器码）</li><li>操作数：单/双/无；（可为立即数，寄存器，存储单元，I/O接口）</li><li>例：MOV AL, 3AH; AL&lt;-3AH B03A<ul><li>MOV为操作码,AL为累加寄存器，3AH为操作数，AL&lt;-3AH为注释，B03A为对应得机器码</li></ul></li></ul></li></ul><h3 id="8086寻址方式"><a href="#8086寻址方式" class="headerlink" title="8086寻址方式"></a>8086寻址方式</h3><p>指令中说明操作数所在地址的方法</p><p>寻址方式越多，编程越灵活方便</p><ul><li><p><strong>立即寻址</strong></p><ul><li><p>操作数（立即数）直接包含在指令中</p></li><li><p>例如</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL, 26H    ; 8位立即数</span><br><span class="line">MOV CX, 2A50H  ; 16位</span><br><span class="line">MOV AX, 0FF00H ; 16位</span><br></pre></td></tr></table></figure><ul><li><strong>寄存器寻址</strong><ul><li>从某一个寄存器中寻找数据，赋给目的操作寄存器</li><li><code>指令 目的寄存器 源寄存器</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX, AX ;（将AX寄存器的数的数送于DX寄存器）</span><br><span class="line">MOV CL, AH ; copy</span><br></pre></td></tr></table></figure><ul><li><strong>直接寻址</strong><ul><li>存储单元的有效地址（EA）由指令给出</li><li><code>MOV AL, [2000H] ;</code> 默认段位DS，一个数外面有[]就代表是一个地址，从一个地址中寻找数据给AL</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若DS=3000H，(32000H)=1234H，则执行后：AL=34H</span><br><span class="line">MOV AX, [2000H] ; AX=1234H</span><br><span class="line">MOV AX, ES:[500H] ; 段超越前缀，操作数地址=ES*16+500H</span><br><span class="line">MOV AX, AREA ; 符号地址/立即数</span><br></pre></td></tr></table></figure><ul><li><p><strong>寄存器间接寻址</strong></p><ul><li><code>MOV BX, [SI]</code></li><li>若DS=1000H，SI=2000H，（12000H）=318BH，则执行后BX=318BH</li><li><code>MOV AX,[BP] ; </code>默认段为SS</li><li><code>MOV BX,DS:[BP] ; </code>强制段为DS</li><li><code>MOV AX,ES:[SI] ; </code>段超越前缀</li><li>[ ]中只能为BX,BP,SI,DI之一</li></ul></li><li><p><strong>寄存器相对寻址</strong></p><ul><li><code>MOV BX, COUNT [SI] ;</code> 等价于<code>MOV BX，[COUNT＋SI]</code></li><li>若DS=3000H,SI=2000H,COUNT=400OH，(36000H)=5678H，则:物理地址=16×DS+SI+COUNT=36000H，执行后BX=5678H</li></ul></li><li><p><strong>基址变址寻址</strong></p><ul><li>EA=基址寄存器BX/BP＋变址寄存器SI/DI</li><li><code>MOV AX，[BX][SI];</code> 等价于<code>MOV AX，[BX+SI]</code></li><li>若DS=3000H,BX=1200H,SI=0500H，(31700H)则:执行后AX=ABCDH</li></ul></li><li><p><strong>相对基址变址寻址</strong></p><ul><li><code>MOV AX，MASK[BX][SI];</code>等价于<code>MOV AX，[MASK+BX+SI]</code></li></ul></li><li><p><strong>I/O端口寻址</strong></p><ul><li><code>IN AL,63H ;</code>将端口63中内容–&gt;AL</li><li><code>MOV DX,213H</code></li><li><code>OUT DX,AL;</code> AL-&gt;端口213H</li></ul></li><li><p><strong>隐含寻址</strong></p><ul><li>DAA：操作数存放于规定位置</li></ul></li><li><p><strong>转移类指令寻址</strong></p></li></ul><h3 id="8086指令系统-1"><a href="#8086指令系统-1" class="headerlink" title="8086指令系统"></a>8086指令系统</h3><ul><li>程序是指令的有序集合</li><li>不同的CPU有各自的指令系统<ul><li>机器指令：用二进制码表示</li><li>汇编指令：用助记符表示</li></ul></li><li>8086指令共115条，分为六大类<ul><li>数据传送指令</li><li>算术运算指令</li><li>逻辑运算与循环移位指令</li><li>字符串处理指令</li><li>控制转移指令</li><li>CPU控制指令</li></ul></li></ul><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><ul><li><p>通过数据传送指令</p></li><li><p><strong>MOV</strong> 传送</p><ul><li>格式：<code>MOV 目的,源 ; 目的&lt;-源B/W</code></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207251637722.png" alt="image-20220725163626559"></li></ul></li><li><p><strong>PUSH</strong> 入栈</p><ul><li>格式：<code>PUSH 源; SP&lt;-SP-2,源操作数（字）入栈</code></li><li>默认段：SS</li><li>先进后出</li><li>SP始终指向栈项</li><li>源：<ul><li>16位通用寄存器</li><li>段寄存器</li><li>存储单元</li><li>不能为立即数</li></ul></li><li>SP为<code>FFFEH~0</code>之间的偶地址</li></ul></li><li><p><strong>POP</strong> 出栈</p><ul><li>格式：<code>POP 目的; 目的&lt;-栈顶字，SP&lt;-SP+2</code></li><li>目的：不能为CS，其他和源相同</li></ul></li><li><p><strong>XCHG</strong> 交换指令</p><ul><li>格式：<code>XCHG 目的，源; 目的&lt;--&gt;源</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例： 设AX=2022H， DS=3000H，BX=1800H，（31A00H）=1984H</span><br><span class="line">则： XCHG AX,[BX+200H ] //寻址方式</span><br><span class="line">执行后： AX=1984H，（31A00H）=2022H</span><br></pre></td></tr></table></figure><ul><li><strong>XLAT</strong> 查表指令<ul><li>格式：<code>XLAT [表首地址]; BX&lt;-表首地址，AL&lt;-偏移量; AL&lt;-结果</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查表求n的段码，查表，BX表首地址加上AL你给出的偏移量，然后得出的结果给AL</span><br><span class="line">TAB : DB 40H,79H,24H,3OH,19H DB12H,02H,78H,OOH，18H </span><br><span class="line">MOV AL,n</span><br><span class="line">MOV BX, OFFSET TAB</span><br><span class="line">XLAT ; (AL) &lt;- (BX+AL)</span><br></pre></td></tr></table></figure><ul><li><strong>I/O</strong> 指令<ul><li><strong>IN</strong> 输入指令<ul><li>格式：</li><li><code>IN AL/AX, 端口地址 ; 8位地址</code></li><li><code>IN AL/AX, DX ; 16位地址</code></li></ul></li><li><strong>OUT</strong> 输出指令<ul><li>格式：</li><li><code>OUT 端口地址, AL/AX</code></li><li><code>OUT DX, AL/AX</code></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line">IN AL,OF1H //送8位</span><br><span class="line"></span><br><span class="line">IN AX,80H  // 送16位，端口地址80H,81H中内容-&gt;AX</span><br><span class="line"></span><br><span class="line">MOV DX,310H  // 如果端口地址是16位的话，需要先送DX，再送AL</span><br><span class="line">IN AL,DX</span><br><span class="line"></span><br><span class="line">OUT 85H, AL</span><br><span class="line"></span><br><span class="line">MOV DX, OFF4H</span><br><span class="line">OUT DX, AL ; AL中内容从地址为OFF4H端口输出</span><br></pre></td></tr></table></figure><ul><li><strong>地址目标传送指令</strong><ul><li><strong>LEA</strong> 取有效地址，将源的偏移地址送入目的中<ul><li>格式：<code>LEA 目的, 源; 目的&lt;-源存储单元有效地址</code></li></ul></li><li><strong>LDS</strong> 双字指针-&gt;寄存器和DS<ul><li>格式：<code>LDS 目的，源</code></li><li>目的：常用SI</li><li>源：连续4字节，前两个存放EA，后两个存放段地址</li></ul></li><li><strong>LES</strong> 双字指针-&gt;寄存器和ES<ul><li>格式：<code>LES 目的,源</code></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEA，例</span><br><span class="line">LEA BX, TAB 等价于 MOV BX, OFFSET TAB</span><br><span class="line">设SI=1000H,DS=5000H,(51000H)=1234H,则：</span><br><span class="line">LEA BX, [SI]; </span><br><span class="line">执行后：BX=1000H//LEA将偏移地址送给BX</span><br><span class="line">MOV BX, [SI]; </span><br><span class="line">执行后：BX=1234H//MOV将偏移地址和数据段的数送给BX</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDS 例，这条指令取两个16位，一个送到指定的SI中，一个送到默认的DS数据段中</span><br><span class="line">设DS=1200H，BX=0020H，（12450H）=F346H，（12452H）=0A90H</span><br><span class="line">则：LDS SI,[450H]; </span><br><span class="line">执行后：SI=F346H DS=0A90H</span><br></pre></td></tr></table></figure><ul><li>标志传送指令<ul><li><code>LAHF; AH&lt;-FLAGS低8位</code></li><li><code>SAHF; FLAGS低8位&lt;-AH 8080/8085的FLAG为AH</code></li><li>常在子程序调用及中断过程：保护/恢复标志</li><li><code>PUSHF; FLAGS入栈</code></li><li><code>POPF; 栈顶内容-&gt;FLAGS</code></li></ul></li></ul><h4 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h4><ul><li><p>包括加、减、乘、除4类运算</p></li><li><p>绝大部分指令影响标志位</p></li><li><p>可处理4位类型数据</p></li><li><table><thead><tr><th>二(B)</th><th>十六(H)</th><th>无符号(D)</th><th>带符号(D)</th><th>非压缩(BCD)</th><th>压缩(BCD)</th></tr></thead><tbody><tr><td>00000111</td><td>07</td><td>7</td><td>+7</td><td>7</td><td>07</td></tr><tr><td>10001001</td><td>89</td><td>137</td><td>-119</td><td>无效</td><td>89</td></tr><tr><td>11000101</td><td>C5</td><td>197</td><td>-59</td><td>无效</td><td>无效</td></tr></tbody></table></li></ul><h5 id="加"><a href="#加" class="headerlink" title="加"></a>加</h5><ul><li><strong>ADD</strong> 加法指令<ul><li>格式：<code>ADD 目的, 源;  目的&lt;-源+目的</code></li><li>源：寄存器，存储器</li><li>目的：寄存器，存储器，立即数</li></ul></li><li><strong>ADC</strong> 带进位的加法<ul><li>格式：<code>ADC 目的, 源; 目的&lt;-源+目的+CF</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：ADD，ADC</span><br><span class="line">ADD AL, 18H</span><br><span class="line">ADC BL, CL</span><br><span class="line">ADC AX, DX</span><br><span class="line">ADD AL,COST [BX]</span><br><span class="line"></span><br><span class="line">分析对FLAGS的影响</span><br><span class="line">MOV AL, 5EH ; 01011110=5EH=94</span><br><span class="line">MOV BL, 3CH ; 00111100=3CH=60</span><br><span class="line">ADD AL, BL  ; AL=100111010=154&gt;127</span><br><span class="line"></span><br><span class="line">// FLAGS: CF=0,AF=1,PF=1,ZF=0,SF=1,OF=0与或1=1</span><br><span class="line">// 注意运算指令对FLAGS的影响：</span><br><span class="line">// 无符号数：CF，ZF</span><br><span class="line">// 带符号数: SF,OF,ZF</span><br><span class="line">// BCD码: AF,CF</span><br><span class="line">// 奇偶校验： PF</span><br></pre></td></tr></table></figure><ul><li><strong>INC</strong> 增量指令（自动增1）<ul><li>格式：<code>INC 目的 ; 不影响CF</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INC BL</span><br><span class="line">INC CX</span><br><span class="line">INC WORD PTR [BX]</span><br><span class="line">// PTR代表属性说明，操作数在[BX]中的属性单元中，WORD就代表对16位数进行操作，不加属性说明就代表按字节加</span><br></pre></td></tr></table></figure><ul><li><strong>AAA</strong>  加法的非压缩BCD调整<ul><li>格式：<code>AAA</code> </li><li>对两个非压缩BCD数相加后位于AL中的和进行调整</li><li>使其仍未非压缩BCD，并将结果-&gt;AX</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AL=BCD9， BL=BCD5</span><br><span class="line">ADD AL,BL ; AL=OEH</span><br><span class="line">AAA       ; AX=0104H,CF=AF=1</span><br><span class="line">  ; 对于ASCLL，再加一条OR AX，3030H</span><br></pre></td></tr></table></figure><ul><li><strong>DAA</strong> 加法的压缩BCD调整<ul><li>格式：<code>DAA</code></li><li>将两个压缩BCD数相加后位于AL的和调整为压缩BCD-&gt;AL</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AL=38H, BL=50HM, CL=49H</span><br><span class="line">ADD AL,BL  ; AL=88H</span><br><span class="line">DAA        ; AL=88H</span><br><span class="line">ADD AL,CL  ; AL=88H+49H=D1H</span><br><span class="line">DAA        ; AL=37H,CF=1</span><br><span class="line"></span><br><span class="line">校正方法：</span><br><span class="line">若AL低4位&gt;9或AF=1，则：</span><br><span class="line">AL&lt;-AL+6，调整低4位；</span><br><span class="line">若此时AL高4位&gt;9或CF=1，则：</span><br><span class="line">AL&lt;-AL+60H，调整高4位，且CF=1，</span><br><span class="line">否则CF清0</span><br></pre></td></tr></table></figure><h5 id="减"><a href="#减" class="headerlink" title="减"></a>减</h5><ul><li><strong>SUB</strong> 减法指令<ul><li>格式：<code>SUB 目的，源; 目的&lt;-目的-源</code></li></ul></li><li><strong>SBB</strong> 带借位的减法指令<ul><li>格式：<code>SBB 目的，源; 目的&lt;-目的-源-CF</code></li></ul></li><li><strong>DEC</strong> 减量指令（自动减1）<ul><li>格式：<code>DEC 目的; 目的&lt;-目的-1,不影响CF</code></li></ul></li><li><strong>NEG</strong> 取补指令<ul><li>格式：<code>NEG 目的; 目的&lt;-0-目的，求补码</code></li></ul></li><li><strong>CMP</strong> 比较指令<ul><li>格式：<code>CMP 目的，源;目的-源，不回送结果但影响FLAGS</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AL=B1H，DL=4AH</span><br><span class="line">SUB AL,DL; AL=67H  （CF:0，AF:1，ZF:0，SF:0，OF:1，PF:0）</span><br><span class="line">CMP AL,DL; AL不变，FLAGS同上</span><br></pre></td></tr></table></figure><ul><li> <strong>AAS</strong> 减法的非压缩BCD调整/ASCLL调整</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AL=BCD3，BL=BCD8，则:</span><br><span class="line">SUB AL,BL ; AL=FBH</span><br><span class="line">AAS       ; AL=BCD5,CF=1</span><br><span class="line"></span><br><span class="line"> 00000011</span><br><span class="line">-00001000</span><br><span class="line">=11111011</span><br></pre></td></tr></table></figure><ul><li><strong>DAS</strong> 减法的压缩BCD调整</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AL=56H，CL=98H</span><br><span class="line">SUB AL,CL; AL=56H-98H=BEH</span><br><span class="line">DAS      ; AL=58H,CF=1</span><br></pre></td></tr></table></figure><h5 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h5><ul><li><strong>MUL</strong> 无符号数乘法<ul><li>格式：<code>MUL 源; AX&lt;-AL*源 (字节乘) | DX,AX&lt;-AL*源 (字乘)</code></li><li>若结果的高半部分(字节乘为AH，字乘为DX≠0，CF=OF=1，字乘为DX=0，CF=OF=0)</li><li>源：不能为立即数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MUL DL ; AX&lt;-AL*DL</span><br><span class="line">MUL CX ; DX,AX&lt;-AX*CX</span><br><span class="line">MUL B[SI]   ; AX&lt;-AL*内存中的字节</span><br><span class="line">MUL W[BX]; DX,AX&lt;-AX*内存中字</span><br></pre></td></tr></table></figure><ul><li><p><strong>IMUL</strong> 带符号数乘法</p><ul><li>格式：<code>IMUL 源: AX&lt;-AL*源 (字节乘) | DX,AX&lt;-AX*源(字乘)</code></li><li>若结果的高半部分（AH或DX）为全0或全1，CF=OF=0，表明为符号扩展为;否则，CF=OF=1，表明为乘积的高位</li></ul></li><li><p><strong>AAM</strong> 无符号数乘法的非压缩BCD调整; 调整AL中的非压缩BCD乘积-&gt;AX</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL, 09H</span><br><span class="line">MOV BL, 06H</span><br><span class="line">MUL BL; AL=36H</span><br><span class="line">AAM ; AX=0504H</span><br><span class="line"></span><br><span class="line">;ASCLL码作乘法前，需先将高4位清0</span><br></pre></td></tr></table></figure><h5 id="除"><a href="#除" class="headerlink" title="除"></a>除</h5><ul><li><strong>DIV</strong> 无符号数除法指令； FLAGS无定义<ul><li>格式：<code>DIV 源;</code></li><li>; AL&lt;-AX/源（B）的商(最大为FFH)</li><li>; AH&lt;-余数</li><li>; AX&lt;-DX,AX/源(W)的商（最大为FFFFH）</li><li>; DX&lt;-余数</li></ul></li><li><strong>IDIV</strong> 带符号数除法<ul><li>格式：<code>IDIV 源; 余数的符号与被除数相同</code></li><li>; 字节除:商值范围:-128~+127</li><li>; 字除:商值范围:-32768~+32767</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">除法运算要求被除数是除数的2倍长度，</span><br><span class="line">即，16/8或32/16，否色需扩展高位</span><br><span class="line">扩展方法：将符号位扩展至高位寄存器的所有位</span><br></pre></td></tr></table></figure><ul><li><strong>CBW</strong> 扩展字节为字</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   AH     AL</span><br><span class="line">00000000  0xxxxxxx</span><br><span class="line">11111111  1xxxxxxx</span><br></pre></td></tr></table></figure><ul><li><strong>CWD</strong> 扩展字为双字</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      DX     AX</span><br><span class="line">00000000000000000xxxxxxxxxxxxxxx</span><br><span class="line">11111111111111111xxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><ul><li><strong>AAD</strong> 除法的非压缩BCD调整<ul><li>; 做除法前，将BCD转换为二进制数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AX=0307H，BL=05H，求AX/BL=？</span><br><span class="line">AAD; AL=25H</span><br><span class="line">DIV BL; AX=0207H</span><br><span class="line"></span><br><span class="line">；若为压缩BCD，需优化为非压缩BCD</span><br></pre></td></tr></table></figure><h4 id="逻辑运算与循环移位指令"><a href="#逻辑运算与循环移位指令" class="headerlink" title="逻辑运算与循环移位指令"></a>逻辑运算与循环移位指令</h4><h5 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h5><ul><li><strong>NOT</strong> 取反<ul><li>格式：NOT 目的; 目的&lt;-目的(非)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOT AX</span><br><span class="line">NOT BL</span><br><span class="line">NOT BYTE [BX]</span><br><span class="line"></span><br><span class="line">以下双逻辑操作数逻辑指令执行后：CF=OF=0；ZF，SF，PF反应结果</span><br></pre></td></tr></table></figure><ul><li><strong>AND</strong> 逻辑与<ul><li>格式：<code>AND 目的, 源; 目的&lt;-目的∧源</code></li><li>与0相与,清0；与1相与,不变</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AX=3538H，则：AND AX,OFOFH   ---&gt;AX=0508H</span><br></pre></td></tr></table></figure><ul><li><strong>OR</strong> 逻辑或<ul><li>格式：<code>OR 目的,源; 目的&lt;-目的∨源</code></li><li>与0相或,不变，与1相或,置1</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设AX=0508H，则：OR AX,3030H    ---&gt;AX=3538H</span><br></pre></td></tr></table></figure><ul><li><strong>XOR</strong> 异或<ul><li><code>格式：XOR 目的,源; 目的&lt;-目的 ⊕ 源 ;</code></li><li>; X⊕0=X;X⊕1=X(非)</li><li>与0异或,不变，与1异或求反</li><li>如果<code>目的</code>和<code>源</code>两个值不相同，则异或结果为1。如果<code>目的</code>和<code>源</code>两个值相同，异或结果为0。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IN AL,61H ; 端口61H的D1位控制扬声器</span><br><span class="line">XOR AL, 00000010B</span><br><span class="line">OUT 61H, AL</span><br></pre></td></tr></table></figure><ul><li><strong>TEST</strong> 测试指令<ul><li>格式：<code>TEST 目的, 源; 目的∧源，不回送结果，但影响FLAGS</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEST AL,80H; 测AL中第7位</span><br><span class="line">JNZ T_ALARM; D7=1,转温度报警</span><br><span class="line">TEST AL,40H; 测D6位</span><br><span class="line">JNZ P_ALAR; D6=1,转压力报警</span><br><span class="line">... ... ...</span><br></pre></td></tr></table></figure><h5 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h5><ul><li><strong>SHL</strong> <strong>SAL</strong> 算数/逻辑左移<ul><li>格式：<code>SHL/SAL 目的, 计数值</code></li><li>计数值：移位次数，1次或者CL(多次)</li><li>; CF&lt;-MSB&lt;-LSB&lt;-0</li><li>; 移位后，若最高位≠CF，则OF=1；若最高位=CF，则OF=0</li><li>; 左移1位，相当于乘2</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH, 06H</span><br><span class="line">SAL AH, 1</span><br><span class="line">MOV CL, 03H</span><br><span class="line">SHL DI, CL</span><br><span class="line">SAL BYTE PTR [BX], 1</span><br></pre></td></tr></table></figure><ul><li><strong>SHR</strong> 逻辑右移<ul><li>格式：<code>SHR 目的, 计数值</code></li><li>右移一次，无符号数相当于除以2(余数丢弃)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL, 10000110B; AL=134</span><br><span class="line">SHR AL, 1 ; AL=67</span><br><span class="line">SHR AL, 1  ; AL=33, CF=1</span><br></pre></td></tr></table></figure><ul><li><strong>SAL</strong> 算数右移<ul><li>格式：<code>SAR 目的, 计数值;</code></li><li>; 右移一次，带符号数相当于除以2</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL, 80H; AL=1000000B=-128</span><br><span class="line">MOV CL, 03H</span><br><span class="line">SAR AL, CL;  AL=1110000B=FOH=-16</span><br></pre></td></tr></table></figure><h4 id="字符串指令"><a href="#字符串指令" class="headerlink" title="字符串指令"></a>字符串指令</h4><ul><li><p><strong>CMPSB/W</strong> 字符串比较指令</p><ul><li>格式：<code>CMPSB/W 目的串, 源串; 不影响串内容，但影响FLAGS</code></li><li>比较两个字符串：口令串PASSWORD和键盘输入字符串IN_WORD。若相同，程序向下执行；否则，喇叭响，拒绝执行</li><li>例<img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207271542209.png" alt="image-20220727154206331"></li></ul></li><li><p><strong>SCASB/W</strong> 字符串扫描指令</p><ul><li>格式：<code>SCASB/W 目的串 ; AL/AX--目的串,不回送,但影响FLAGS</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：在字符串中查找关键字&#x27;A&#x27;</span><br><span class="line">      MOV DI, OFFSET STRING; DI&lt;-字符串偏移地址</span><br><span class="line">      MOV CX, COUNT; CX&lt;-串长度</span><br><span class="line">      MOV AL, &#x27;A&#x27;; AL&lt;-关键字&#x27;A&#x27;</span><br><span class="line">      CLD</span><br><span class="line">      PEPNE SCASB; 不等且CX≠0时重复</span><br><span class="line">      JZ FIND; 查到，转FIND</span><br><span class="line">      MOV DI, 0</span><br><span class="line">FIND: MOV BX, DI</span><br><span class="line">  HLT</span><br></pre></td></tr></table></figure><ul><li><strong>LODS</strong> 字符串装入指令<ul><li>格式：<code>LODS 源串; AL/AX&lt;-源串内容，DS:SI自动修改</code></li></ul></li><li><strong>STOS</strong> 数据传存储指令<ul><li>格式：<code>STOSB/W 目的串; 目的串单元&lt;-AL/AX,ES:DI自动修改</code></li><li>目的串：常用于将某数据区填充相同的数</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207271628999.png" alt="image-20220727162823111"></p><h4 id="控制转移类指令"><a href="#控制转移类指令" class="headerlink" title="控制转移类指令"></a>控制转移类指令</h4><h5 id="无条件转移与过程调用返回指令"><a href="#无条件转移与过程调用返回指令" class="headerlink" title="无条件转移与过程调用返回指令"></a>无条件转移与过程调用返回指令</h5><ul><li><strong>JMP</strong> 无条件转移<ul><li>格式：<code>JMP 目的</code></li><li>4种类型<ul><li>段内直接转移：段不变，转向的偏移地址=IP当前+DISP(偏移量)<ul><li><code>JMP SHORT PTR 标号;</code> 8位DISP，转移范围：-128~+127</li><li><code>JMP NEAR PTR 标号;</code> 16位DISP，范围：-32768~+32767 </li></ul></li><li>段内间接转移<ul><li><code>JMP BX; 若BX=4500H,则转向4500H处</code></li></ul></li><li>段间直接转移<ul><li><code>JMP FAR PTR PROG_F;</code> 跳到另一个段</li><li>FAR：属性说明跳到比较远的地址，不是8和16位</li></ul></li><li>段间间接转移<ul><li><code>JMP DWORD PTR [SI+0125H]</code></li></ul></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 段内直接转移</span><br><span class="line">例：地址 机器码PROG_S：ADD  AL, 05H</span><br><span class="line">   0000    0405 NOP</span><br><span class="line">   0002  90JMP SHORT PROG_S</span><br><span class="line">   000590NOP</span><br><span class="line">DISP=目的地址——IP当前=0000H-0005H=-5</span><br><span class="line"></span><br><span class="line">// 段内间接转移</span><br><span class="line">设DS=2000H，BX=100H，(20105H)=4F0H,则</span><br><span class="line">JMP WORD PTR 5 [BX] ; IP=(20000+100+5)=4F0H</span><br><span class="line"></span><br><span class="line">// 段间间接转移</span><br><span class="line">执行前：CS=1200H，IP=05H，DS=2500H</span><br><span class="line">   SI=1300H，（26425H）=4500H</span><br><span class="line">   (26427H)=32F0H</span><br><span class="line">执行：JMP DWORD PTR [SI+0125H]</span><br><span class="line">执行后：转向32F0H:4500H</span><br></pre></td></tr></table></figure><ul><li><strong>CALL RET 过程调用与返回指令</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207281438801.png" alt="image-20220728143826977"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用：CALL 过程名： </span><br><span class="line">  保护断点：SP&lt;-SP-2,CS入栈</span><br><span class="line">    SP&lt;-SP-2,IP入栈</span><br><span class="line">  转子程序入口（与JMP方法一样）</span><br><span class="line">  </span><br><span class="line">返回：RET; IP&lt;-(栈顶字),SP&lt;-SP+2</span><br><span class="line">    CS&lt;-(栈顶字),SP&lt;-SP+2（仅对远调用）</span><br><span class="line">    </span><br><span class="line">返回：RET n; 弹出断电后，再弹出n个字节，SP&lt;-SP+n</span><br></pre></td></tr></table></figure><h5 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h5><ul><li>全为段内短转移</li></ul><table><thead><tr><th>助记符</th><th>功能</th><th>测试条件</th></tr></thead><tbody><tr><td>JC</td><td>有进位/借位</td><td>CF=1</td></tr><tr><td>JNC</td><td>无进位/借位</td><td>CF=0</td></tr><tr><td>JZ/JE</td><td>结果为0/相等</td><td>ZF=1</td></tr><tr><td>JNZ</td><td>结果非0/不等</td><td>ZF=0</td></tr><tr><td>JS</td><td>为负</td><td>SF=1</td></tr><tr><td>JNS</td><td>为正</td><td>SF=0</td></tr><tr><td>JO</td><td>溢出</td><td>OF=1</td></tr><tr><td>JNO</td><td>无溢出</td><td>OF=0</td></tr><tr><td>JP</td><td>奇偶位为1</td><td>PF=1</td></tr><tr><td>JNP</td><td>奇偶位为0</td><td>PF=0</td></tr><tr><td>JA</td><td>高于</td><td>CF=0</td></tr><tr><td>JAE</td><td>高于等于</td><td>CF∨ZF=0</td></tr><tr><td>JB</td><td>低于</td><td>CF=1</td></tr><tr><td>JBE</td><td>低于等于</td><td>CF∨ZF=1</td></tr><tr><td>JG</td><td>大于</td><td>SF⊕OF=1</td></tr><tr><td>JGE</td><td>大于等于</td><td>(SF⊕OF)∨ZF=0</td></tr><tr><td>JL</td><td>小于</td><td>SF⊕OF=1</td></tr><tr><td>JLE</td><td>小于等于</td><td>(SF⊕OF)∨ZF=1</td></tr></tbody></table><ul><li>Above/Below：用于无符号数</li><li>Great/Less：用于带符号数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微机原理&quot;&gt;&lt;a href=&quot;#微机原理&quot; class=&quot;headerlink&quot; title=&quot;微机原理&quot;&gt;&lt;/a&gt;微机原理&lt;/h1&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/07/13/Linux/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/07/13/Linux/</id>
    <published>2022-07-13T01:56:27.000Z</published>
    <updated>2022-07-21T01:00:30.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h2><ul><li>介绍<ul><li>Linux读法：【里纽克斯，里尼科斯，里纳克斯】</li><li>Linux是一款操作系统，免费，开源，安全，高效，稳定，处理高并发强悍</li><li>Linux创始人：linus</li><li>Linux吉祥物：企鹅，Tux</li><li>Linux主要的发行版：<ul><li>RedHat<ul><li>CentOS</li><li>RedHat</li></ul></li><li>Ubuntu</li><li>Suse</li><li>红旗Linux</li><li>还有很多</li></ul></li><li>目前主要的操作系统有<ul><li>window，android，车载系统，linux</li></ul></li></ul></li><li>Linux与Unix的关系<ul><li>Unix是由Ken Thompson和Dennis Ritchie共同发明的<ul><li>Linux的开发过程呢是因为当时Linus使用的基于Unix的操作系统Minix太难用了，于是决定自己开发一个操作系统，采用了Unix的设计理念，于是Linux诞生了。</li></ul></li></ul></li><li>Linux与Window比较<ul><li>Linux<ul><li>免费或少许收费</li><li>软件开源</li><li>相对来说比window安全</li><li>兼具图形界面操作和完整的命令行操作，可以只使用键盘完成一切操作</li></ul></li><li>Window<ul><li>收费</li><li>软件收费</li><li>容易中病毒，三天两头打补丁</li><li>纯图形操作界面，容易入门</li></ul></li></ul></li></ul><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><h3 id="Linux文件目录系统"><a href="#Linux文件目录系统" class="headerlink" title="Linux文件目录系统"></a>Linux文件目录系统</h3><blockquote><p>在Linux世界里，一切皆文件</p></blockquote><blockquote><blockquote><p>Linux的目录中有且只有一个根目录</p></blockquote><blockquote><p>linux的各个目录存放的内容是规划好，不用乱放文件</p></blockquote><blockquote><p>linux是以文件的形式管理我们的设备，因此linux系统，一切皆文件</p></blockquote></blockquote><p>linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/“，然后在此目录下再创建其他的目录。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207131651585.png" alt="image-20220713165122703"></p><ul><li><p><code>/bin</code></p><ul><li>存放着最经常使用的命令（Binary的缩写）</li></ul></li><li><p><code>/sbin</code></p><ul><li>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li></ul></li><li><p><code>/home</code></p><ul><li>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li></ul></li><li><p><code>/root</code></p><ul><li>该目录为系统管理员，也称作超级权限者的用户主目录。</li></ul></li><li><p><code>/lib</code></p><ul><li>系统开机所需要最基本的动态连接共享库，其作用类似于windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li></ul></li><li><p><code>/lost+found</code></p><ul><li>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li></ul></li><li><p><code>/etc</code></p><ul><li>所有的系统管理所需要的配置文件和子目录</li></ul></li><li><p><code>/usr</code></p><ul><li>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</li></ul></li><li><p><code>/boot</code></p><ul><li>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</li></ul></li><li><p><code>/proc</code></p><ul><li>这个目录是一个虚拟的目录，它是系统内存的映射，访间这个目录来获取系统信息.</li></ul></li><li><p><code>/srv</code></p><ul><li>service缩写，该目录存放一些服务启动之后需要提取的数据。</li></ul></li><li><p><code>/sys</code></p><ul><li>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统<code>ysfs</code></li></ul></li><li><p><code>/tmp</code></p><ul><li>这个目录是用来存放一些临时文件的。</li></ul></li><li><p><code>/dev</code></p><ul><li>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</li></ul></li><li><p><code>/media</code></p><ul><li>linux系统会自动识别一些设备，例如u盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li></ul></li><li><p><code>/mnt</code></p><ul><li>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在<code>/mnt/</code>上，然后进入该目录就可以查看里的内容了。</li></ul></li><li><p><code>/opt</code></p><ul><li>这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。</li></ul></li><li><p><code>/usr/local</code></p><ul><li>是另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序。</li></ul></li><li><p><code>/var</code></p><ul><li>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的日录放在这个日录下。包括各种日志文件。</li></ul></li><li><p><code>/selinux</code></p><ul><li>SELinux是一和安全子系统,它能控制程序只能方间特定文件。（<em>security-hanced</em>）</li></ul></li></ul><h3 id="远程登陆Linux系统"><a href="#远程登陆Linux系统" class="headerlink" title="远程登陆Linux系统"></a>远程登陆Linux系统</h3><p>说明:公司开发时候，具体的情况是这样</p><ol><li>linux服务器是开发小组共享的</li><li>正式上线的项目是运行在公网的</li><li>因此程序员需要远程登录到centos进行项目管理或者开发</li></ol><ul><li>Ubuntu系统查询ssh服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装ssh服务器</span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"></span><br><span class="line">// 打开ssh服务</span><br><span class="line">sudo service ssh start</span><br><span class="line"></span><br><span class="line">// 查询ssh服务</span><br><span class="line">sudo ps -e | grep ssh</span><br></pre></td></tr></table></figure><ul><li>CentOS系统开启ssh服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装ssh服务</span><br><span class="line">yum install -y openssl openssh-server</span><br><span class="line"></span><br><span class="line">// 启动ssh服务</span><br><span class="line">systemctl start sshd.service</span><br></pre></td></tr></table></figure><ul><li>开启了ssh服务之后，使用Xhell工具进行远程登陆Linux系统<ul><li>安装好Xshell后，点击文件-&gt;新建</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207131756284.png" alt="image-20220713175606078"></li><li>然后点击确定，点击会话进行连接</li><li>输入你要连接linux用户名和密码</li><li>如果需要连接root用户，则需要在linux系统中开启ssh的root权限（百度一下）</li></ul></li><li>使用FileZilla进行上传和下载文件<ul><li>安装好之后点击导航栏的文件——&gt;站点管理器——&gt;新建站点</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207140909188.png" alt="image-20220714090951189"></li><li>然后点击连接就可以点击连接了，进行连接linux必须安装ssh服务</li></ul></li></ul><h3 id="vi和vim使用"><a href="#vi和vim使用" class="headerlink" title="vi和vim使用"></a>vi和vim使用</h3><ul><li><p>所有的Linux系统都会内建vi文本编辑器。</p></li><li><p>Vim具有程序编辑的能力，可以看做是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p></li><li><p>vi和vim的三种常见模式</p><ul><li>正常模式:<ul><li>以vim打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、贴上』来处理你的文件数据。</li></ul></li><li>插入模式:<ul><li>在正常模式下按下i, l, o,O, a,A, r, R等任何一个字母之后才会进入编辑模式,一般来说按i即可.</li></ul></li><li>命令行模式<ul><li>在vim中按下esc键进入命令行模式，在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的!</li></ul></li></ul></li><li><p>Vim 的常见指令案例</p><ul><li>yy：拷贝当前行</li><li>5yy：拷贝当前5行</li><li>dd：删除当前行</li><li>5dd：删除当前行向下的5行</li><li>在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个</li><li>设置文件行号：set nu，取消文件行号：set nonu</li><li>编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg</li><li>撤销输入：在正常模式下输入u</li><li>编辑文件，光标移动到某行：shift+g</li></ul><ul><li>显示行号：set nu<ul><li>输入行号这个数</li><li>输入shift+g</li></ul></li></ul></li></ul><h4 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>vim [file1 file2 file3 …]</td><td>打开单个或多个文件</td></tr><tr><td>:open file</td><td>在vim窗口中打开一个新文件</td></tr><tr><td>:split file</td><td>在新窗口中打开文件（split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。）</td></tr><tr><td>Ctrl+ww</td><td>移动到下一个窗口</td></tr><tr><td>Ctrl+wj</td><td>移动到下方的窗口</td></tr><tr><td>Ctrl+wk</td><td>移动到上方的窗口</td></tr><tr><td>:close</td><td>最后一个窗口不能使用此命令，可以防止意外退出vim。</td></tr><tr><td>:only</td><td>关闭所有窗口，只保留当前窗口</td></tr><tr><td>:bn</td><td>切换到下一个文件</td></tr><tr><td>:bp</td><td>切换到上一个文件</td></tr><tr><td>:args</td><td>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来</td></tr><tr><td>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a></td><td>打开远程文件，比如ftp或者share folder</td></tr></tbody></table><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><ul><li>插入命令</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在当前位置生前插入</td></tr><tr><td>I</td><td>在当前行首插入</td></tr><tr><td>a</td><td>在当前位置后插入</td></tr><tr><td>A</td><td>在当前行尾插入</td></tr><tr><td>o</td><td>在当前行之后插入一行</td></tr><tr><td>O</td><td>在当前行之前插入一行</td></tr></tbody></table><ul><li>游标移动</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>gg</td><td>移动到文件头。 = [[</td></tr><tr><td>G（shift + g）</td><td>移动到文件尾。 = ]]</td></tr><tr><td>行数 → Shift+G</td><td>移动到第 n 行</td></tr><tr><td>冒号+行号，回车</td><td>比如跳到240行就是 :240回车</td></tr><tr><td>h</td><td>左移一个字符</td></tr><tr><td>l</td><td>右移一个字符，这个命令很少用，一般用w代替。</td></tr><tr><td>k</td><td>上移一个字符</td></tr><tr><td>j</td><td>下移一个字符</td></tr><tr><td>w</td><td>向前移动一个单词（光标停在单词首部）</td></tr><tr><td>b</td><td>向后移动一个单词 2b 向后移动2个单词</td></tr><tr><td>e</td><td>同w，只不过是光标停在单词尾部</td></tr><tr><td>ge</td><td>同b，光标停在单词尾部。</td></tr><tr><td>^</td><td>移动到本行第一个非空白字符上。</td></tr><tr><td>0</td><td>移动到本行第一个字符上</td></tr><tr><td>HOME</td><td>移动到本行第一个字符。同0健。</td></tr><tr><td>$</td><td>移动到行尾 3$ 移动到下面3行的行尾</td></tr><tr><td>f（find）</td><td>fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</td></tr><tr><td>F</td><td>同f，反向查找</td></tr></tbody></table><ul><li>撤销和重做</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>u</td><td>撤销（Undo）</td></tr><tr><td>U</td><td>撤销对整行的操作</td></tr><tr><td>Ctrl + r</td><td>重做（Redo），即撤销的撤销。</td></tr></tbody></table><ul><li>删除命令</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>3x</td><td>删除当前光标开始向后三个字符</td></tr><tr><td>X</td><td>删除当前字符的前一个字符。X=dh</td></tr><tr><td>dl</td><td>删除当前字符， dl=x</td></tr><tr><td>dh</td><td>删除前一个字符</td></tr><tr><td>dd</td><td>删除当前行</td></tr><tr><td>dj</td><td>删除上一行</td></tr><tr><td>dk</td><td>删除下一行</td></tr><tr><td>10d</td><td>删除当前行开始的10行。</td></tr><tr><td>D</td><td>删除当前字符至行尾。D=d$</td></tr><tr><td>d$</td><td>删除当前字符之后的所有字符（本行）</td></tr><tr><td>kdgg</td><td>删除当前行之前所有行（不包括当前行）</td></tr><tr><td>jdG（jd shift + g）</td><td>删除当前行之后所有行（不包括当前行）</td></tr><tr><td>:1,10d</td><td>删除1-10行</td></tr><tr><td>:11,$d</td><td>删除11行及以后所有的行</td></tr><tr><td>:1,$d</td><td>删除所有行</td></tr><tr><td>J(shift + j)</td><td>删除两行之间的空行，实际上是合并两行。</td></tr></tbody></table><ul><li>拷贝，剪贴和粘贴</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>nyy</td><td>拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</td></tr><tr><td>p</td><td>在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</td></tr><tr><td>shift+p</td><td>在当前行前粘贴</td></tr><tr><td>:1,10 co 20</td><td>将1-10行插入到第20行之后。</td></tr><tr><td>:1,$ co $</td><td>将整个文件复制一份并添加到文件尾部。</td></tr><tr><td>ddp</td><td>交换当前行和其下一行</td></tr><tr><td>xp</td><td>交换当前字符和其后一个字符</td></tr><tr><td>ndd</td><td>剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</td></tr><tr><td>:1,10d</td><td>将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</td></tr><tr><td>:1, 10 m 20</td><td>将第1-10行移动到第20行之后。</td></tr></tbody></table><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p><ul><li>退出命令</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>ZZ</td><td>保存并退出</td></tr><tr><td>:q!</td><td>强制退出并忽略所有更改</td></tr><tr><td>:e!</td><td>放弃所有修改，并打开原来文件。</td></tr><tr><td>:q</td><td>未修改直接退出</td></tr></tbody></table><ul><li>注释命令</li></ul><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>3,5 s/^/#/g</td><td>注释第3-5行</td></tr><tr><td>3,5 s/^#//g</td><td>解除3-5行的注释</td></tr><tr><td>1,$ s/^/#/g</td><td>注释整个文档。</td></tr><tr><td>:%s/^/#/g</td><td>注释整个文档，此法更快。</td></tr></tbody></table><h4 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h4><ul><li>:!command</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>:!ls</td><td>列出当前目录下文件</td></tr><tr><td>:!perl -c script.pl</td><td>检查perl脚本语法，可以不用退出vim，非常方便。</td></tr><tr><td>:!perl script.pl</td><td>执行perl脚本，可以不用退出vim，非常方便。</td></tr><tr><td>:suspend或Ctrl - Z</td><td>挂起vim，回到shell，按fg可以返回vim。</td></tr></tbody></table><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>:help or F1</td><td>显示整个帮助</td></tr><tr><td>:help xxx</td><td>显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。</td></tr><tr><td>:help ‘number’</td><td>Vim选项的帮助用单引号括起</td></tr><tr><td>:help &lt;Esc&gt;</td><td>特殊键的帮助用&lt;&gt;扩起</td></tr><tr><td>:help -t</td><td>Vim启动参数的帮助用-</td></tr><tr><td>:help i_&lt;Esc&gt;</td><td>插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式</td></tr></tbody></table><p>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p><h4 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>重复前一次命令</td></tr><tr><td>:set ruler?</td><td>查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</td></tr><tr><td>:scriptnames</td><td>查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</td></tr><tr><td>:set list</td><td>显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了 expandtab，那么tab将被扩展为空格。</td></tr></tbody></table><ul><li><p>Vim教程</p><ul><li>在Unix系统上 $ vimtutor</li><li>在Windows系统上 :help tutor</li></ul></li><li><p>录制宏:</p><ul><li>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</li></ul></li><li><p>:syntax 列出已经定义的语法项</p></li><li><p>:syntax clear 清除已定义的语法规则</p></li><li><p>:syntax case match 大小写敏感，int和Int将视为不同的语法元素</p></li><li><p>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p></li></ul><h3 id="关机-amp-重启-amp-注销"><a href="#关机-amp-重启-amp-注销" class="headerlink" title="关机&amp;重启&amp;注销"></a>关机&amp;重启&amp;注销</h3><ul><li>关机<ul><li>shutdown -h now：立即关机</li><li>shutdown -h 1：1分钟后关机</li><li>half：直接关机</li></ul></li><li>重启<ul><li>shutdown -r now：立即重启</li><li>reboot：重启系统</li></ul></li><li>sync<ul><li>把内存的内容同步到磁盘</li><li>当我们关机或重启的时，都应该先执行以下sync指令，把内存的数据存入磁盘，防止数据丢失</li></ul></li><li>登陆<ul><li>登陆时尽量少用root账号登陆，因为他是系统管理员，最大的权限，避免操作失误，可以使用普通用户登陆，登陆后在使用<code>su &quot;用户名&quot;</code>命令来切换成系统管理员身份</li></ul></li><li>注销<ul><li>logout：注销</li><li>logout在图形运行界面无效</li><li>在运行级别3下有效</li></ul></li></ul><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><blockquote><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的月户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><blockquote><p>Linux的用户至少属于一个组</p></blockquote></blockquote><p><img src="C:\Users\LONG\AppData\Roaming\Typora\typora-user-images\image-20220714104524476.png" alt="image-20220714104524476"></p><ul><li><p>添加用户</p><ul><li><code>adduser [选项] 用户名 [用户组]（常用）</code><ul><li>当创建用户成功后，会自动的创建和用户同名的家目录</li><li>-h Dir指定家目录位置</li><li>ingroup：指定用户所属的组</li><li>可以是使用<code>adduser -help</code>查看参数怎么写</li></ul></li></ul></li><li><p>指定密码</p><ul><li><code>passwd 用户名</code></li></ul></li><li><p>删除用户</p><ul><li><code>deluser 用户名（常用）</code></li><li>删除用户及家目录<ul><li><code>deluser -remove-home 用户名</code></li></ul></li><li>删除用户组<ul><li><code>deluser -group 用户组名</code></li></ul></li><li><em>删除用户时尽量不要删除家目录</em></li></ul></li><li><p>查询用户信息</p><ul><li><code>id 用户名</code></li><li>当该用户不存在时，则会报无此用户</li></ul></li><li><p>切换用户</p><ul><li>在操作Linux中，如果当前用户的权限不够，可以通过su指令，切换到高权限用户，比如root</li><li><code>su 用户名</code></li><li><code>exit</code> 返回原先用户</li></ul></li><li><p>查看当前用户</p><ul><li><code>whoami</code></li></ul></li><li><p>用户组</p><ul><li>类似于角色，系统可以对有共性的多个用户进行统一的管理。</li><li>增加组：<ul><li><code>addgroup [参数] GROUP</code></li></ul></li><li>删除组<ul><li><code>delgroup [参数] GROUP</code></li></ul></li><li>修改用户组<ul><li><code>usermod -g 用户组 用户</code></li></ul></li></ul></li><li><p>用户和组相关的文件</p><ul><li>/etc/passwd 文件<ul><li>用户( user!的配置文件，记录用户的名种信息</li><li>每行的含义:用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录shell</li></ul></li><li>/etc/shadow文件<ul><li>口令的配置文件</li><li>每行的含义。登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</li></ul></li><li>/atc/group文件<ul><li>组(group)的配置文件，己录unux包含的组的信息</li><li>每行含义:组名:口令:组标识号:组内用户列表</li></ul></li></ul></li></ul><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><h4 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h4><ul><li>0，关机</li><li>1，单用户【找回丢失密码】</li><li>2，多用户状态没有网络服务</li><li>3，多用户状态有网络服务</li><li>4，系统未使用保留给用户</li><li>5，图形界面</li><li>6，系统重层</li><li>常用的运行级别是3和5，要更改默认的运行级别可修改文件<code>/etc/inittab的id:5:initdefault</code>这一行中的数字</li><li>命令<code>init[012356]</code></li></ul><h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4><ul><li><p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。</p></li><li><p><code>man</code></p><ul><li>获取帮助信息</li><li><code>man [命令或配置文件]</code> （功能描述:获得帮助信息）</li></ul></li><li><p><code>help</code></p><ul><li>获取帮助信息</li><li><code>help 指令</code>  (功能描述。获得shell内置命令的帮助信息)</li></ul></li></ul><h4 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h4><ul><li><p><strong>pwd</strong>指令</p><ul><li><code>pwd</code>：显示当前工作目录的绝对路径</li></ul></li><li><p><strong>ls</strong>指令</p><ul><li><code>ls [选项] 目录或是文件</code>：显示当前目录</li><li>-a：显示当前目录所有的文件和目录，包括隐藏的</li><li>-l：以列表的方式显示信息</li></ul></li><li><p><strong>cd</strong>指令</p><ul><li><code>cd [参数]</code>：切换到指定目录目录</li></ul></li><li><p><strong>mkdir</strong>指令</p><ul><li><code>mkdir [选项] 要创建的目录</code>：创建目录</li><li>-p：创建多级目录</li></ul></li><li><p><strong>rmdir</strong>指令</p><ul><li><code>rmdir 空目录</code>：删除指定空目录</li></ul></li><li><p><strong>rm -rf</strong>指令</p><ul><li><code>rm -rf 非空目录</code>：删除指定非空目录</li><li>-r：递归删除整个文件夹</li><li>-f：强制删除不提示</li></ul></li><li><p><strong>touch</strong>指令</p><ul><li><code>touch 文件名称</code>：创建空文件</li></ul></li><li><p><strong>cp</strong>指令</p><ul><li><code>cp [选项] source dest</code>：拷贝文件到指定目录</li><li>-r：递归复制整个文件夹</li></ul></li><li><p><strong>mv</strong>指令</p><ul><li>mv mvoldNameFile newNameFile (功能描述。重命名)</li><li>mv /temp/movefile /targetFolder (功能描述。移动文件)</li></ul></li><li><p><strong>cat</strong>指令</p><ul><li><code>cat [选项] 要查看的文件常用选项</code>：查看文件内容</li><li>-n :显示行号</li><li>| more：分页显示（管道命令）</li></ul></li><li><p><strong>more</strong>指令</p><ul><li><p>more指令是一企基于vI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键</p></li><li><p><code>more 要查看的文件</code></p></li></ul></li></ul><ul><li><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空格（space）</td><td>代表向下翻一页</td></tr><tr><td>Enter</td><td>代表向下翻【一行】</td></tr><tr><td>q</td><td>代表立即离开more，不在显示文件内容</td></tr><tr><td>Ctrl+F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl+B</td><td>返回上一屏</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table></li><li><p><strong>less</strong>指令</p><ul><li><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p></li><li><p><code>less 要查看的文件</code></p></li><li><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻动一页</td></tr><tr><td>[pagedown]</td><td>向下翻动一页</td></tr><tr><td>[pageup]</td><td>向上翻动一页</td></tr><tr><td>/字串</td><td>向下搜索[字串]的功能，n：向下查找，N：向上查找</td></tr><tr><td>?字串</td><td>向上搜索[字串]的功能，n：向上查找，N：向下查找</td></tr><tr><td>q</td><td>离开less</td></tr></tbody></table></li></ul></li><li><p>**&gt;<strong>指令和</strong>&gt;&gt;**指令</p><ul><li><code>&gt;</code>输出重定向</li><li><code>&gt;&gt;</code>追加</li><li><code>ls &gt; 文件</code>：功能描述:列表的内容写入文件a.txt中（覆盖写)</li><li><code>ls &gt;&gt; 文件</code>：功能描述:列表的内容追加到文件aa.txt的末尾</li><li><code>cat文件1 &gt; 文件2</code>：功能描述:将文件1的内容覆盖到文件2</li></ul></li><li><p><strong>echo</strong>指令</p><ul><li>输出内容到控制到</li><li><code>echo [选项] [输出内容]</code></li></ul></li><li><p><strong>head</strong>指令</p><ul><li>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</li><li><code>head 文件</code>：查看文件头10行内容</li><li><code>head -n 5 文件</code>：查看文件头5行内容，5可以是任意行数</li></ul></li><li><p>**tail **指令</p><ul><li>tail 用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。</li><li><code>tail 文件</code>：查看文件后10行内容</li><li><code>tail -n 5 文件</code>：查看文件后5行内容，5可以是任意行数</li><li><code>tail -f 文件</code>：实时追踪该文档的所有更新</li></ul></li><li><p><strong>ln</strong>指令</p><ul><li>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</li><li><code>ln -s [原文件或目录] [软连接名]</code>：给原文件创建一个软链接</li></ul></li><li><p><strong>history</strong>指令</p><ul><li>查看已经执行过历史命令，也可以执行历史指令</li><li><code>history</code>：查看已经执行过的历史命令</li><li><code>history 10</code>：查看最近执行的10条历史命令</li><li><code>!10</code>：执行历史编号为10的指令</li></ul></li></ul><h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><ul><li><strong>date</strong>指令<ul><li>显示当前日期</li><li><code>date</code>：显示当前时间</li><li><code>date +%Y</code>：显示当前年份</li><li><code>date +%m</code>：显示当前月份</li><li><code>date +%d</code>：显示当前是哪一天</li><li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月日时分秒</li><li>设置系统时间</li><li><code>date -s 字符串时间</code></li></ul></li><li><strong>cal</strong>指令<ul><li>查看日历信息</li><li><code>cal [选项]</code></li></ul></li></ul><h4 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h4><ul><li><p><strong>find</strong>指令</p><ul><li><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p></li><li><p><code>find [搜索范围] [选项]</code></p></li><li><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name &lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件，也可以使用通配符查找</td></tr><tr><td>-user &lt;用户名&gt;</td><td>查找属于指定用户所有的文件</td></tr><tr><td>-size &lt;文件大小&gt;</td><td>按照指定的文件大小查找文件（+n大于,-小于n，n等于）</td></tr></tbody></table></li></ul></li><li><p><strong>locate</strong>指令</p><ul><li>locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</li><li><code>locate 搜索文件</code></li><li>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。</li></ul></li><li><p><strong>grep</strong>指令 和 **|**管道符号</p><ul><li><p>grep过滤查找</p><ul><li><p> <code>grep [选项] 查找内容 原文件</code></p></li><li><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-i</td><td>忽略字母大小写</td></tr></tbody></table></li></ul></li><li><p>管道符，“**|**”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p></li></ul></li></ul><h4 id="压缩和解压缩类"><a href="#压缩和解压缩类" class="headerlink" title="压缩和解压缩类"></a>压缩和解压缩类</h4><ul><li><p><strong>gzip</strong>/<strong>gunzip</strong>指令</p><ul><li>gzip用于压缩文件，gunzip用于解压文件</li><li><code>gzip 文件</code>：压缩文件，只能将文件压缩为.gz文件</li><li><code>gunzip文件.gz</code>：解压缩文件命令</li></ul></li><li><p><strong>zip</strong>/<strong>unzip</strong>指令</p><ul><li>zip用于压缩文件，unzip用于解压的，这个在项目打包发布中很有用的</li><li><code>zip [选项] 名称.zip file(将要压缩的目录或内容) </code>：压缩文件和目录的命令<ul><li>-r：递归压缩，及压缩目录</li></ul></li><li><code>unzip [选项] 名称.zip</code>：解压缩文件<ul><li>-d&lt;目录&gt;：指定解压后文件的存放目录</li></ul></li></ul></li><li><p><strong>tar</strong>指令</p><ul><li><p>tar指令是打包指令，最后打包后的文件是.tar.gz的文件。</p></li><li><p><code>tar [选项] 名称.tar.gz 打包的内容</code> ：打包目录，压缩后的文件格式为.tar.gz</p></li><li><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table></li></ul></li></ul><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><blockquote><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</p><ul><li>所有者<ul><li>一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。</li></ul></li><li>所在组</li><li>其它组<ul><li>除文件的所有者和所在组的用户外，系统的某它用户都是文件的其它组。</li></ul></li><li>改变用户所在的组</li></ul></blockquote><ul><li><p>查看文件的所有者/目录所在组</p><ul><li>指令：<code>ls -ahl</code></li></ul></li><li><p>修改文件所有者</p><ul><li>指令：<code>chown 用户名 文件名</code></li><li>同时更改所有者以及所有组<ul><li><code>chown newowner:newgroup file</code></li></ul></li><li>-R 如果是目录，则使其下所有文件或目录递归生效</li></ul></li><li><p>组的创建</p><ul><li><code>addgroup 组名</code></li><li><code>groupadd 组名</code></li></ul></li><li><p>修改文件所在组</p><ul><li>指令：<code>chgrp 组名 文件名</code></li><li>-R 如果是目录，则使其下所有文件或目录递归生效</li></ul></li><li><p>修改用户所在组</p><ul><li>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。</li><li><code>usermod -g 组名 用户名</code></li><li><code>usermod -d 目录名 用户名</code>：改变该用户登陆的初始目录</li></ul></li></ul><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul><li><p>权限基本介绍</p><ul><li><p>ls -l中显示的内容如下</p></li><li><p>```<br>-rwxrw-r– 1 root root 1213 七月 2 09:39 abc</p><p>按顺序来说:<br>第0位 - 代表文件的类型</p><pre><code>-：普通文件d：目录l：软链接c：字符设备（键盘，鼠标）b：块文件（硬盘）</code></pre><p>第1-3位 rwx 代表文件所有者权限</p><pre><code>r：读权限w：写权限x：可被执行-：无权限</code></pre><p>第4-6位 rw- 代表文件所在组的用户的权限</p><pre><code>r：读权限w：写权限-：无x权限</code></pre><p>第7-9位个 r– 代表文件其他组的用户的权限</p><pre><code>r：读权限-：无w权限-：无x权限</code></pre><p>第10位 1 代表</p><pre><code>文件：1目录：目录中子目录的个数</code></pre><p>第11个 root 代表用户名<br>第12个 root 代表用户所在组<br>第13个 1213 代表文件的大小，如果是目录则显示4096<br>第14个 七月 2 09:39 代表文件最后修改的时间<br>第15个 abc 代表文件名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 第0位确定文件类型(d,-,l,c,b)</span><br><span class="line"></span><br><span class="line">  - 第1-3位确定所有者（该文件的所有者)拥有该文件的权限。---User</span><br><span class="line"></span><br><span class="line">  - 第4-6位确定所属组（同用户组的)拥有该文件的权限，---Group</span><br><span class="line"></span><br><span class="line">  - 第7-9位确定其他用户拥有该文件的权限---Other</span><br><span class="line"></span><br><span class="line">  - rwx权限详解</span><br><span class="line"></span><br><span class="line">    - rwx可用数字表示：r=4，w=2，x=1，rwx=7</span><br><span class="line">    - rwx作用到文件</span><br><span class="line">    - [r]代表可读(read)：可以读取,查看</span><br><span class="line">    - [w]代表可写(write)：可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</span><br><span class="line">    - [x]代表可执行(execute)：可以被执行</span><br><span class="line">    - rwx作用到目录</span><br><span class="line">      - [r]代表可读(read)：可以读取，ls查看目录内容</span><br><span class="line">      - [w]代表可写(write)：可以修改,目录内创建+删除+重命名目录</span><br><span class="line">      - [x]代表可执行(execute)：可以进入该目录</span><br><span class="line"></span><br><span class="line">- 权限的管理</span><br><span class="line"></span><br><span class="line">  - 通过chmod指令，可以修改文件或者目录的权限。</span><br><span class="line">  - 第一种方式：+、-、=变更权限</span><br><span class="line">    - u:所有者，g：所有组，o：其他人，a：所有人(u、g、o的总和)</span><br><span class="line">    - `chmod u=rwx,g=rx,o=x 文件目录名`</span><br><span class="line">    - `chmod o+w 文件目录名`</span><br><span class="line">    - `chmod a-x 文件目录名`</span><br><span class="line">  - 第二种方式：通过数字更改权限</span><br><span class="line">    - r=4，w=2，x=1（rwx=4+2+1=7）</span><br><span class="line">    - `chmod 751 文件目录名` </span><br><span class="line"></span><br><span class="line">### crond任务调度</span><br><span class="line"></span><br><span class="line">- 任务调度:是指系统在某个时间执行的特定的命令或程序。</span><br><span class="line"></span><br><span class="line">- 任务调度分类:</span><br><span class="line"></span><br><span class="line">  - 1.系统工作，有些重要的工作必须周而复始地执行。如病毒扫描等</span><br><span class="line">  - 2.个别用户工作。个别用户可能希望执行某些程序，比如对mysql数据库定时的备份。</span><br><span class="line"></span><br><span class="line">- crontab [选项]</span><br><span class="line"></span><br><span class="line">- | 选项 | 功能                          |</span><br><span class="line">  | ---- | ----------------------------- |</span><br><span class="line">  | -e   | 编辑crontab定时任务           |</span><br><span class="line">  | -l   | 查询crontab任务               |</span><br><span class="line">  | -r   | 删除当前用户所有的crontab任务 |</span><br><span class="line"></span><br><span class="line">- 例如</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">*/1 * * * * ls -l /etc/ &gt;&gt; /tmp/to.txt</span><br><span class="line"># 每1min执行一次将/etc/列表添加到/tmp/to.txt</span><br><span class="line"></span><br><span class="line"># 格式如下：</span><br><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 7) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br><span class="line"></span><br><span class="line">* * * * *    每分钟执行</span><br><span class="line">*/1 * * * *  每1分钟执行</span><br><span class="line">0 * * * *    每小时执行</span><br><span class="line">0 0 * * *    每天执行</span><br><span class="line">0 0 * * 0    每周执行</span><br><span class="line">0 0 1 * *    每月执行</span><br><span class="line">0 0 1 1 *    每年执行</span><br><span class="line">1 * * * *    每小时的第1分钟执行</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="磁盘分区与挂载"><a href="#磁盘分区与挂载" class="headerlink" title="磁盘分区与挂载"></a>磁盘分区与挂载</h3><ul><li><p>分区基础知识</p><ul><li>mbr份区:<ul><li>最多支持四个主分区</li><li>系统只能安装在主分区</li><li>扩展分区要占一个主分区</li><li>MBR最大只支持2TB，但拥有最好的兼容性</li></ul></li><li>gtp分区:<ul><li>支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区)</li><li>最大支持18EB的大容量(EB=1024 PB，PB=1024 TB)</li><li>windows7 64位以后支持gtp</li></ul></li></ul></li><li><p>Linux分区</p><ul><li><code>lsblk -f</code> | <code>lsblk</code>：查看系统的分区和挂载的情况</li><li>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一生文件结构，Linux中每个分区都是月来组成整个文件系统的一部分。</li><li>Linux采用了一和叫“载入”的处理方法，它的整个文件系统口包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存诸空间在一个目录下获得。</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207181443176.png" alt="image-20220718144307941"></li></ul></li><li><p>硬盘说明</p><ul><li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li><li>对于IDE硬盘，驱动器标识符为“hdx<del>“,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），“</del>代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第三个IDE硬盘上的第二个主分区或扩展分区。</li><li>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法—样。</li></ul></li></ul><h4 id="如何增加一块硬盘"><a href="#如何增加一块硬盘" class="headerlink" title="如何增加一块硬盘"></a>如何增加一块硬盘</h4><ul><li><p>虚拟机添加硬盘</p></li><li><p>分区：<code>fdisk /dev/sdb1(分区目录)</code>：对硬盘进行分区</p></li><li><p>格式化硬盘：<code>mkfs -t ext4 /dev/sdb1(分区目录)</code></p></li><li><p>挂载：</p><ul><li>先创建一个目录 /home/newdisk</li><li> 挂载：<code>mount /dev/sdb1(分区目录) /home/newdisk(挂载目录)</code></li></ul></li><li><p>自动挂载</p><ul><li><p>打开一个文件：<code>vim /etc/fstab</code></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207181707026.png" alt="image-20220718170747491"></p></li><li><p>完成之后，执行<code>mount -a</code>生效</p></li></ul></li><li><p>如何卸载硬盘</p><ul><li><code>umount 设备名称或挂载目录</code></li></ul></li></ul><h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><ul><li>查询系统整体磁盘管理情况<ul><li><code>df -h</code></li></ul></li><li>查询指定目录的磁盘占用情况<ul><li><code>du -h /目录</code></li><li>-s：指定目录占用大小汇总</li><li>-h：带计量单位</li><li>-a：带文件</li><li>-c：列出明细的同时，增加汇总值</li><li>–max-depth=1：子目录深度</li></ul></li><li>统计目录下文件的个数<ul><li><code>ls -l /目录 | grep &quot;^-&quot; | wc -l</code></li></ul></li><li>统计目录下目录的个数<ul><li><code>ls -l /目录 | grep &quot;^d&quot; | wc -l</code></li></ul></li><li>统计目录下文件的个数，包括子目录下的文件<ul><li><code>ls -lR /目录 | grep &quot;^- | wc -l&quot;</code></li></ul></li><li>统计目录下目录的个数，包括子目录下的目录<ul><li><code>ls -lR /目录 | grep &quot;^d&quot; | wc -l</code></li></ul></li><li>树状显示结构<ul><li><code>tree</code></li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul><li><p>介绍</p><ul><li><p>在Linux中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。</p></li><li><p>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。</p></li><li><p>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程,通常使用后台方式执行。</p></li><li><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</p></li></ul></li></ul><h4 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h4><ul><li><p>查看进程树</p><ul><li><code>pstree [选项]</code>   </li></ul></li><li><p><code>ps</code>：用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207191702119.png" alt="image-20220719170213701"></li><li>-a：显示当前终端的所有进程信息</li><li>-u：以用户的格式显示进程信息</li><li>-x：显示后台进程运行的参数</li><li>-ef：查看父进程</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps指令详解：</span><br><span class="line">指令：ps -aux | grep more</span><br><span class="line"></span><br><span class="line">指令说明：</span><br><span class="line">System V展示风格</span><br><span class="line">USER：用户名称</span><br><span class="line">PID：进程号</span><br><span class="line">%CPU：进程占用CPU的百分比</span><br><span class="line">%MEM：进程占用的物理内存的百分比</span><br><span class="line">VSZ：进程占用的虚拟内存大小（单位KB）</span><br><span class="line">RSS：进程占用的物理内存大小（单位KB）</span><br><span class="line">TT：终端名称，缩写</span><br><span class="line">STAT：进程状态， </span><br><span class="line">S-：睡觉</span><br><span class="line">s-：表示该进程是会话的先导进程</span><br><span class="line">N-：表示进程拥有比普通优先级更低的优先级</span><br><span class="line">R-：正在运行</span><br><span class="line">D-：短期等待</span><br><span class="line">Z-：僵死进程</span><br><span class="line">T-：被跟踪或者被停止等等</span><br><span class="line">STARTED：进程的启动时间</span><br><span class="line">TIME：CPU时间，即进程使用CPU的总时间</span><br><span class="line">COMMAND：启动进程所用的命令和参数，如果时间过长会被截断显示</span><br></pre></td></tr></table></figure><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><ul><li>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</li><li><code>kill [选项] 进程号</code>：通过进程号杀死进程</li><li><code>killall 进程名称</code> ：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用</li><li>-9：表示强迫进程立即停止</li></ul><h4 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h4><ul><li>服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。【原理图】</li><li>service管理指令<ul><li><code>service 服务名 start | stop | restart | reload | status</code></li><li>在centos7.0后使用<code>systemctl</code></li></ul></li><li>查看服务名<ul><li>方法1：service –status-all</li><li>方法2：/etc/init.d/服务名称</li></ul></li><li><code>chkconfig</code>指令<ul><li>通过<em>chkconfig</em>命令可以给各个运行级别设置自启动/关闭</li><li><code>chkconfig --list | grep xxx</code></li><li><code>chkconfig 服务名 --list</code></li><li><code>chkconfig --level 5(级别) 服务名 on/off </code></li></ul></li></ul><h4 id="监控进程"><a href="#监控进程" class="headerlink" title="监控进程"></a>监控进程</h4><ul><li>动态监控进程<ul><li>top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。</li><li><code>top [选项]</code></li><li>-d 秒数：指定top命令每隔几秒更新，默认是3秒在top命令的交互模式当中可以执行的命令</li><li>-i：使top不是显示任何闲置或者僵死进程</li><li>-p：通过指定监控进程ID来仅仅监控某个进程的状态</li><li>交互操作</li><li>P：以CPU使用率排序，默认是此项</li><li>M：以内存的使用率排序</li><li>N：以PID排序</li><li>q：退出top</li></ul></li><li>监控网络状态<ul><li><code>netstat [选项]</code>：查看系统网络情况</li><li>-an：按一定顺序排列输出</li><li>-p：显示哪个进程在调用</li></ul></li></ul><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><ul><li>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写―些程序。</li></ul><h4 id="shell脚本快速入门"><a href="#shell脚本快速入门" class="headerlink" title="shell脚本快速入门"></a>shell脚本快速入门</h4><ul><li>shell脚本要求<ul><li>脚本以<code>#!/bin/bash</code>开头</li><li>脚本需要有可执行权限</li><li>执行方式<ul><li>+x，输入shell文件名称执行<ul><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207201507443.png" alt="image-20220720150723077"></li></ul></li><li><code>sh 文件程序</code></li></ul></li></ul></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">这就是一个shell脚本，写完之后，给他一个执行权限就可以执行了</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Shell的变量"><a href="#Shell的变量" class="headerlink" title="Shell的变量"></a>Shell的变量</h4><ul><li>介绍<ul><li>Linux Shell中的变量分为,系统变量和用户自定义变量。系统变量:$HOME、SPWD. $SHELL、 $USER等等</li><li>比如:echo SHOME等等..</li><li>显示当前shell中所有变量:set</li></ul></li><li>shell变量的定义<ul><li>基本语法<ul><li>定义变量：<code>变量=值</code></li><li>撤销变量：<code>unset 变量</code></li><li>声明静态变量：<code>readonly 变量</code>，注意：不能unset</li></ul></li><li>定义变量的规则<ul><li>变量名称可以由字母、数字、下划线组成，但是不能以数字开头</li><li>等号两侧不能有空格</li><li>变量名称一般习惯为大写</li></ul></li><li>将命令的返回值赋给变量<ul><li>A=`ls -la` 反引号，运行里面的命令，并把结果返回变量A</li><li><code>A=$(ls -la)</code> 等价于反引号</li></ul></li></ul></li><li>设置环境变量<ul><li>基本语法<ul><li><code>export 变量名=变量名</code>：将shell变量输出为环境变量</li><li><code>source 配置文件</code>：让修改后的配置信息立即生效</li><li><code>echo $变量名</code>：查询环境变量的值</li></ul></li></ul></li><li>位置参数变量<ul><li>当我们执行一个shell脚本时,如果希望获取到命令行得参数信息，就可以使用到位置参数变量，比如：<code>./myshell.sh 100 200</code>,这个就是一个执行shell命令行，可以在myshell脚本中获取到参数信息</li><li>基本语法<ul><li><code>$n</code>：n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含,如$[10}</li><li><code>$*</code>：代表命令行中所有的参数，$*把所有的参数看成一个整体</li><li><code>$@</code>：代表命令行中所有的参数，不过$@把每个参数区分对待</li><li><code>$#</code>：代表命令行中所有参数的个数</li></ul></li></ul></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;参数个数:<span class="variable">$#</span>&quot;</span></span><br><span class="line">                          </span><br><span class="line">执行：</span><br><span class="line">./myShell.sh 100 200</span><br></pre></td></tr></table></figure><ul><li>预变量<ul><li>就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</li><li>基本语法<ul><li><code>$$</code>：当前进程的进程号</li><li><code>$!</code>：后台运行的最后一个进程的进程号</li><li><code>$?</code>：最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，如果这个变量的值为非0（具体是那个数，由命令自己来决定），则证明上一个命令执行不正确了</li></ul></li></ul></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前进程的进程号：$$&quot;</span></span><br><span class="line"><span class="comment">#在后台的方式运行一个程序，查看最后的一个进程号</span></span><br><span class="line">./myShell.sh &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;最后的进程号：$!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;执行的值：$?&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h4><ul><li>如何在shell中进行各种运算操作</li><li>基本语法<ul><li><code>&quot;$((运算式))</code>“或<code>&quot;$&#123;运算式&#125;&quot;</code></li><li><code>expr m + n</code>(运算符之间要有空格)</li><li><code>expr m +-*/% n</code>：运算符加减乘除，取余</li></ul></li></ul><h4 id="Shell条件判断"><a href="#Shell条件判断" class="headerlink" title="Shell条件判断"></a>Shell条件判断</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ conidition ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">如果符合条件则执行块</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#结束</span></span><br></pre></td></tr></table></figure><ul><li><code>[ condition ]</code>：非空返回true，可使用$?验证(0为true，&gt;1为false)<ul><li>两个整数的比较<ul><li>-lt：小于</li><li>-le：小于等于</li><li>-eq：等于</li><li>-gt：大于</li><li>-ge：大于等于</li><li>-ne：不等于</li></ul></li><li>按照文件权限进行判断<ul><li>-r：有读的权限</li><li>-w：有写的权限</li><li>-x：有执行的权限</li></ul></li><li>按照文件类型进行判断<ul><li>-f：文件存在并且是一个常规的文件</li><li>-e：文件存在</li><li>-d：文件存在并是一个目录</li></ul></li></ul></li></ul><h4 id="Shell流程控制"><a href="#Shell流程控制" class="headerlink" title="Shell流程控制"></a>Shell流程控制</h4><ul><li><strong>if elif语句</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">elif</span> [条件判断式]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><strong>case 语句</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名 <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;值1&quot;</span>)</span><br><span class="line">如果变量名的值等于值1，则执行程序1</span><br><span class="line">;;</span><br><span class="line"><span class="string">&quot;值2&quot;</span>)</span><br><span class="line">如果变量名的值等于值2，则执行程序2</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">如果以上都没有满足的，执行此程序</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><ul><li><strong>for 循环语句</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值1 值2 值3...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((初始值;循环控制条件;变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li><strong>while 循环</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件判断式 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li><strong>read读取控制台输入</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> [选项] <span class="string">&quot;提示信息&quot;</span> 参数</span><br><span class="line"><span class="comment"># read -p &quot;你输入的值是：&quot; NUM1</span></span><br><span class="line"></span><br><span class="line">-p：知道读取值时的提示符</span><br><span class="line">-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了</span><br></pre></td></tr></table></figure><h4 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h4><ul><li>shell编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个。</li><li>系统函数<ul><li>basename<ul><li>返回完整路径最后的/的部分，常用于获取文件名</li><li><code>basename [pathname] [suffix]</code></li><li>``basenamem [string] [suffix]`</li><li>suffix是选项，如果写了，就代表把那一段给剪切掉</li></ul></li><li>dirname<ul><li>返回完整路径最后/的前面的部分，常用于返回路径的部分</li><li><code>dirname 文件绝对路径</code></li></ul></li></ul></li><li>自定义函数</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function funName()</span><br><span class="line">&#123;</span><br><span class="line">代码块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">funName 参数1 参数2 参数...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h1&gt;&lt;h2 id=&quot;Linux介绍&quot;&gt;&lt;a href=&quot;#Linux介绍&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="系统" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vue3组合API</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/05/17/Vue3%E7%BB%84%E5%90%88API/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/05/17/Vue3%E7%BB%84%E5%90%88API/</id>
    <published>2022-05-17T00:07:41.000Z</published>
    <updated>2022-05-20T02:14:25.814Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Vue3-组合API"><a href="#Vue3-组合API" class="headerlink" title="Vue3 组合API"></a>Vue3 组合API</h1><h2 id="使用-vite-构建-Vue"><a href="#使用-vite-构建-Vue" class="headerlink" title="使用 vite 构建 Vue"></a>使用 vite 构建 Vue</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init vite-app &lt;project-name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd &lt;project-name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="组合API"><a href="#组合API" class="headerlink" title="组合API"></a>组合API</h2><p>通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。</p><p><img src="https://v3.cn.vuejs.org/images/options-api.png" alt="Vue 选项式 API: 按选项类型分组的代码"></p><p>这是一个大型组件的示例，其中<strong>逻辑关注点</strong>按颜色进行分组。</p><p>这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块。</p><p>如果能够将同一个逻辑关注点相关代码收集在一起会更好。而这正是组合式 API 使我们能够做到的。</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup()"></a>setup()</h3><blockquote><p>新的 <code>setup</code> 选项在组件被创建<strong>之前</strong>执行，一旦 <code>props</code> 被解析完成，它就将被作为组合式 API 的入口。</p></blockquote><blockquote><p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数， <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p></blockquote><blockquote><p><code>setup</code>中应该避免使用this，因为它找不到组件实例。<code>setup</code> 的调用发生在 <code>data</code> property、<code>computed</code> property 或 <code>methods</code> 被解析之前</p></blockquote><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>使用<code>setup</code>时，它接受了两个参数<code>props</code>和<code>context</code></p><ul><li>props<ul><li>就是用来接收外部传入的props属性值，来进行操作</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = toRefs(props)</span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>context<ul><li>context是一个普通的对象，用来操作在setup中有用的值</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Attribute (非响应式对象，等同于 $attrs)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插槽 (非响应式对象，等同于 $slots)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件 (方法，等同于 $emit)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露公共 property (函数)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.expose)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问组件的property"><a href="#访问组件的property" class="headerlink" title="访问组件的property"></a>访问组件的property</h4><ul><li>执行setup时，只可以访问以下prop<ul><li><code>props</code></li><li><code>attrs</code></li><li><code>slots</code></li><li><code>emit</code></li></ul></li><li>无法访问以下组件<ul><li><code>data</code></li><li><code>computed</code></li><li><code>methods</code></li><li><code>refs</code></li></ul></li></ul><h4 id="渲染操作"><a href="#渲染操作" class="headerlink" title="渲染操作"></a>渲染操作</h4><p>Vue2操作数据时的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 @click=&quot;changeEvent&quot;&gt;计数；&#123;&#123;count&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeEvent () &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">      count()&#123;</span><br><span class="line">          console.log(this.count + &quot;watch&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">change:&#123;</span><br><span class="line">        get()&#123;</span><br><span class="line">            console.log(this.count + &quot;get&quot;)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(value)&#123;</span><br><span class="line">            console.log(this.count + &quot;set&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用vue2操作数据时一旦数据繁杂之后就会很复杂，不容易维护</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Vue3使用setup时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1 @click=&quot;changeNum&quot;&gt;计数；&#123;&#123;num&#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;username&#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;age&#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;reverseAge&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref,toRefs,reactive,computed,watch&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup () &#123;</span><br><span class="line">      const num = ref(0);</span><br><span class="line">       // 在setup中声明函数</span><br><span class="line">      function changeNum () &#123;</span><br><span class="line">        num.value += 10;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      // 如果setup需要返回一个对象，使用reactive来进行响应式绑定</span><br><span class="line">      const user = reactive(&#123;</span><br><span class="line">          username: &quot;小鱼！&quot;,</span><br><span class="line">          age:18,</span><br><span class="line">          // 使用computed属性来进行监听</span><br><span class="line">          reverseAge: computed(() =&gt; &#123;</span><br><span class="line">            return user.type.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      // 使用watch监听单个数据,并返回两个参数（新val，旧val）</span><br><span class="line">      watch(num,(newVal,prevVal) =&gt; &#123;</span><br><span class="line">          console.log(newVal,prevVal)</span><br><span class="line">      &#125;)</span><br><span class="line">        </span><br><span class="line">      // 使用watch监听多个数据，使用数组包裹</span><br><span class="line">      watch([num,user],(newVal,prevVal) =&gt;&#123;</span><br><span class="line">          console.log(newVal,prevVal)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      // 通过return返回回去之后可以访问</span><br><span class="line">      // 使用...Refs后可以重构user对象，直接访问其中的属性</span><br><span class="line">      return &#123; num, changeNum,...toRefs(user),&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue3生命周期钩子"><a href="#Vue3生命周期钩子" class="headerlink" title="Vue3生命周期钩子"></a>Vue3生命周期钩子</h3><p>Vue3中生命周期在Vue2的生命周期前加了on</p><p>同时Vue3生命周期函数接收一个回调函数</p><p>当组件被调用时执行，Vue3生命周期中<code>beforeCreate</code>与<code>created</code>被<code>setup</code>代替</p><p>Vue3使用生命周期函数的时候需要先引用</p><table><thead><tr><th>选项式API</th><th>Hook inside setup</th><th>功能</th></tr></thead><tbody><tr><td>beforeCreate</td><td>Not needed* setup()</td><td></td></tr><tr><td>created</td><td>Not needed* setup()</td><td>在 beforeCreate 和 created 之前执行，创建的是 data 和 method</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>组件挂载到节点上之前执行的函数</td></tr><tr><td>mounted</td><td>onMounted</td><td>组件挂载完成后执行的函数</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>组件更新之前执行的函数</td></tr><tr><td>updated</td><td>onUpdated</td><td>组件更新完成之后执行的函数</td></tr><tr><td>beforeUnmount</td><td>onBeforeUnmount</td><td>组件卸载之前执行的函数</td></tr><tr><td>unmounted</td><td>onUnmounted</td><td>组件卸载完成后执行的函数</td></tr><tr><td>errorCaptured</td><td>onErrorCaptured</td><td>当捕获一个来自子孙组件的异常时激活钩子函数</td></tr><tr><td>renderTracked</td><td>onRenderTracked</td><td>跟踪虚拟DOM重新渲染时调用,钩子接收debugger event作为参数,此事件告诉你哪个操作跟踪了组件以及该操作的目标对象和键。</td></tr><tr><td>renderTriggered</td><td>onRenderTriggered</td><td>当虚拟DOM重新渲染被触发时调用,和renderTracked类似,接收debugger event作为参数,此事件告诉你是什么操作触发了重新渲染,以及该操作的目标对象和键。</td></tr><tr><td>activated</td><td>onActivated</td><td>被包含在 <keep-alive> 中的组件，会多出两个生命周期钩子函数，被激活时执行；</td></tr><tr><td>deactivated</td><td>onDeactivated</td><td>比如从 A 组件，切换到 B 组件，A 组件消失时执行</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    onBeforeMount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;beforeMounte: 挂在渲染之前&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;mounted：挂载渲染之后&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    onBeforeUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;beforeUpdate：更新之前&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    onUpdated(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;updated：更新之后&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    onBeforeUnmount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;beforeDestory:销毁之前&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    onUnmounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;destoryed:销毁之后&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Provide-amp-inject"><a href="#Provide-amp-inject" class="headerlink" title="Provide &amp; inject"></a>Provide &amp; inject</h3><blockquote><p>Provide和inject一般用于父组件传递给子组件数据</p></blockquote><ul><li>provide有两个参数<ul><li>name: <String>类型</li><li>value: 数据</li></ul></li><li>inject<ul><li>name: <String>类型</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Father.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!--使用组件标签--&gt;</span><br><span class="line">    &lt;Son /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">// 引入Provide与reactive   </span><br><span class="line">import &#123; reactive, provide &#125; from &quot;vue&quot;</span><br><span class="line">// 引入子组件</span><br><span class="line">import Son from &quot;./components/Son.vue&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">    // 在setup中使用reactive创建响应对象</span><br><span class="line">    const student = reactive(&#123;</span><br><span class="line">      name: &quot;小小&quot;,</span><br><span class="line">      age: 18</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 使用provide进行传输数据</span><br><span class="line">    provide(&quot;student&quot;, student)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Son.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;学生&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;用户名：&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 引入inject</span><br><span class="line">import &#123; inject &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    // 使用inject来获取provide传输的数据</span><br><span class="line">    const student = inject(&quot;student&quot;)</span><br><span class="line">    // 返回数据并解构</span><br><span class="line">    return &#123; ...student &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;Vue3-组合API&quot;&gt;&lt;a href=&quot;#Vue3-组合API&quot; class=&quot;headerlink&quot; title=&quot;Vue3 组合API&quot;&gt;&lt;/a&gt;Vue3 组合API&lt;/h1&gt;&lt;h2 id=&quot;使用-vite-</summary>
      
    
    
    
    <category term="Vue" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/Vue/"/>
    
    
    <category term="Vue3" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/05/08/MySQL/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/05/08/MySQL/</id>
    <published>2022-05-08T07:35:53.000Z</published>
    <updated>2022-05-31T08:25:31.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQl"><a href="#SQl" class="headerlink" title="SQl"></a>SQl</h1><h2 id="数据库概述及数据准备"><a href="#数据库概述及数据准备" class="headerlink" title="数据库概述及数据准备"></a>数据库概述及数据准备</h2><h3 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h3><ul><li><p>数据库定义</p><ul><li>理解：存放数据的仓库（增、删、改、查）</li><li>定义：数据库（<code>Datebase</code> 简称<code>DB</code>）是一个软件产品</li><li>数据库按照数据结构组织、存储和管理数据的，建立在计算机存储设备上的仓库。</li></ul></li><li><p>数据库特点</p><ul><li>数据共享</li><li>数据一致性和可维护性</li><li>安全性</li><li>完整性</li><li>并发控制</li><li>数据恢复</li></ul></li></ul><h3 id="常见的数据库管理系统"><a href="#常见的数据库管理系统" class="headerlink" title="常见的数据库管理系统"></a>常见的数据库管理系统</h3><ul><li><strong>Oracle</strong> 甲骨文<ul><li><code>Oracle</code>他是世界上第一个商品化的关系型数据库管理系统</li><li>传统行业、政府部分用<code>Oracle</code>居多</li></ul></li><li><strong>MySQL</strong><ul><li>小型的关系型数据库管理系统，开发者瑞典<code>Mysql AB</code>公司</li><li>现属于<code>Oracle</code>旗下产品（收购）。</li><li>特点：体积小、速度快、总体拥有成本低、开放源码</li><li>互联网公司用<code>MySQL</code>居多</li></ul></li><li><strong>DB2</strong><ul><li>美国<code>IBM</code>公司开发的一款关系型数据库管理系统，<code>DB2</code>有很多版本，<br>可以运行在掌上产品到大型机不同的终端机器上</li></ul></li><li><strong>Sybase</strong><ul><li>美国<code>Sysbase</code>公司推出的一款关系型数据库</li><li>是一种基于<code>UNIX</code>或<code>WindowsNT</code>平台上客户端/服务器环境下的大型数据库</li></ul></li><li><strong>Access</strong>：微软发布的关系型数据库管理系统，把数据库引擎的图形用户界面<br>和开发工具结合在一起的数据库管理系统。</li><li><strong>MS SqlServer</strong>：支持标准<code>sql</code>的数据库管理系统<ul><li>微软推出的一款关系型数据库管理系统，运行在<code>Windows NT</code>平台上支持客户端/服务器模式的数据库，采用标准的<code>SQL</code>语言。</li></ul></li></ul><h3 id="sql、DB、DBMS-分别是什么"><a href="#sql、DB、DBMS-分别是什么" class="headerlink" title="sql、DB、DBMS 分别是什么"></a>sql、DB、DBMS 分别是什么</h3><ul><li><p><strong>DB</strong>：<code>DataBase</code>（数据库，数据库实际上在硬盘上以文件的形式存在）</p></li><li><p><strong>DBMS</strong>：<code>DataBase Management System</code>（数据库管理系统，常见的有，<code>MySQL</code> <code>Oracle</code> <code>DB2</code> <code>Sybase</code> <code>SqlServer</code></p></li><li><p><strong>SQL</strong>：结构化查询语言，是一门标准通用的语言，标准的<code>sql</code>适用于所有的数据库产品，<code>sql</code>属于高级语言，sql 语句再执行的时候，实际上内部也会先进行编译，然后再执行<code>sql</code>，<code>sql</code>语句的编译由 DBMS 完成</p><blockquote><p>DBMS 负责执行 sql 语句，通过执行 sql 语句来操作 DB 当中的数据</p><p>DBMS - （执行）-&gt; SQL - （操作） -&gt; DB</p></blockquote></li></ul><h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><ul><li><code>SQL</code>，一般发音为<code>sequel</code>，<code>SQL</code>的全称<code>Structured Query Language</code>，<code>SQL</code>用来和数据库打交道，完成和数据库的通信，<code>SQL</code>是一套标准。但是每一个数据都有自己的特性别的数据库没有，当使用这个数据库特性相关的功能，这时<code>SQL</code>语句可能就不是标准了，（90%以上的<code>SQL</code>都是通用的）</li></ul><h3 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h3><ul><li>数据库，通常是一个或工组文件，保存了一些符合特定规格的数据数据库对应的英语单词是<code>DataBase</code>, 简称:DB,数据库软件称为数据库管理系统(DBMS)， 全称为<code>DataBase Management System</code>,如: <code>Oracle</code>、<code>SQL Server</code>、<code>MySq|</code>、<code>Sybase</code>、<code>informix</code>、 <code>DB2</code>、<code>interbase</code>、<code>PostgreSql</code>。</li></ul><h3 id="MySQl-概述"><a href="#MySQl-概述" class="headerlink" title="MySQl 概述"></a>MySQl 概述</h3><ul><li><code>MySQL</code>最初是由<code>MySQL AB</code>公司开发的-套关系型数据库管理系统( <code>RDBMS Relational</code><br><code>Database Mangerment System</code>)。。</li><li><code>MySQL</code>不仅是最流行的开源数据库，而且是业界成长最快的数据库，每天有超过 7 万次的<br>下载量，其应用范围从大型企业到专有的嵌入应用系统。</li><li><code>MySQL</code> AB 是由两个瑞典人和一个芬兰人: <code>David Axmark</code>、<code>Allan Larsson</code> 和<code>Michael &quot;Monty</code>“<code>Widenius</code>在瑞典创办的。。<br>在 2008 年初，<code>Sun Microsystems</code>收购了<code>MySQL AB</code>公司。在 2009 年，<code>Oracle</code> 收购了<code>Sun</code>公司，使<code>MySQL</code>并入<code>Oracle</code>的数据库产品线。</li></ul><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><blockquote><p>表（table）：是数据库最基本的组成单元，数据库是用来存储数据的，数据库中有很多表，每一个表都是一个独立的单元，表也是一个结构化的文件，由行和列组成，行称为数据戒记录，列称为字段， 字段又包含：字段名称、字段类型、长度、约束。</p></blockquote><ul><li><p>表：<code>table</code></p><ul><li><p><code>table</code>是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强</p></li><li><p>一个表包括行和列：</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学号（int) 姓名(varchar)年龄(int)</span><br><span class="line">-----------------------------------------</span><br><span class="line">110  张三   20</span><br><span class="line">120  李四   21</span><br></pre></td></tr></table></figure><ul><li>行：被称为数据 / 记录</li><li>列：被称为字段（<code>column</code>）<ul><li>每一个字段都应该包括哪些属性？<ul><li>字段名、数据类型、相关的类型</li></ul></li></ul></li></ul><h3 id="SQL-语句的分类"><a href="#SQL-语句的分类" class="headerlink" title="SQL 语句的分类"></a>SQL 语句的分类</h3><ul><li><code>SQL</code>语句包括增删改查，那么究竟怎么分类？</li><li><strong>DQL（数据查询语言）</strong>：查询语句，凡是<code>select</code>语句都是<code>DQL</code></li><li><strong>DML（数据操作语言）</strong>：<code>insert</code>、<code>delete</code>、<code>update</code>，对表当中的数据进行增删改</li><li><strong>DDL（数据定义语言）</strong>：<code>create</code>、<code>drop</code>、<code>alter</code>，对表结构的增删改</li><li><strong>TCL（事务控制语言）</strong>：<code>commit</code>提交事务，<code>rollback</code>回滚事务（<code>TCL</code>中的<code>T</code>是<code>Transaction</code>）</li><li><strong>DCL（数据控制语言）</strong>：<code>qrant</code>授权、<code>revoke</code>撤销权限等</li></ul><h3 id="导入演示数据"><a href="#导入演示数据" class="headerlink" title="导入演示数据"></a>导入演示数据</h3><ul><li><p>一、登录<code>mysql</code>数据库管理系统</p><ul><li><code>dos</code>命令窗口<ul><li><strong>mysql -u root -p</strong></li></ul></li></ul></li><li><p>二、查看有哪些数据库</p><ul><li><strong>show databases</strong>;（这个不是<code>SQL</code>语句，是<code>MySQL</code>的命令）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自带的数据库</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><ul><li><p>三、创建属于我们自己的数据库</p><ul><li>**create database 数据库名称;**（这个不是<code>SQL</code>语句，属于<code>MySQL</code>的命令)</li><li><code>bjpowernode</code>是数据库名字</li></ul></li><li><p>四、使用<code>bjpowernode</code>数据库</p></li><li><p>**use 数据库名称;**（这个不是<code>SQL</code>语句，属于<code>MySQL</code>的命令）</p></li><li><p>五、查看当前使用的数据库中有那些表格</p></li><li><p>**show tables;**（这个不是<code>SQL</code>语句，属于<code>MySQL</code>的命令）</p></li><li><p>六、初始化数据</p><ul><li><p><a href="https://github.com/HAODEabcd/Note/blob/master/SQL/bjpowernode.sql">https://github.com/HAODEabcd/Note/blob/master/SQL/bjpowernode.sql</a> 文件地址</p></li><li><p><strong>source D:././././bjpowernode.sql</strong></p></li><li><p>注意：数据初始化完成之后，有三张表</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------------------+</span><br><span class="line">| Tables_in_bjpowernode      |</span><br><span class="line">+----------------------------+</span><br><span class="line">| dept |</span><br><span class="line">| emp                |</span><br><span class="line">| salqrade  |</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure><ul><li><p><strong>sql 脚本</strong></p><ul><li><code>bjpowernode.sql</code>，这个文件以<code>sql</code>结尾，这样的文件被称为”<code>sql</code>脚本”。什么是<code>sql</code>脚本？</li><li>当一个文件的扩展名是<code>.sql</code>，并且该文件中编写了大量的<code>sql</code>语句，我们成这样的文件为<code>sql</code>脚本</li><li>直接使用 source 命令可以执行<code>sql</code>脚本</li><li><code>sql</code>脚本中的数据量太大的时候，无法打开，请使用<code>source</code>命令完成初始化</li><li><code>sql</code>脚本有很多，每一个都不一样，我这个仅仅是练习使用</li></ul></li><li><p>六、删除数据库：<strong>drop database 数据库名称;</strong></p></li></ul><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_bjpowernode |</span><br><span class="line">+-----------------------+</span><br><span class="line">| dept                  |(部门表)</span><br><span class="line">| emp                   |(员工表)</span><br><span class="line">| salgrade              |(工资等级表)</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure><ul><li>查看表结构<ul><li><strong>desc 数据库中表的名称;</strong></li><li><code>desc</code> <code>dept / emp / salgrade</code>;</li></ul></li><li>查看表中的数据<ul><li><strong>select * from 数据库中表的名称;</strong></li><li><code>select * from emp;</code></li></ul></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>查看<strong>mysql</strong>版本</p><ul><li><code>mysql -Version</code></li><li><code>select version()</code></li></ul></li><li><p>创建数据库</p><ul><li><code>create database 数据库名称</code></li></ul></li><li><p>查询当前使用的数据库</p><ul><li><code>select database()</code></li><li>查询数据库版本 <code>select version()</code></li></ul></li><li><p>终止一条语句</p><ul><li><code>\c</code> 可以终止一条语句</li></ul></li><li><p>退出<strong>MySQL</strong></p><ul><li><code>exit</code> 退出<code>mysql</code></li></ul></li></ul><h2 id="查看演示数据的表结构"><a href="#查看演示数据的表结构" class="headerlink" title="查看演示数据的表结构"></a>查看演示数据的表结构</h2><ul><li><p>查看数据库</p><ul><li><code>show databases;</code></li></ul></li><li><p>使用数据库</p><ul><li><code>use 数据库名称;</code></li></ul></li><li><p>查看当前使用的数据库</p><ul><li><code>select database();</code></li></ul></li><li><p>查看数据库中的表</p><ul><li><code>show tables;</code></li></ul></li><li><p>查看其他数据库中的表</p><ul><li><code>show tables from 数据库名称;</code></li></ul></li><li><p>查看表结构</p><ul><li><code>desc 表名称;</code></li></ul></li><li><p>查看表的创建语句</p><ul><li><code>show create table 表名称;</code></li></ul></li></ul><h2 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h2><h3 id="简单的查询"><a href="#简单的查询" class="headerlink" title="简单的查询"></a>简单的查询</h3><ul><li><strong>select 字段名 1，字段名 2，字段名 3，……from 表名;</strong></li><li><code>select ename,sal from emp;</code></li><li>提示：<ul><li>任何一条<code>sql</code>语句都以”;”（分号）结尾</li><li><code>sql</code>语句不区分大小写</li><li>字段可以参与数学运算<ul><li><code>select ename,sal * 12 from emp</code></li></ul></li><li>查完之后列可以重命名<ul><li><code>select 字段1，字段2 as 更改后的列名 from emp;</code></li><li><code>select ename,sal * 12 as yearsal from emp;</code></li><li><code>as</code>关键字可以省略</li></ul></li><li>标准<code>sql</code>语句中，要求用字符串使用单引号括起来-</li></ul></li><li>查询所有数据<ul><li><code>select * from emp;</code></li><li>实际开发中不建议使用，效率较低</li></ul></li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p><strong>语法格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">字段，字段……</span><br><span class="line">from</span><br><span class="line">数据库中的数据表名称</span><br><span class="line">where</span><br><span class="line">条件;</span><br><span class="line"></span><br><span class="line">执行顺序：先from，然后where，最后select</span><br></pre></td></tr></table></figure><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>=</code></td><td>等于</td></tr><tr><td><code>&lt;&gt;</code>或<code>!=</code></td><td>不等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>between…and…</code></td><td>两个值之间，等同于 <code>x &gt;= 1 and x &lt;= 3</code></td></tr><tr><td><code>is null</code></td><td>为<code>null</code>（<code>is not null</code> 不为空）</td></tr><tr><td><code>and</code></td><td>并且</td></tr><tr><td><code>or</code></td><td>或者</td></tr><tr><td><code>in</code></td><td>包含，相当于多个<code>or</code>（就是在这个几个值当中寻找），<code>in(条件1，条件……)</code>，<code>in</code>里面的条件就是精确的值，不是范围</td></tr><tr><td><code>not in</code></td><td>不包含，不在这几个值当中</td></tr><tr><td><code>not</code></td><td><code>not</code>可以取非，主要用作<code>js</code>或<code>in</code>中</td></tr><tr><td><code>like</code></td><td><code>like</code>称为模糊查询，要掌握两个符号，<code>%</code>和<code>_</code>，<code>%</code>代表任意多个字符，<code>_</code>代表任意一个字符</td></tr></tbody></table><blockquote><p>在数据库中 NULL 不是一个值，代表什么也没有，为空，空不是一个值，不能用等号衡量，必须使用 is null 或者 is not null</p><p>当运算符优先级不确定的时候加小括号</p><p>模糊查询中，要掌握两个特殊符号，一个是<code>%</code>一个是<code>_</code></p></blockquote><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><p><code>order by</code></p></li><li><p>例：<code>select 字段 from 表名 order by 字段</code></p></li><li><p>默认是升序</p></li><li><p><code>asc</code>表示升序，<code>desc</code>表示降序</p></li><li><p>升序</p><ul><li><code>select 字段 from 表名 order by 字段</code></li><li><code>select 字段 from 表名 order by 字段 asc</code></li></ul></li><li><p>降序</p><ul><li><code>select 字段 from 表名 order by 字段 desc</code></li></ul></li><li><p>多个字段排序</p></li></ul><blockquote><p>两个字段进行排序，如果前面那个字段可以正常排序，就不执行后面的那个字段排序，如果前面的那个字段无法进行排序，就执行后面的那个字段排序</p><p>越靠前的字段越能起到主导作用，只有当前面的字段无法排序时，才会启用后面的字段</p></blockquote><ul><li><p><code>select 字段 from 表名 order by 字段 desc ， 字段 asc</code></p></li><li><p>条件排序</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 执行顺序</span><br><span class="line">select</span><br><span class="line">*(字段)3</span><br><span class="line">from</span><br><span class="line">表名1</span><br><span class="line">where</span><br><span class="line">条件2</span><br><span class="line">order by</span><br><span class="line">字段4</span><br></pre></td></tr></table></figure><h3 id="（分组-聚合-多行、单行处理）函数"><a href="#（分组-聚合-多行、单行处理）函数" class="headerlink" title="（分组/聚合/多行、单行处理）函数"></a>（分组/聚合/多行、单行处理）函数</h3><h4 id="分组函数-多行函数"><a href="#分组函数-多行函数" class="headerlink" title="分组函数/多行函数"></a><strong>分组函数/多行函数</strong></h4><ul><li><p>多行处理函数就是多行最后得出一个结果</p></li><li><p><code>count()</code> 计数</p><ul><li><code>count(*)</code> 不是统计某个字段中数据的个数，而是统计的总记录条数（和某个字段无关）</li><li><code>count(字段)</code>表示统计的这个字段中不为 NULL 的数据总数量</li><li><code>count(字段)</code></li></ul></li><li><p><code>sun()</code> 求和</p><ul><li><code>sum(字段)</code></li></ul></li><li><p><code>avg()</code> 平均值</p><ul><li><code>avg(字段)</code></li></ul></li><li><p><code>max()</code> 最大值</p><ul><li><code>max(字段)</code></li></ul></li><li><p><code>min()</code> 最小值</p><ul><li><code>min(字段)</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(字段) from 表   ----&gt; 求和</span><br><span class="line">select max(字段) from 表   ----&gt; 最大值</span><br><span class="line">select min(字段) from 表----&gt; 最小值</span><br><span class="line">select count(字段) from 表   ----&gt; 计数</span><br><span class="line">select avg(字段) from 表   ----&gt; 计数</span><br></pre></td></tr></table></figure><blockquote><p>所有的分组函数都是对“某一组”数据进行操作的。</p><p>分组函数也叫多行处理函数，多行处理函数的特点，输入多行，最终输出一行。</p><p>分组函数自动忽略 NULL。</p><p>数据库中数学表达式中有 NULL，进行数学运算，最后都是 NULL，没有值</p><p>分组函数不可直接使用在 where 子句当中，因为 group by 是在 where 之后才会执行</p></blockquote><h4 id="单行处理函数"><a href="#单行处理函数" class="headerlink" title="单行处理函数"></a>单行处理函数</h4><ul><li>单行处理函数的特点是输入一行，输出一行</li><li><code>ifnull()</code> 可能为<code>NULL</code>的数据，都被当作什么处理<ul><li><code>ifnull(字段,0)</code>：如果这个字段是<code>NULL</code>，那么当成<code>0</code>处理</li></ul></li><li><code>Lower()</code>：转换小写</li><li><code>upper()</code>：转换大写</li><li><code>substr()</code>：取子串（被截取的字符串的起始下标，截取的长度）<ul><li><code>substr(字段，被截取的字符串的起始下标，截取的长度)</code></li></ul></li><li><code>length()</code>：取长度</li><li><code>trim()</code>：去空格</li><li><code>str_to_date()</code>：将字符串转换为日期</li><li><code>format()</code>：设置千分位</li><li><code>round()</code>：四舍五入<ul><li><code>round(数字，小数点后保留的位数)</code></li></ul></li><li><code>rand()</code>：生成随机数<ul><li>生成的<code>0-1</code>的随机数</li></ul></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li><code>group by</code> ：按照某个字段或者多个字段进行分组<ul><li><code>select 字段 from 表名 group by 字段</code></li><li>一个字段分组：<code>group by 字段</code></li><li>多个字段分组：<code>group by 字段，字段</code></li></ul></li><li><code>having</code>：是对分组之后的数据进行再次过滤<ul><li><code>heaving</code>是在<code>group by</code>之后完成过滤</li><li><code>where</code>实在<code>group by</code>之前完成过滤</li><li>能够在<code>where</code>在过滤的数据不要放到<code>having</code>中进行过滤，否则影响<code>SQL</code>语句的执行效率</li></ul></li></ul><blockquote><p>分组函数一般都会和 group by 联合使用，这也是它被称为分组函数的原因，并且任何一个分组函数都是在 group by 语句执行结束之后才会执行</p><p>当一条 sql 语句中没有 group by 的话，整张表的数据会自成一组</p><p>当一条 sql 语句有 group by 时，select 后面只可以有参加分组的字段和分组函数字段</p></blockquote><h3 id="完整的-DQL-语句"><a href="#完整的-DQL-语句" class="headerlink" title="完整的 DQL 语句"></a>完整的 DQL 语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语句执行顺序</span><br><span class="line"></span><br><span class="line">select5</span><br><span class="line">...</span><br><span class="line">from1</span><br><span class="line">...</span><br><span class="line">where2</span><br><span class="line">...</span><br><span class="line">group by3</span><br><span class="line">...</span><br><span class="line">having4</span><br><span class="line">...</span><br><span class="line">order by6</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">书写顺序不可以颠倒，它可以缺少某个，但是不可以颠倒顺序</span><br></pre></td></tr></table></figure><h3 id="关于查询结果的去重"><a href="#关于查询结果的去重" class="headerlink" title="关于查询结果的去重"></a>关于查询结果的去重</h3><ul><li><strong>distinct</strong><ul><li>例：<code>select distinct 字段 from 表 where ... </code></li><li><code>distinct</code>只可以出现在所有字段的最前面</li><li><code>distinct</code>出现在最前面是为了后面所有字段联合起来去重</li></ul></li></ul><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>什么是连接查询<ul><li>在实际开发中，大部分都不是从单表中查询数据，一般都是多张表联合查询，取出结果，在实际开发中，一般一个业务都会对应多张表，比如，学生和班级，起码两张表，如果存在一张表，数据会存在大量的冗余。</li></ul></li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>分局语法出现的年代来划分，包括</p><ul><li><strong>SQL92</strong>（一些老的<code>DBA</code>可能还在使用这种语法，<code>DBA</code>：<code>DataBase Administerator</code>，数据库管理员）</li><li><strong>SQL99</strong>（比较新的语法）</li></ul></li><li><p>根据表的连接方式来划分，包括</p><ul><li>内连接：<ul><li>等值连接</li><li>非等值连接</li><li>自连接</li></ul></li><li>外连接<ul><li>左外连接（左连接）</li><li>右外连接（右连接）</li></ul></li><li>全连接</li></ul></li></ul><h4 id="笛卡尔积现象-别名"><a href="#笛卡尔积现象-别名" class="headerlink" title="笛卡尔积现象/别名"></a>笛卡尔积现象/别名</h4><ul><li><p>笛卡尔乘积现象</p><ul><li>若两张表迚行连接查询的时候没有仸何条件限制，最终的查询结果总数是两张表记录 的乘积，该现在称为笛卡尔积现象。</li><li>避免笛卡尔积现象<ul><li>避免笛卡尔积现象，不会减少记录的匹配次数，只是显示的是有效记录，并不会提高执行效率</li><li>例如：<code>select e.ename,d.dname from emp e,dept d where e.deptno = d.deptno;</code><ul><li><code>SQL92</code>语法</li></ul></li></ul></li></ul></li><li><p>别名</p><ul><li><code>select 表别名.字段，表别名.字段 from 表名 表别名(生成的)，表名 表别名(生成的)</code></li><li>例如：<code>select e.ename,d.dname from emp e,dept d;</code></li><li>可读性好</li><li>执行效率高</li></ul></li></ul><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><blockquote><p>内连接之等值连接：最大的特点是：连接条件是等量关系</p></blockquote><ul><li>示例：查询员工的名称和员工所对应的部门名称</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emp是员工表，dept是部门表，e.name和d.name是emphe dept两个表的</span><br><span class="line"></span><br><span class="line">SQL92:</span><br><span class="line">select</span><br><span class="line">e.name,d.dname</span><br><span class="line">from</span><br><span class="line">emp e,dept d</span><br><span class="line">where</span><br><span class="line">e.deptno = d.deptno</span><br><span class="line"></span><br><span class="line">SQL99:</span><br><span class="line">select</span><br><span class="line">e.ename,d.dname</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">dept d</span><br><span class="line">on</span><br><span class="line">e.deptno = d.deptno;</span><br></pre></td></tr></table></figure><pre><code>  select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;</code></pre><p>  注：inner可忽略<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  join on的语法</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  A</span><br><span class="line">  inner join</span><br><span class="line">  B</span><br><span class="line">  on</span><br><span class="line">  连接条件</span><br><span class="line">  where</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  99的语法结构更加清晰，表与表的连接条件和where的条件分离了，inner可以省略，带着inner可以看出来是内连接</span><br></pre></td></tr></table></figure></p><h5 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h5><blockquote><p>内连接之非等值连接：最大的特点是：连接条件中的关系是非等量关系</p></blockquote><ul><li>找出每个员工的工资等级，要求显示员工名，工资、工资等级</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">e.ename,e.sal,s.grade</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">salgrade s</span><br><span class="line">on</span><br><span class="line">e.sal</span><br><span class="line">between</span><br><span class="line">s.losal</span><br><span class="line">and</span><br><span class="line">s.hisal</span><br><span class="line"></span><br><span class="line">e.ename是名字，e.sal是工资,s.grade是等级</span><br><span class="line">emp 是员工表</span><br><span class="line">salgrade 是薪资等级表</span><br></pre></td></tr></table></figure><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><blockquote><p>自连接：最大的特点是：一张表看做两张表，自己连接自己</p></blockquote><ul><li>找出每个员工的上级领导，要求显示员工名和对应的领导名</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">a.ename as &#x27;员工表&#x27;,b.ename as &#x27;领导表&#x27;</span><br><span class="line">from</span><br><span class="line">emp a</span><br><span class="line">inner join</span><br><span class="line">emp b</span><br><span class="line">on</span><br><span class="line">a.mgr = b.empno;</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><ul><li><p>什么是外连接，和内连接有什么区别？</p><ul><li>内连接<ul><li>假设<code>A</code>和 B 表进行连接，使用内连接的话，凡是<code>A</code>表和<code>B</code>表能够匹配上的记录查询出来，这就是内连接，<code>AB</code>两张表没有主副之分</li></ul></li><li>外连接<ul><li>假设<code>A</code>和<code>B</code>表进行连接，使用外连接的话，<code>AB</code>两张表中有一张是主表，一张表是副表，主要查询主表中的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出<code>NULL</code>与之匹配</li><li>朱标的数据无条件的全部查询出来</li></ul></li></ul></li><li><p>左外连接：表示左边的这张表是主表</p></li><li><p>右外连接：表示右边的这张表是主表</p></li><li><p>左连接有右连接的写法，右连接也会有对应的左连接的写法</p></li><li><p>语法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join on的语法</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">left/right outer join</span><br><span class="line">B</span><br><span class="line">on</span><br><span class="line">连接条件</span><br><span class="line">where</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">outer可以省略，区分内外连接主要不是inner和outer这两个单词，带着两个单词可读性强，外连接使用较多</span><br></pre></td></tr></table></figure><ul><li>例：找出所有员工的上级领导</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左外连接</span><br><span class="line">select</span><br><span class="line">a.ename as &#x27;员工&#x27;,b.ename as &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">emp a</span><br><span class="line">left join</span><br><span class="line">emp b</span><br><span class="line">on</span><br><span class="line">a.mgr = b.empno;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">右外连接</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">a.ename <span class="keyword">as</span> <span class="string">&#x27;员工&#x27;</span>,b.ename <span class="keyword">as</span> <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">emp b</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line">emp a</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">a.mgr <span class="operator">=</span> b.empno;</span><br><span class="line"></span><br><span class="line">a是主表，b是副表，<span class="keyword">left</span>代表左外连接，<span class="keyword">right</span>代表右外连接</span><br><span class="line">```</span><br></pre></td></tr></table></figure><ul><li>找到那个部门没有员工</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">d.*</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">right join</span><br><span class="line">dept d</span><br><span class="line">on</span><br><span class="line">e.deptno = d.deptno</span><br><span class="line">where</span><br><span class="line">e.empno is null;</span><br></pre></td></tr></table></figure><ul><li><p>三个表连接</p><ul><li>找出每一个员工的部门名称、工资等级、以及上级领导</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">e.ename as &#x27;员工&#x27;,d.dname,s.grade,el.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">dept d</span><br><span class="line">on</span><br><span class="line">e.deptno = d.deptno</span><br><span class="line">join</span><br><span class="line">salgrade s</span><br><span class="line">on</span><br><span class="line">e.sal between s.losal and s.hisal</span><br><span class="line">left join</span><br><span class="line">emp e1</span><br><span class="line">on</span><br><span class="line">e.mgr = e1.empno;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li><p>什么是子查询？子查询都可以出现在哪里？</p><ul><li><p><code>select</code>语句当中嵌套<code>select</code>语句，被嵌套的<code>select</code>语句是子查询</p></li><li><p>子查询可以出现在哪里？</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">..(select).</span><br><span class="line">from</span><br><span class="line">..(select).</span><br><span class="line">where</span><br><span class="line">..(select).</span><br></pre></td></tr></table></figure><h4 id="where-后面子查询"><a href="#where-后面子查询" class="headerlink" title="where 后面子查询"></a>where 后面子查询</h4><ul><li>案例：在<code>emp</code>表中找出高于平均工资的员工信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where sal &gt; avg(sal); // 错误，where后面不能有分组函数</span><br><span class="line"></span><br><span class="line">第一步:找出平均薪资，结果就是平均薪资</span><br><span class="line">select avg(sal) from emp;</span><br><span class="line">第二步：where过滤</span><br><span class="line">where sal &gt; 第一步的结果</span><br><span class="line">合并：</span><br><span class="line">select * from emp where sal &gt; (select avg(sal) from emp);</span><br></pre></td></tr></table></figure><h4 id="from-后面子查询"><a href="#from-后面子查询" class="headerlink" title="from 后面子查询"></a>from 后面子查询</h4><ul><li>案例：找出每个部门平均薪水的薪资等级</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步：找出每个部门平均薪水（按照部门编号分组，求sal的平均值）</span><br><span class="line">select deptno,avg(sal) as avgsal from emp group by deptno;</span><br><span class="line">第二步：将以上的查询结果当作临时表t，让t表和薪资等级表连接</span><br><span class="line">select</span><br><span class="line">t.*,s.grade</span><br><span class="line">from</span><br><span class="line">(select deptno,avg(sal) as avgsal from emp group by deptno) t</span><br><span class="line">join</span><br><span class="line">salgrade s</span><br><span class="line">on</span><br><span class="line">t.avgsal between s.losal and s.hisal;</span><br></pre></td></tr></table></figure><ul><li>案例：找出每个部门平均的薪水等级</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先找薪水等级，把薪水等级平均</span><br><span class="line"></span><br><span class="line">第一步：找出每个员工的薪水等级</span><br><span class="line">select</span><br><span class="line">e.ename,e.sal,e.deptno,s.grade</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">salgrade s</span><br><span class="line">on</span><br><span class="line">e.sal between s.losal and s.hisal;</span><br><span class="line">第二部：基于以上结果，继续按照deptno分组，求grade平均值</span><br><span class="line">select</span><br><span class="line">e.deptno,avg(s.grade)</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">salgrade s</span><br><span class="line">on</span><br><span class="line">e.sal between s.losal and s.hisal</span><br><span class="line">group by</span><br><span class="line">e.deptno;</span><br></pre></td></tr></table></figure><h4 id="select-后面嵌套子查询"><a href="#select-后面嵌套子查询" class="headerlink" title="select 后面嵌套子查询"></a>select 后面嵌套子查询</h4><ul><li>找出每个员工所在的部门名称，要求显示员工名和部门名</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">e.ename,e.deptno,</span><br><span class="line">(select d.dname from dept d where e.deptno = d.deptno) as dname</span><br><span class="line">from</span><br><span class="line">emp e;</span><br></pre></td></tr></table></figure><h2 id="limit、union"><a href="#limit、union" class="headerlink" title="limit、union"></a>limit、union</h2><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><ul><li><p>可以将查询结果相加，两张不相干的表中的数据拼接在一起显示</p></li><li><p><code>union</code>上下拼接的时候显示的列数要一样</p></li><li><p>案例：找出工作岗位是 SALESMAN 和 MANAGER 的员工？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种：</span><br><span class="line">select ename,job from emp where job = &#x27;SALESMAN&#x27; or job = &#x27;MANAGER&#x27;;</span><br><span class="line"></span><br><span class="line">第二种：使用in</span><br><span class="line">select ename,job from emp where job in(&#x27;SALESMAN&#x27;,&#x27;MANAGER&#x27;);</span><br><span class="line"></span><br><span class="line">第三种：union</span><br><span class="line">select ename,job from emp where job = &#x27;SALESMAN&#x27;</span><br><span class="line">union</span><br><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27;;</span><br></pre></td></tr></table></figure><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><ul><li><p><code>limit</code>是<code>mysql</code>特有的，其他数据库没有，不通用（<code>oracle</code>中有一个相同的机制，叫<code>rownum</code>）</p></li><li><p><code>limit</code>取结果集中的部分数据，这是它的作用</p></li><li><p>语法机制：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit startIndex,length</span><br><span class="line">startIndex 表示起始位置，默认从0开始，不写就是从0开始</span><br><span class="line">length 表示取几个</span><br></pre></td></tr></table></figure><ul><li>案例：取出工资前五名的员工</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.ename,e.sal from emp e order by sal desc limit 0,5;</span><br></pre></td></tr></table></figure><ul><li>案例：找出工资排名在第 4 到第 9 的员工</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.ename,e.sal from emp e order by sal desc limit 3,6;</span><br><span class="line">3表示，起始位置，6代表取6个</span><br></pre></td></tr></table></figure><ul><li><code>limit</code>是<code>SQL</code>语句最后执行的一个环节</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">...</span><br><span class="line">from</span><br><span class="line">...</span><br><span class="line">where</span><br><span class="line">...</span><br><span class="line">group by</span><br><span class="line">...</span><br><span class="line">having</span><br><span class="line">...</span><br><span class="line">order by</span><br><span class="line">...</span><br><span class="line">limit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p>分页显示采用<code>limit</code></p><ul><li>每页显示三条记录：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一页：0，3</span><br><span class="line">第二页：3，3</span><br><span class="line">第二页：6，3</span><br><span class="line">第二页：9，3</span><br><span class="line">第二页：12，3</span><br></pre></td></tr></table></figure><ul><li><p>每页显示<code>pageSize</code>条记录</p><ul><li>第<code>pageNo</code>页：<code>（pageNo - 1) * pageSize</code>，<code>pageSize</code></li></ul></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>数据类型</th><th>占用字节数</th><th>描述</th></tr></thead><tbody><tr><td><code>char</code></td><td><code>char(n)</code></td><td>定长字符串，存储空间大小固定使用<code>char(2)</code>来表示类型或状态</td></tr><tr><td><code>varchar</code></td><td><code>varchar(n)</code></td><td>变长字符串，存储空间等于实际数据空间，只包含英文字符的字符串</td></tr><tr><td><code>int</code></td><td>4 个字节</td><td>整型</td></tr><tr><td><code>bigint</code></td><td>8 个字节</td><td>长整型</td></tr><tr><td><code>float</code></td><td><code>float(有效位数)</code></td><td>数值型</td></tr><tr><td><code>double</code></td><td><code>double(有效数字位数)</code></td><td>数值型</td></tr><tr><td><code>date</code></td><td>8 字节</td><td>日期和时间</td></tr><tr><td><code>BLOB</code></td><td></td><td><code>Binary Large Object</code>（二进制大对象）</td></tr><tr><td><code>CLOB</code></td><td></td><td><code>Character Large Object</code>（字符大对象）</td></tr><tr><td>其他…</td><td></td><td></td></tr></tbody></table><ul><li><p><strong>varchar</strong> ：可变长度字符串</p><ul><li><code>varchar(3)</code>表示存储的数据长度不能超过 3 个字符长度</li></ul></li><li><p><strong>char</strong>：定长字符串</p><ul><li><code>char(3)</code>表示存储的数据长度 ch 不能超过 3 个的字符长度</li></ul></li><li><p><strong>int</strong>：整数型</p><ul><li><code>int(3)</code>表示最大可以存储 999</li></ul></li><li><p><strong>bigint</strong>：长整型</p><ul><li>对应<code>long</code>类型</li></ul></li><li><p><strong>float</strong>：浮点型单精度</p><ul><li><code>float(7,2)</code>表示 7 个有效数字，2 个有效小数位</li></ul></li><li><p><strong>double</strong>：浮点双精度</p><ul><li><code>double(7,2)</code>表示 7 个有效数字，2 个有效小数位</li></ul></li><li><p><strong>date</strong>：日期类型</p><ul><li>实际开发中，常用字符串代替日期类型</li></ul></li><li><p><strong>BLOB</strong>：二进制大对象（<code>Binary Large Object</code>）</p><ul><li>专门存储图片、视频、声音等数据</li><li>数据库存储图片很常见，但存储大视频很少见，一般都是存储视频地址</li></ul></li><li><p><strong>CLOB</strong>：字符串大对象（<code>Character Large Object</code>）</p><ul><li>存储超大文本，可存储<code>4G+</code>的字符串</li></ul></li><li><p><strong>varchar 与 char 对比</strong></p><ul><li>都是字符串</li><li><code>varchar</code>比较智能，可以根据实际数据长度分配空间，比较节省空间；但在分配的时候需要相关判断，效率低</li><li><code>char</code>不需要动态分配空间，所以执行效率高，但是可能会导致空间浪费</li><li>若字段中的数据不具备伸缩性，建议采用<code>char</code>类型存储</li><li>若字段中的数据具有很强的伸缩性，建议采用<code>varchar</code>类型存储</li></ul></li></ul><h2 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">    字段名1 数据类型 约束,</span><br><span class="line">字段名2 数据类型 约束,</span><br><span class="line">    字段名3 数据类型 约束,</span><br><span class="line">   ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>表名在数据库中一般建议以：<code>t_</code>或<code>tbl_</code>开始</p></li><li><p>案例：创建学生表</p><ul><li><p>学生信息包括：</p><ul><li>学号、姓名、性别、班级编号、生日</li><li>学号：<code>bigint</code></li><li>姓名：<code>varchar</code></li><li>性别：<code>char</code></li><li>班级编号：<code>int</code></li><li>生日：<code>char</code></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_student(</span><br><span class="line">no bigint,</span><br><span class="line">    name varchar(255),</span><br><span class="line">    sex char(1),</span><br><span class="line">    classno varchar(255),</span><br><span class="line">    birth char(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists 表名;// 当这个表存在的话删除</span><br></pre></td></tr></table></figure><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除列</span><br><span class="line">alter table 【表名字】 drop 【列名称】</span><br><span class="line"></span><br><span class="line">增加列</span><br><span class="line">alter table 【表名字】 add 【列名称】 数据类型 not NULL comment &#x27;注释说明&#x27;</span><br><span class="line"></span><br><span class="line">修改列的类型信息</span><br><span class="line">alter table 【表名字】 change 【列名称】【新列名称（这里可以用和原来列同名即可）】 数据类型 not NULL  comment &#x27;注释说明&#x27;</span><br><span class="line"></span><br><span class="line">重命名列</span><br><span class="line">alter table 【表名字】 change 【列名称】【新列名称】 数据类型 not NULL  COMMENT &#x27;注释说明&#x27;</span><br><span class="line"></span><br><span class="line">重命名表</span><br><span class="line">alter table 【表名字】 rename 【表新名字】</span><br><span class="line"></span><br><span class="line">删除表中主键</span><br><span class="line">alter table 【表名字】 drop primary key</span><br><span class="line"></span><br><span class="line">添加主键</span><br><span class="line">加主关键字的索引</span><br><span class="line">alter table tablename add primary key(id);</span><br><span class="line">alter table sj_resource_charges add constraint PK_SJ_RESOURCE_CHARGES primary key (resid,resfromid)</span><br><span class="line"></span><br><span class="line">添加索引</span><br><span class="line">alter table tablename add index 索引名 (字段名1[，字段名2 …]);</span><br><span class="line">alter table tablename add index emp_name (name);</span><br><span class="line">alter table sj_resource_charges add index index_name (name);</span><br><span class="line"></span><br><span class="line">添加唯一限制条件索引</span><br><span class="line">alter table sj_resource_charges add unique emp_name2(cardnumber);</span><br><span class="line"></span><br><span class="line">删除索引</span><br><span class="line">alter table tablename drop index emp_name;</span><br><span class="line"></span><br><span class="line">查看某个数据表的索引</span><br><span class="line">show index from 表名;</span><br><span class="line"></span><br><span class="line">MySQL创建、删除、重建和查看索引命令总结如下：</span><br><span class="line"></span><br><span class="line">创建索引（primary key，index，unique）</span><br><span class="line">alter table tbl_name add index index_name (column list);</span><br><span class="line">alter table tbl_name add unique index_name (column list);</span><br><span class="line">alter table tbl_name add primary key index_name (column list);</span><br><span class="line"></span><br><span class="line">删除索引（primary key，index，unique）</span><br><span class="line">alter table tbl_name drop index index_name (column list);</span><br><span class="line">alter table tbl_name drop unique index_name (column list);</span><br><span class="line">alter table tbl_name drop primary key index_name (column list);</span><br><span class="line"></span><br><span class="line">重建索引</span><br><span class="line">rename table tbl_name quick;</span><br><span class="line"></span><br><span class="line">查看某个数据表的索引</span><br><span class="line">show index from tbl_name;</span><br></pre></td></tr></table></figure><h2 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h2><h3 id="insert-语句插入数据"><a href="#insert-语句插入数据" class="headerlink" title="insert 语句插入数据"></a>insert 语句插入数据</h3><ul><li><p>语法格式</p><ul><li><strong>插入单行数据</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">(字段名1,字段名2,字段名3,....)</span><br><span class="line">values</span><br><span class="line">(值1,值2,值3,......);</span><br><span class="line"></span><br><span class="line">insert into values(值1,值2,值3,......); //这样就只能对应列的数量写</span><br></pre></td></tr></table></figure><ul><li><strong>插入多行数据</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">(字段名1,字段名2,字段名3,....)</span><br><span class="line">values</span><br><span class="line">(值1,值2,值3,......),</span><br><span class="line">(值1,值2,值3,......),</span><br><span class="line">(值1,值2,值3,......);</span><br></pre></td></tr></table></figure><ul><li><p>要求：字段的数量和值的数量相同，并且数据类型要对应相同</p></li><li><p>可以只插入指定字段，其他字段如果没有数据，则为<code>NULL</code></p></li><li><p><code>into</code>可以省略的</p></li><li><p>案例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入单行数据</span><br><span class="line">insert into t_student</span><br><span class="line">(no,name,sex,classno,birth)</span><br><span class="line">values</span><br><span class="line">(1,&#x27;zhangsan&#x27;,&#x27;m&#x27;,&#x27;gaosanyiban&#x27;,&#x27;1999-01-22&#x27;);</span><br><span class="line"></span><br><span class="line">插入多行数据</span><br><span class="line">insert into t_student</span><br><span class="line">(no,name,sex,classno,birth)</span><br><span class="line">values</span><br><span class="line">(2,&#x27;lsi&#x27;,&#x27;m&#x27;,&#x27;gaosanyiban&#x27;,&#x27;1999-01-22&#x27;),</span><br><span class="line">(3,&#x27;wangwu&#x27;,&#x27;m&#x27;,&#x27;gaosanyiban&#x27;,&#x27;1999-01-22&#x27;),</span><br><span class="line">(4,&#x27;zhaoliu&#x27;,&#x27;m&#x27;,&#x27;gaosanyiban&#x27;,&#x27;1999-01-22&#x27;),</span><br><span class="line">(5,&#x27;shenqi&#x27;,&#x27;m&#x27;,&#x27;gaosanyiban&#x27;,&#x27;1999-01-22&#x27;);</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>当一条<code>insert</code>语句执行成功之后，表格当中必然会多一行记录。</li><li>即使多的这一行记录当中某些字段是<code>NULL</code>，后期也没有办法在执行</li><li><code>insert</code>插入数据了，只能使用<code>update</code>进行更新了</li></ul></li></ul><h3 id="表的复制及批量插入"><a href="#表的复制及批量插入" class="headerlink" title="表的复制及批量插入"></a>表的复制及批量插入</h3><ul><li>表的复制</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名 as select语句;   // 将查询结果当作表创建出</span><br></pre></td></tr></table></figure><ul><li>批量插入</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名 select语句</span><br></pre></td></tr></table></figure><ul><li>注意：这里有表结构的影响，不同的表结构不可以随便插入</li></ul><h3 id="update-修改表的数据"><a href="#update-修改表的数据" class="headerlink" title="update 修改表的数据"></a>update 修改表的数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段名1=值1，字段名2=值2... where 条件;</span><br></pre></td></tr></table></figure><ul><li>注意：没有条件整张表将全部更新</li></ul><h3 id="delete-删除数据"><a href="#delete-删除数据" class="headerlink" title="delete 删除数据"></a>delete 删除数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">detele from 表名 where 条件;</span><br></pre></td></tr></table></figure><ul><li><p>注意：没有条件全部删除</p></li><li><p>怎么删除大表中的数据（数据量特别大的表）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truncate table 表名</span><br></pre></td></tr></table></figure><ul><li><p>表被截断，不可回滚，永久丢失</p></li><li><p>删之前，慎重！</p></li></ul><h2 id="约束（Constraint）"><a href="#约束（Constraint）" class="headerlink" title="约束（Constraint）"></a>约束（Constraint）</h2><ul><li>什么是约束？常见的约束有哪些？<ul><li>在创建表的时候，可以给表的字段添加响应的约束，添加约束的目的是为了保证表的数据的合法性、有效性、完整性</li><li>常见的约束<ul><li>非空约束（<strong>not null</strong>）：约束的字段不能为<code>NULL</code></li><li>唯一约束（<strong>unique</strong>）：约束的字段不能重复</li><li>主键约束（<strong>primary key</strong>）：约束的字段不能为<code>NULL</code>，也不能重复（简称<code>PK</code>）</li><li>外键约束（<strong>foreign key</strong>）：（简称<code>FK</code>）</li><li>检查约束（<strong>check</strong>）<ul><li>注意：<code>Oracle</code>数据空有<code>check</code>约束，但<code>mysql</code>没有</li></ul></li></ul></li></ul></li></ul><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><ul><li><strong>not null</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">id int,</span><br><span class="line">    username varchar(255) not null, -- 这样username这列就必须填写值，不可以为空（NULL）</span><br><span class="line">    password varchar(255)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><ul><li><p><strong>unique</strong></p><ul><li>唯一约束修饰的字段具有唯一性，不能重复，但可以为<code>NULL</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给一个字段加唯一约束</span><br><span class="line">create table t_user(</span><br><span class="line">id int unique, -- id这列就是唯一了，不可以填写重复的值，可以为NULL</span><br><span class="line">    username varchar(255),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">表级约束：给多个字段加唯一约束</span><br><span class="line">create table t_user(</span><br><span class="line">id int,</span><br><span class="line">    username varchar(255),</span><br><span class="line">    usercode varchar(255),</span><br><span class="line">    unique(username,usercode)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">列级约束：给多个字段加唯一约束（2）</span><br><span class="line">create table t_user(</span><br><span class="line">id int,</span><br><span class="line">    username varchar(255) unique,</span><br><span class="line">    usercode varchar(255) unique</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">表级约束中的unique(字段1，字段...)表示的是多个字段联合建立一个约束，只要多个字段连接起来重复才是重复，单独一个字段重复，是不重复</span><br><span class="line">列级约束在字段后面加unique是给单独这一个字段加唯一约束，这个字段有重复的就不可以</span><br></pre></td></tr></table></figure><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><ul><li><p><strong>primary key</strong></p><ul><li>主键特点：不能为<code>NULL</code>，也不能重复</li><li>一张表的主键约束只能有<strong>1</strong>个（重点）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列级主键约束</span><br><span class="line">create table t_user(</span><br><span class="line">id int primary key,</span><br><span class="line">    username varchar(255),</span><br><span class="line">    email varchar(255)</span><br><span class="line">)</span><br><span class="line">insert into t_user(id,username,email) values(1,&#x27;zs&#x27;,&#x27;zs@123.com&#x27;)</span><br><span class="line"></span><br><span class="line">表级主键约束</span><br><span class="line">create table t_user(</span><br><span class="line">id int,</span><br><span class="line">    username varchar(255),</span><br><span class="line">    email varchar(255),</span><br><span class="line">    primary key(id) -- 和标记unique约束一样</span><br><span class="line">)</span><br><span class="line">insert into t_user(id,username,email) values(1,&#x27;zs&#x27;,&#x27;zs@123.com&#x27;)</span><br><span class="line"></span><br><span class="line">复合主键约束</span><br><span class="line">create table t_user(</span><br><span class="line">    id int,</span><br><span class="line">    username varchar(255),</span><br><span class="line">    password varchar(255),</span><br><span class="line">    primary key(id,username)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>相关术语：</p><ul><li>主键约束（<code>primary key</code>）</li><li>主键字段（<code>id</code>字段添加<code>primary key</code>之后，<code>id</code>叫做主键字段）</li><li>主键值（<code>id</code>字段中的每一个值都是主键值）</li></ul></li><li><p>主键有什么作用呢？</p><ul><li>表的设计三范式有要求，第一范式中就要求任何一张表都应该有主键</li><li>主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像身份证号一样）</li></ul></li><li><p>主键分类</p><ul><li>根据主键字段的字段数量来划分<ul><li>单一主键（常用，推荐）</li><li>复合主键（多个字段联合起来添加一个主键约束）（不建议用，违反三范式）</li></ul></li><li>根据主键性质来划分<ul><li>自然主键</li><li>业务主键（主键值和系统的业务挂钩）（银行卡的卡号、身份证号作为主键）（不推荐用）<ul><li>最好不要拿着和业务挂钩的字段作为主键，因为以后的业务一旦发生改变的时候，主键值也需要随着发生变化，但有的时候没有办法变化，因为变化会导致主键值重复</li></ul></li></ul></li></ul></li><li><p>主键值自增</p><ul><li><strong>auto_increment</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">id int primary key auto_increment, -- 在primary key后面加上auto_increment就是自增了</span><br><span class="line">    username varchar(255),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>Oracle</code>当中也提供了一个自增机制，叫做：序列（<code>sequence</code>）对象</li></ul><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li><p>相关术语：</p><ul><li>外键约束（<code>foreign key</code>）</li><li>外键字段：添加有外键约束的字段</li><li>外键值：外键字段中的每一个值</li></ul></li><li><p>业务背景（请设计数据库表，用来维护学生和班级的信息？）</p><ul><li>第一种方案：一张表存储所有数据（冗余）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no(pk)name classno  classname</span><br><span class="line">---------------------------------------------------</span><br><span class="line">1zs1   101  亦庄二中高三1班</span><br><span class="line">2zs2   101  亦庄二中高三1班</span><br><span class="line">3zs3   102  亦庄二中高三2班</span><br><span class="line">4zs4   102  亦庄二中高三2班</span><br><span class="line">5zs5   102  亦庄二中高三2班</span><br></pre></td></tr></table></figure><ul><li>第二种方案：两张表（班级表，学生表）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- t_class 班级表表</span><br><span class="line">classnoclassname</span><br><span class="line">--------------------------------</span><br><span class="line">101亦庄二中高三1班</span><br><span class="line">102亦庄二中高三2班</span><br><span class="line"></span><br><span class="line">-- t_student 学生表</span><br><span class="line">snosname classno(该字段添加外键约束fk)</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">1zs1 101</span><br><span class="line">2zs2 101</span><br><span class="line">3zs3 102</span><br><span class="line">4zs4 102</span><br><span class="line">5zs5 102</span><br></pre></td></tr></table></figure><ul><li><p>将以上表建表语句写出来：</p><ul><li><p><code>t_student</code>中的<code>classno</code>字段引用<code>t_class</code>表中的<code>classno</code>字段，此时，<code>t_student</code>叫做子表，<code>t_class</code>叫做副表</p></li><li><p>顺序要求</p><ul><li>删除数据的时候，先删除子表，在删除父表</li><li>添加数据的时候，先添加父表，在添加子表</li><li>创建表的时候，先创建父表，在创建子表</li><li>删除表的时候，先删除子表，在删除父表</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_class(</span><br><span class="line">classno int,</span><br><span class="line">    classname varchar(255),</span><br><span class="line">    primary key(classno)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">create table t_student(</span><br><span class="line">sno int,</span><br><span class="line">    sname varchar(255),</span><br><span class="line">    cno int,</span><br><span class="line">    primary key(sno),</span><br><span class="line">    foreign key(cno) references t_class(classno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreign key(需要外键字段) references 父表名(要引用的字段)</span><br></pre></td></tr></table></figure><ul><li><p>子表中的外键值需要引用父表的外键值，不可以和父表的外键值不一样</p></li><li><p>外键值可以为<code>NULL</code></p></li><li><p>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？</p><ul><li>被引用的字段不一定是主键，但是至少要有<code>unique</code>唯一性</li></ul></li></ul><h3 id="默认值约束"><a href="#默认值约束" class="headerlink" title="默认值约束"></a>默认值约束</h3><ul><li><p>语法</p></li><li><p>```mysql<br>&lt;字段名&gt; &lt;数据类型&gt; default &lt;默认值&gt;;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 存储引擎</span><br><span class="line"></span><br><span class="line">- 存储引擎是：`MySQL`特有的，其它数据库没有，存储引擎这个名字旨在`mysql`中存在（`Oracle`中有对应的机制，但是不叫存储引擎，叫存储方式)</span><br><span class="line"></span><br><span class="line">### 存储引擎的本质</span><br><span class="line"></span><br><span class="line">- `mysql`支持很多的存储引擎，每一个存储引擎都对应了一种不同的存储方式</span><br><span class="line">- 每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎</span><br><span class="line">- 通过采用不同的技术将数据存储在文件或内存中；</span><br><span class="line">- 每一种技术都有不同的存储机制，不同的存储机制提供不同的功能和能力</span><br><span class="line">- 通过选择不同的技术，可以获得额外的速度或功能，改善我们的应用；</span><br><span class="line"></span><br><span class="line">### 查看存储引擎</span><br><span class="line"></span><br><span class="line">- **show engines\G**</span><br><span class="line">- 在创建表时，可使用&lt; ENGINES&gt; 选项为 CREATE TABLE 诧句显示指定存储引擎</span><br><span class="line">  - 例如：`create table table_name(no int)engine = myisam;`</span><br><span class="line">- 如果创建表时没有指定存储引擎，则使用当前默认的存储引擎；</span><br><span class="line">- 默认的存储引擎可在 `my.ini` 配置文件中使用 `default-storage-engin` 选项指定；</span><br><span class="line">- 修改表的存储引擎使用：`alter table 表名 engine= 存储引擎名称;`</span><br><span class="line">- 查看表使用的存储引擎，命令如下：</span><br><span class="line">  - `show create table 表名\G;`</span><br><span class="line">  - `show table status like &#x27;表名&#x27;\G;`</span><br><span class="line"></span><br><span class="line">### 常见的存储引擎</span><br><span class="line"></span><br><span class="line">#### MyISAM 存储引擎</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">Engine: MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: MyISAM storage engine</span><br><span class="line">Transactions: NO -- 事务（TCL）</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br></pre></td></tr></table></figure></li><li><p><code>MyISAM</code>不支持事务</p></li><li><p><code>MyISAM</code>是<code>MyISAM</code>最常用的，但不是默认的引擎</p></li><li><p>他管理的表具有以下特性</p><ul><li>每个表使用三个文件来存储所有的东西<ul><li>格式文件——存储表的结构（<code>mytable.frm</code>）</li><li>数据文件——存储表的数据（<code>mytable.MYD</code>）</li><li>索引文件——储存表的索引（<code>mytable.MYI</code>）</li></ul></li><li>灵活的<code>auto_increment</code>字段处理</li><li>可被转换为压缩、制度来节省空间</li></ul></li></ul><h4 id="InnoDB-引擎"><a href="#InnoDB-引擎" class="headerlink" title="InnoDB 引擎"></a>InnoDB 引擎</h4><ul><li><code>InnoDB</code>存储引擎是<code>MySQL</code>的缺省引擎</li><li>它管理的表主要具有以下特征<ul><li>每个<code>InnoDB</code>表在数据库目录中以<code>.frm</code>格式文件表示</li><li><code>InnoDB</code>表空间<code>tablespace</code>被用于存储表的内容</li><li>提供一组用来记录事务性活动的日志文件</li><li>用<code>commit</code>（提交）、<code>savepoint</code>及<code>rollback</code>（回滚）支持事务处理</li><li>提供全<code>ACID</code>兼容</li><li>在<code>MySQL</code>服务器崩溃后提供自动回复</li><li>多版本（<code>MVCC</code>）和行级锁定</li><li>支持外键及引用的完整性，包括级联删除和更新</li><li>很安全，支持事务</li></ul></li></ul><h4 id="MEMORY-存储引擎"><a href="#MEMORY-存储引擎" class="headerlink" title="MEMORY 存储引擎"></a>MEMORY 存储引擎</h4><ul><li>使用<code>MEMORY</code>存储引擎的表，因为数据存储在内存中，且行的长度固定，所以使得<code>MEMORY</code>存储引擎 非常快；</li><li><code>MEMORY</code>存储引擎管理的表具有下列特征：<ul><li>在数据库目录内，每个表均以<code>.frm</code>格式文件表示</li><li>表数据及索引被存储在内存中</li><li>表级锁机制</li><li>字段属性性能包含<code>TEXT</code>或<code>BLOB</code>字段</li></ul></li><li><code>MEMORY</code>存储引擎以前被称为<code>HEAP</code>引擎</li></ul><h4 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h4><ul><li><code>MyISAM</code>表最适合于大量的数据读而少量数据更新的混合操作。<code>MyISAM</code>表的另一种适用情形是使用压缩的只读表。</li><li>如果查询中包含较多的数据更新操作，应使用<code>InnoDB</code>。其行级锁机制和多版本的支持为数据读取和更新的混合提供了良好的并发机制。</li><li>使用<code>MEMORY</code>存储引擎存储非永丽需要的数据，或者是能够从基于磁盘的表中重新生成的数据。</li></ul><h2 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul><li>一个事务是一个完整的业务逻辑单元，不可再分</li><li>通常一个事务对应一个完整的业务；（如：银行转账业务）</li><li>而一个完整的业务需要批量的<code>DML</code>（<code>insert</code>、<code>update</code>、<code>delete</code>）语句共同完成；</li><li>事务只和<code>DML</code>语句有关系，或者说只有<code>DML</code>语句才有事务；</li><li>以上所描述的批量<code>DML</code>语句共有多少<code>DML</code>语句，这个和业务逻辑有关系，业务逻辑不同<code>DML</code>语句个数不同 ；</li><li>假设所有的业务都能使用<code>1</code>条<code>DML</code>语句搞定，还需要事务机制吗？不需要事务，但实际情况不是这样的，通常一个事务需要多条<code>DML</code>语句共同联合完成</li></ul><h3 id="事务的一些概念-SQL-语句"><a href="#事务的一些概念-SQL-语句" class="headerlink" title="事务的一些概念\SQL 语句"></a>事务的一些概念\SQL 语句</h3><ul><li><p><strong>SQL</strong>语句</p><ul><li><strong>commit</strong>：提交事务</li><li><strong>rollback</strong>：回滚事务</li></ul></li><li><p>概念</p><ul><li>开启事务（<code>start transaction</code>）</li><li>结束事务（<code>end transaction</code>）</li><li>提交事务（<code>commit transaction</code>）</li><li>回滚事务（<code>rollback transaction</code>）</li></ul></li><li><p>开始和结束的标志</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设一个事儿，需要先执行一条insert，在执行一条update，最后执行一条detele，这个事才算完成</span><br><span class="line"></span><br><span class="line">开启事务机制（开始）</span><br><span class="line"></span><br><span class="line">执行insert语句--&gt;insert....（这个执行成功之后，把这个执行记录到数据库的操作历史当中，并不会向文件中保存一条数据，不会真正修改硬盘上的数据）</span><br><span class="line">执行一条update语句 --&gt; update...（这个执行也是记录一下历史操作，不会真正的修改硬盘上的数据）</span><br><span class="line">执行delete语句 --&gt; delete...（这个执行也是记录以下历史操作【记录到缓存】，不会真正的修改硬盘上的数据）</span><br><span class="line"></span><br><span class="line">提交事务或者回滚事务（结束）</span><br></pre></td></tr></table></figure><ul><li><p>开始的标志：任何一条<code>DML</code>语句执行，标志着事务的开始</p></li><li><p>结束的标志：</p><ul><li>提交（<code>commit</code>）、回滚（<code>rollback</code>）<ul><li>提交：成功的结束，将所有的<code>DML</code>语句操作记录和底层硬盘文件中数据进行一次同步</li><li>回滚：失败的结束，将所有的<code>DML</code>语句操作记录全部清空</li></ul></li></ul></li><li><p><strong>重点</strong></p><ul><li>在事务进行过程中，未结束之前，<code>DML</code>语句是不会修改底层数据库文件中的数据</li><li>只是将历史操作记录以下，在内存中完成记录</li><li>只有在事务结束的，而且是成功结束的时候才会修改底层硬盘文件中的数据</li></ul></li></ul><h3 id="事务四个特性（ACID）"><a href="#事务四个特性（ACID）" class="headerlink" title="事务四个特性（ACID）"></a>事务四个特性（ACID）</h3><ul><li><p>事务可以保证多个操作原子性，要么全成功，要么全失败。对于数据库来说，事务保证批量的<code>DML</code>要么全成功，要么全失败。</p></li><li><p><strong>A</strong>：原子性（<code>Atomicity</code>）：最小单元，不可再分</p></li><li><p><strong>C</strong>：一致性（<code>Consistency</code>）：事务要求所有的<code>DML</code>语句操作的时候，必须保证同时成功或失败</p></li><li><p><strong>I</strong>：隔离性（<code>lsolation</code>）：一个事务不会影响其他事务的运行，事务<strong>A</strong>与事务<strong>B</strong>之间具有隔离</p></li><li><p><strong>D</strong>：持久性（<code>Durability</code>）：在事务完成之后，该事务对数据库所作的更改将持续地保存在数据库中，并不会被回滚，事务才算成功的结束</p></li></ul><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><ul><li><p>事务特性<code>ACID</code>之一：隔离性（<code>isolation</code>）</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li>第一级别：读未提交（<code>read uncommitted</code>）<ul><li>对方事务还没有提交，我们当前事务可以读取到对方未提交的数据</li><li>读未提交存在脏读（<code>Dirty Read</code>）现象：表示读到了脏的数据。</li></ul></li><li>第二级别：读已提交（<code>read committed</code>）<ul><li>对方事务提交之后的数据我方可以读取到</li><li>读已提交存在的问题是：不可重复读</li><li>这种隔离级别，解决了脏读现象，但是出现了不可重复读</li></ul></li><li>第三级别：可重复读（<code>repeatable read</code>）<ul><li>对方提交之后的数据都读取不到</li><li>这种隔离级别，解决了不可重复读问题</li><li>这种隔离级别可以避免“脏读和丌可重复读”，达到“重复读取”</li><li>这种隔离级别存在的问题是：读取到的数据是幻象</li></ul></li><li>第四级别：串行化<ul><li>事务<code>A</code>和事务<code>B</code>，事务 A 在操作数据库表中数据的时候，事务<code>B</code>叧能排队等待</li><li>解决了所有问题</li><li>存在的问题：效率低，需要事务排队</li></ul></li></ul></li><li><p><code>Oracle</code>数据库默认的级别是第二级别（读已提交）</p></li><li><p><code>MySQL</code>数据库默认的级别是第三级别（可重复读）</p></li></ul><h4 id="查看隔离级别"><a href="#查看隔离级别" class="headerlink" title="查看隔离级别"></a>查看隔离级别</h4><ul><li>查看当前会话的隔离级别<ul><li><code>select @@tx_isolation;</code></li><li><code>select @@session.tx_isolation;</code></li></ul></li><li>查看当前全局隔离级别<ul><li><code>select @@global.tx_isolation;</code></li></ul></li></ul><h4 id="设置服务器缺省隔离级别"><a href="#设置服务器缺省隔离级别" class="headerlink" title="设置服务器缺省隔离级别"></a>设置服务器缺省隔离级别</h4><ul><li><p>第一种：修改该<code>my.ini</code>配置文件</p><ul><li>在<code>my.ini</code>文件中的<code>[mysqlid]</code>下面添加</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-------------------------my.ini------------------------------</span><br><span class="line">[mysqld]</span><br><span class="line">transaction-isolation = isolation-level</span><br><span class="line">--------------------------my.ini-------------------------------</span><br></pre></td></tr></table></figure><ul><li><p><code>isolation-level</code>可选项为：</p><ul><li><code>read-uncommitted</code></li><li><code>read-committed</code></li><li><code>repeatable-read</code></li><li><code>serializable</code></li></ul></li><li><p>第二种：通过命令方式设置事务隔离级别</p><ul><li><code>set transaction isolaction level isolation-level;</code></li><li><code>isolation-level</code>可选值<ul><li><code>read uncommitted</code></li><li><code>read committed</code></li><li><code>repeatable read</code></li><li><code>serializable</code></li></ul></li></ul></li><li><p>设置隔离级别作用的范围</p><ul><li>事务隔离级别的作用范围分为两种：会话级、全局级<ul><li>会话级（<code>session</code>）：叧对当前会话有效</li><li>全局级（<code>global</code>）：对所有会话有效</li></ul></li><li>使用方法如下<ul><li>会话级：<ul><li><code>set transaction isolation level &lt;isolation-level&gt;;</code></li><li><code>set session transaction isolation level &lt;isolation-level&gt;;</code></li></ul></li><li>全局级:<ul><li><code>set global transaction isolation level &lt;isolation-level&gt;;</code></li></ul></li></ul></li></ul></li><li><p>隔离级别不一致性问题的关系</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻象读</th></tr></thead><tbody><tr><td>读未提交</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table></li></ul><h3 id="演示事务"><a href="#演示事务" class="headerlink" title="演示事务"></a>演示事务</h3><ul><li><p><code>mysql</code>事务默认情况下是自动提交的</p><ul><li>什么是自动提交？只要执行任意一条<code>DML</code>语句则提交一次</li></ul></li><li><p>怎么关闭自动提交</p><ul><li><code>start transaction</code></li></ul></li><li><p>演示：自动提交</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    username varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into t_user(username) values(&#x27;zs&#x27;);</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback; -- 回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_usre;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 回滚没有管用，说明commit（提交）是自动的</span><br></pre></td></tr></table></figure><ul><li>演示：关闭自动提交</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; -- 开启事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&#x27;ls&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">|  2 | ls       |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback; -- 回滚，清空历史记录，结束事务</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 回滚成功，说明自动提交关闭了</span><br></pre></td></tr></table></figure><ul><li>演示：提交事务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; start transaction; -- 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&#x27;wangwu&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&#x27;rose&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">|  3 | wangwu   |</span><br><span class="line">|  4 | rose     |</span><br><span class="line">+----+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; -- 提交，结束事务</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">|  3 | wangwu   |</span><br><span class="line">|  4 | rose     |</span><br><span class="line">+----+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 提交成功，没有错误</span><br></pre></td></tr></table></figure><ul><li>演示四个级别</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>什么是索引，有什么用？</p><ul><li>相当于一本书的目录，通过目录可以快速的找到对应的资源。</li><li>在数据方面，查询一张表的时候有两种检索方式<ul><li>第一种方式：全表扫描</li><li>第二种方式：根据索引检索？（效率很高）</li></ul></li><li>索引为什么可以提高检索效率？<ul><li>其实最根本的原理是缩小了扫描的范围</li><li>索引虽然可以提高检索效率，但是不可以随意添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改，这样就不适合添加索引，因为数据一旦被修改，索引需要重新排序，进行维护。</li></ul></li><li>添加索引是给某一个字段，或者说某些字段添加索引<ul><li><code>select ename,sal from emp where ename=&#39;SMITH&#39;;</code></li><li>当<code>ename</code>字段上没有添加索引的时候，以上<code>sql</code>语句会进行全表扫描，扫描<code>ename</code>字段中所有的值。</li><li>当<code>ename</code>字段中添加索引的时候，以上<code>sql</code>语句会根据索引扫描，快速定位</li></ul></li></ul></li><li><p>怎么创建索引对象？怎么删除索引对象？</p><ul><li>创建索引对象：<code>create index 索引名称 on 表名(字段);</code></li><li>删除索引对象：<code>drop index 索引名称 on 表名;</code></li></ul></li><li><p>什么时候考虑给字段添加索引？（满足什么条件）</p><ul><li>数据量庞大（根据客户的需求，根据线上的环境）</li><li>该字段很少的<code>DML</code>字段（因为字段进行修改操作，索引也需要维护）</li><li>该字段经常出现在<code>where</code>子句中（经常根据那个字段查询）</li><li><strong>注意</strong>：主键和具有<code>unique</code>约束的字段自动会添加索引<ul><li>根据主键查询效率较高，尽量根据主键检索</li></ul></li></ul></li><li><p>查看<code>sql</code>语句的执行计划</p><ul><li><code>explain select语句</code></li></ul></li><li><p>索引底层采用的数据结构是<code>B + True</code></p></li><li><p>索引的实现原理</p><ul><li>通过<code>B True</code>缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename from emp where ename = &#x27;smith&#x27;;</span><br><span class="line">通过索引转换为</span><br><span class="line">select ename from emp where 物理地址 = &#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure><ul><li>索引的分类？<ul><li>单一索引：给单个字段添加索引</li><li>复合索引：给多个字段联合起来添加 1 个索引</li><li>主键索引：主键上会自动添加索引</li><li>唯一索引：有<code>unique</code>约束的字段上会自动添加索引</li><li>…..</li></ul></li><li>索引什么时候会失效？<ul><li>模糊查询的时候，第一个字符使用的是<code>%</code>，这个时候索引是失效的</li></ul></li></ul><h2 id="视图（view）"><a href="#视图（view）" class="headerlink" title="视图（view）"></a>视图（view）</h2><ul><li><p>什么是视图？</p><ul><li>站在不同的角度去看到数据（同一张表的数据，通过不同的角度去看待）</li></ul></li><li><p>创建、删除视图</p><ul><li>创建视图<ul><li><code>create view 视图名称 as select 字段,字段... from 表名;</code></li></ul></li><li>删除视图<ul><li><code>drop view 视图名称;</code></li></ul></li><li>注意：只有<code>DQL</code>语句才能以视图的方式创建出来，可以对视图进行<code>CRUD</code>操作</li></ul></li><li><p>对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据，不是直接操作的原表）</p></li><li><p>视图的操作</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table emp_bak as select * from emp;</span><br><span class="line">ccreate view myview as select ename,empno,sal from emp_bak; // 建立视图</span><br><span class="line">update myview set ename=&#x27;hehe&#x27;,sal=1 where empno=&#x27;7369&#x27;; // 通过视图修改原表数据</span><br><span class="line">delete from myview where empno = 7369; // 通过视图删除原表数据</span><br></pre></td></tr></table></figure><ul><li><p>视图的作用？</p><ul><li>视图可以隐藏表的实现细节，保密级别较高的系统，数据库只对提供相关的视图，只对视图进行<code>CRUD</code></li></ul></li></ul><h2 id="DBA-命令"><a href="#DBA-命令" class="headerlink" title="DBA 命令"></a>DBA 命令</h2><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><ul><li><p><code>create user 用户名 identified by &#39;密码&#39;;</code></p></li><li><p>实例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user username identified by &#x27;123&#x27;;</span><br><span class="line">可以登录但是只可以看见一个库information_schema</span><br></pre></td></tr></table></figure><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><h4 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：grant all privileges on dbname.tbname to &#x27;username&#x27;@&#x27;login ip&#x27; identified by &#x27;password&#x27; with grant option;</span><br><span class="line"></span><br><span class="line">1) dbname=* 表示所有数据库</span><br><span class="line">2) tbname=* 表示所有表</span><br><span class="line">3) login ip=% 表示任何ip</span><br><span class="line">4) password 为空，表示不需要密码即可登录</span><br><span class="line">5) with grant option; 表示该用户还可以授权给其他用户</span><br></pre></td></tr></table></figure><ul><li>细粒度授权<ul><li>首先以 root 用户进入<code>mysql</code></li><li>然后键入命令：<code>grant select,insert,update,delete on *.* to p361 @localhost Identified by &quot;123&quot;;</code></li><li>如果希望该用户能够在任何机器上登陆<code>mysql</code>，则将<code>localhost</code>改为 <code>&quot;%&quot;</code></li></ul></li><li>粗粒度授权<ul><li>我们测试用户一般使用该命令授权：<ul><li><code>GRANT ALL PRIVILEGES ON *.* TO &#39;p361&#39;@&#39;%&#39; Identified by &quot;123&quot;;</code></li></ul></li><li>注意：用以上命令授权的用户丌能给其它用户授权,如果想让该用户可以授权,用以下命令:<ul><li><code>GRANT ALL privileges ON *.* TO &#39;p361&#39;@&#39;%&#39; Identified by &quot;123&quot; WITH GRANT OPTION;</code></li></ul></li></ul></li><li>用户权限<code>privileges</code>包括：<ul><li><code>alter</code>：修改数据库的表</li><li><code>create</code>：创建新的数据库戒表</li><li><code>delete</code>：删除表数据</li><li><code>drop</code>：删除数据库/表</li><li><code>index</code>：创建/删除索引</li><li><code>insert</code>：添加表数据</li><li><code>select</code>：查询表数据</li><li><code>update</code>：更新表数据</li><li><code>all</code>：允许任何操作</li><li><code>usage</code>：叧允许登录</li></ul></li></ul><h3 id="回收授权"><a href="#回收授权" class="headerlink" title="回收授权"></a>回收授权</h3><ul><li>命令详解</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回收授权</span><br><span class="line">revoke privileges on dbname[.tbname] from username;</span><br><span class="line">revoke all privileges on *.* from p361;</span><br><span class="line"></span><br><span class="line">use mysql</span><br><span class="line">select * from user</span><br><span class="line">迚入 mysql库中</span><br><span class="line">修改密码;</span><br><span class="line">update user set password = password(&#x27;qwe&#x27;) where user = &#x27;p646&#x27;;</span><br><span class="line">刷新权限;</span><br><span class="line">flush privileges</span><br></pre></td></tr></table></figure><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><ul><li><p>将数据库当中所有的数据导出</p><ul><li><code>mysqldump 数据库名称&gt;要导出的sql文件的路径 -uroot -p密码</code></li><li><code>mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p333</code></li></ul></li><li><p>导出数据库中某个表的数据</p><ul><li><code>mysqldump 数据库名称 表名&gt;要导出的sql文件的路径 -uroot -p密码</code></li><li><code>mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p333</code></li></ul></li><li><p>导入数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create databases 数据库名称;</span><br><span class="line">use 数据库名称;</span><br><span class="line">source sql文件所在的路径地址</span><br></pre></td></tr></table></figure><h2 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h2><ul><li><p>什么是设计范式？</p><ul><li>设计表的依据，按照三范式设计的表不会出现数据冗余</li></ul></li><li><p>三范式都是那些？</p><ul><li><p>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分</p></li><li><p>第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部份依赖</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多对多？ 三张表 关系表，两个外键</span><br><span class="line"></span><br><span class="line">t_student 学生表</span><br><span class="line">sno(pk)sname</span><br><span class="line">---------------------</span><br><span class="line">1张三</span><br><span class="line">2李四</span><br><span class="line">3王五</span><br><span class="line"></span><br><span class="line">t_teacher 讲师表</span><br><span class="line">tno(pk)tname</span><br><span class="line">---------------------</span><br><span class="line">1王老师</span><br><span class="line">2张老师</span><br><span class="line">3李老师</span><br><span class="line"></span><br><span class="line">t_student_teacher_relation 学生关系讲师表</span><br><span class="line">id(pk)sno(fk)tno(fk)</span><br><span class="line">---------------------------------</span><br><span class="line">113</span><br><span class="line">211</span><br><span class="line">322</span><br><span class="line">423</span><br><span class="line">531</span><br><span class="line">633</span><br></pre></td></tr></table></figure><ul><li>第三范式：建立在第二范式之上，所有非主键字段直接依赖主键，不能产生传递依赖</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一对多？ 两张表 多的表加外键</span><br><span class="line"></span><br><span class="line">班级t_class</span><br><span class="line">cno(pk)cname</span><br><span class="line">------------------</span><br><span class="line">1班级1</span><br><span class="line">2班级2</span><br><span class="line"></span><br><span class="line">学生t_student</span><br><span class="line">sno(pk)snameclassno(fk)</span><br><span class="line">------------------------------------</span><br><span class="line">101张11</span><br><span class="line">102张21</span><br><span class="line">103张32</span><br><span class="line">104张42</span><br><span class="line">105张52</span><br></pre></td></tr></table></figure><ul><li><p>提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度</p></li><li><p>一对一怎么设计？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种方案：主键共享</span><br><span class="line">t_user_login  用户登录表</span><br><span class="line">id(pk)username  password</span><br><span class="line">------------------------------------</span><br><span class="line">1zs  123</span><br><span class="line">2ls  456</span><br><span class="line"></span><br><span class="line">t_user_detail  用户详细信息表</span><br><span class="line">id(pk+fk)realnametel...</span><br><span class="line">------------------------------------</span><br><span class="line">2李四 12345</span><br><span class="line">1张三 87998</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第二种方案：外键唯一</span><br><span class="line">t_user_login  用户登录表</span><br><span class="line">id(pk)username  password</span><br><span class="line">------------------------------------</span><br><span class="line">1zs  123</span><br><span class="line">2ls  456</span><br><span class="line"></span><br><span class="line">t_user_detail  用户详细信息表</span><br><span class="line">id(pk)realname  teluserid(fk+unique)...</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">2李四 12345   2</span><br><span class="line">1张三 87998   1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQl&quot;&gt;&lt;a href=&quot;#SQl&quot; class=&quot;headerlink&quot; title=&quot;SQl&quot;&gt;&lt;/a&gt;SQl&lt;/h1&gt;&lt;h2 id=&quot;数据库概述及数据准备&quot;&gt;&lt;a href=&quot;#数据库概述及数据准备&quot; class=&quot;headerlink&quot; title=&quot;数</summary>
      
    
    
    
    <category term="Sql" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/Sql/"/>
    
    
    <category term="Mysql" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs模块化</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/04/11/NodeJs%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/04/11/NodeJs%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2022-04-11T10:41:15.000Z</published>
    <updated>2022-05-17T01:12:47.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NodeJs模块化"><a href="#NodeJs模块化" class="headerlink" title="NodeJs模块化"></a>NodeJs模块化</h1><ul><li>第一部分<ul><li>后端的规范与思想</li></ul></li><li>第二部分<ul><li>基础的API</li></ul></li><li>第三部分<ul><li>常用的框架</li></ul></li><li>第四部分（Web项目）<ul><li>接收Web请求</li><li>处理业务逻辑</li><li>文件操作</li><li>数据库（MySql，MongoDB）</li><li>反向代理服务器（IP哈希，轮询）</li></ul></li></ul><span id="more"></span><h2 id="后端的规范与思想"><a href="#后端的规范与思想" class="headerlink" title="后端的规范与思想"></a>后端的规范与思想</h2><ol><li><p>分层</p><ol><li>Web层（接收和发送Http请求，判断，传给服务层，封装），又叫controller层</li><li>业务逻辑层（服务层，进行比较信息，XXXService）</li><li>DAO层（数据访问对象）<ol><li>DataBase(DB):存数据</li><li>业务：对对象进行操作</li><li>如果要存储：对象转为数据</li><li>如果要读取：数据转为对象</li></ol></li><li>持久层：存在磁盘上<ol><li>文件，数据库</li></ol></li><li>Domain：实体层</li></ol></li><li><p>模块化</p><ol><li>ES6:支持导入和导出,ES3、ES5缺点：缺少模块化概念</li><li>Js规范缺乏管理机制</li><li>NPM</li></ol></li></ol><h2 id="node模块化"><a href="#node模块化" class="headerlink" title="node模块化"></a>node模块化</h2><h3 id="node的导入与导出"><a href="#node的导入与导出" class="headerlink" title="node的导入与导出"></a>node的导入与导出</h3><p>导入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;模块&quot;</span>)</span><br></pre></td></tr></table></figure><p>导出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = ...</span><br><span class="line"><span class="built_in">exports</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//exports是module.exports的简写,都可以使用,但当二者遇到时,优先导出module.exports</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span> = a</span><br><span class="line"><span class="built_in">module</span>.exports = b</span><br><span class="line"><span class="comment">// 但当exports.a = a和module.exports.b = b这样使用时则module.export不会覆盖exports</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="built_in">require</span>(<span class="string">&quot;./test.js&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test) <span class="comment">// abcd</span></span><br></pre></td></tr></table></figure><p>注意: NodeJs是运行在一个函数中的，并不是一个全局函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Nodejs的模块是运行在一个函数中的</span></span><br><span class="line"><span class="comment">// 把这些东西当作参数传入到函数中</span></span><br><span class="line"><span class="comment">// 函数名不知道是什么</span></span><br><span class="line"><span class="comment">// 同时参数顺序如下，可以通过console.log(arguments)查看</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xyz</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//---</span></span><br><span class="line">  <span class="comment">// 中间的内容是我们写的nodejs的代码</span></span><br><span class="line">  <span class="comment">//---</span></span><br><span class="line">  <span class="comment">// NodeJs的模块试运行在一个函数中的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.log(arguments)</span></span><br><span class="line">[Arguments] &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: &#123;&#125;, <span class="comment">//exports</span></span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: [<span class="built_in">Function</span>: <span class="built_in">require</span>] &#123;...&#125;, <span class="comment">// require</span></span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: Module &#123;&#125;, <span class="comment">//module</span></span><br><span class="line">  <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;d:\\**\\filename.js&#x27;</span>, <span class="comment">//__filename</span></span><br><span class="line">  <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;d:\\**\\**\\dirname&#x27;</span> <span class="comment">//__dirname</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NodeAPI"><a href="#NodeAPI" class="headerlink" title="NodeAPI"></a>NodeAPI</h2><h3 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h3><blockquote><p><code>net</code> 模块提供了异步的网络 API，用于创建基于流的 TCP 或 <a href="http://nodejs.cn/api/net.html#ipc-support">IPC</a> 服务器 (<a href="http://nodejs.cn/api/net.html#netcreateserveroptions-connectionlistener"><code>net.createServer()</code></a>) 和客户端 (<a href="http://nodejs.cn/api/net.html#netcreateconnection"><code>net.createConnection()</code></a>)。</p></blockquote><p><code>Net</code>模块可用于创建Socket服务器或Socket客户端。NodeJS 的数据通信，最基础的两个模块是 Net 和 Http，前者是基于 Tcp 的封装，后者本质还是 Tcp 层，只不过做了比较多的数据封装，我们视为表现层</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202204211035533.png" alt="image-20220421102836497"></p><ul><li>使用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>创建Server层</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = net.createServer()</span><br></pre></td></tr></table></figure><ul><li>创建Client层</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = net.createConnection(port，host)</span><br><span class="line">或</span><br><span class="line"><span class="keyword">const</span> socket = net.connect(port，host)</span><br></pre></td></tr></table></figure><ul><li>在server端监听端口</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.listen(port，host)</span><br></pre></td></tr></table></figure><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ul><li><strong>listening</strong><ul><li>在调用 <a href="http://nodejs.cn/api/net.html#serverlisten"><code>server.listen()</code></a> 后绑定服务器时触发。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务已启动&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用on绑定</span></span><br></pre></td></tr></table></figure><ul><li><strong>connection</strong><ul><li>建立新连接时触发。 <code>socket</code> 是 <code>net.Socket</code> 的实例。</li><li>当有client连接socket时触发</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数socket,当连接时返回socket</span></span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;有新的连接&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>close</strong><ul><li>当server端关闭时触发</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&#x27;close&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>error</strong><ul><li>当出现错误是触发</li></ul></li></ul><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul><li><strong>listen</strong><ul><li>在server端监听端口</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.listen(port，host)</span><br></pre></td></tr></table></figure><ul><li><strong>close</strong><ul><li>关闭server端</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.close()</span><br><span class="line"><span class="comment">// 基本上不适用close关闭</span></span><br></pre></td></tr></table></figure><ul><li><strong>address</strong><ul><li>返回server的地址</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(server.address())</span><br><span class="line"><span class="comment">// &#123; address: &#x27;127.0.0.1&#x27;, family: &#x27;IPv4&#x27;, port: 3366 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><h5 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h5><ul><li><strong>connect</strong><ul><li>当成功建立与server连接时触发。 </li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket.js</span></span><br><span class="line">socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;已连接到服务器&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><strong>data</strong></p><ul><li><p>接收到数据时触发。 参数 <code>data</code> 将是 <code>Buffer</code> 或 <code>String</code>。 数据的编码由 <a href="http://nodejs.cn/api/net.html#socketsetencodingencoding"><code>socket.setEncoding()</code></a> 设置。</p><p>如果 <code>Socket</code> 触发 <code>&#39;data&#39;</code> 事件时没有监听器，则数据将丢失。</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket.js</span></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> socket = net.connect(<span class="number">3366</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收server返回的消息</span></span><br><span class="line">socket.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给server端发送数据</span></span><br><span class="line">socket.write(<span class="string">&#x27;你好，server端&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = net.createServer()</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3366</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 连接后接收消息，返回socket端消息</span></span><br><span class="line">  socket.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    socket.write(<span class="string">&#x27;hello client&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><strong>end</strong></p><ul><li>当连接传输结束时触发</li></ul></li><li><p><strong>timeout</strong></p><ul><li>当socket空闲超时触发，仅是表明socket已经空闲。用户必须手动关闭连接。</li></ul></li><li><p><strong>error</strong></p><ul><li>发生错误时触发。 <code>&#39;close&#39;</code> 事件将在此事件之后直接调用。</li></ul></li><li><p><strong>close</strong></p><ul><li>当socket端关闭时触发</li></ul></li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><p><strong>remoteAddress</strong></p><ul><li>服务器地址</li></ul></li><li><p><strong>remotePort</strong></p><ul><li>服务器端口</li></ul></li><li><p><strong>localAddress</strong></p><ul><li>本地地址</li></ul></li><li><p><strong>localPort</strong></p><ul><li>本地端口</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket.js</span></span><br><span class="line">socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;已连接到服务器&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(socket.remoteAddress)</span><br><span class="line">  <span class="built_in">console</span>.log(socket.remotePort)</span><br><span class="line">  <span class="built_in">console</span>.log(socket.localAddress)</span><br><span class="line">  <span class="built_in">console</span>.log(socket.localPort)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">// 服务器地址</span></span><br><span class="line"><span class="number">3366</span>  <span class="comment">// 服务器端口</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">// 本地地址</span></span><br><span class="line"><span class="number">51672</span>  <span class="comment">// 本地端口</span></span><br></pre></td></tr></table></figure><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li><p><strong>setTimeout</strong></p><ul><li>socket闲置时间超过<code>timeout</code>毫秒后 ，将socket设置为超时。</li><li>触发空闲超时事件时，socket将会收到<code>&#39;timeout&#39;</code>事件，但是连接不会被断开。用户必须手动调用<code>end()</code>或<code>destroy()</code>这个socket。</li><li>如果<code>timeout</code>= 0，那么现有的闲置超时会被禁用</li><li>可选的callback参数将会被添加成为’timeout’事件的一次性监听器。</li></ul></li><li><p><strong>write</strong></p><ul><li>向server端发送数据或向socket端返回数据</li></ul></li><li><p><strong>setEncoding</strong></p><ul><li>设置socket的编码为可读流。</li></ul></li><li><p><strong>end</strong></p><ul><li>关闭socket端服务方法</li></ul></li></ul><h4 id="获取响应头，返回数据"><a href="#获取响应头，返回数据" class="headerlink" title="获取响应头，返回数据"></a>获取响应头，返回数据</h4><p>可以通过Net来进行浏览器之间的数据交互，在浏览器上进行访问server地址:端口来进行访问server，通过server端的操作来进行获取响应头以及返回数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Socket &#125; = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口12306,地址为127.0.0.1</span></span><br><span class="line">server.listen(<span class="number">12306</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务已启动&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接时进行触发</span></span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;有新的连接&#x27;</span>)</span><br><span class="line">  <span class="comment">// 当浏览器访问时返回Http报文</span></span><br><span class="line">  socket.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    <span class="comment">// 获取响应报文的url，进行split分割</span></span><br><span class="line">    <span class="keyword">var</span> request = data.toString().split(<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">    <span class="comment">// 获取数组中第一位进行分割获取url页面地址</span></span><br><span class="line">    <span class="keyword">var</span> url = request[<span class="number">0</span>].split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">console</span>.log(url)</span><br><span class="line">   <span class="comment">// 获取Http报文后，可以进行返回响应报文</span></span><br><span class="line">    socket.write(<span class="string">`HTTP 200OK\r\n</span></span><br><span class="line"><span class="string">      Content-type:text/html\r\n</span></span><br><span class="line"><span class="string">      ServerDWS/1.1\r\n</span></span><br><span class="line"><span class="string">      &lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器端输入127.0.0.1:12306/abc</span></span><br><span class="line"><span class="comment">// 后面的abc是为了查看报文可以进行交互</span></span><br></pre></td></tr></table></figure><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><blockquote><p><code>fs</code> 模块支持以标准 POSIX 函数建模的方式与文件系统进行交互。</p></blockquote><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><ul><li>fs.writeFileSync<ul><li>同步</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   fs.writeFileSync(<span class="string">&#x27;message.txt&#x27;</span>,data) </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fs.writeFile<ul><li>异步</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">&#x27;message.txt&#x27;</span>, data, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>fs.appendFile<ul><li>可读可写</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">fs.appendFile(fileName, data + <span class="string">&#x27;\n&#x27;</span>, &#123; <span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="fs-open"><a href="#fs-open" class="headerlink" title="fs.open"></a>fs.open</h4><blockquote><p>打开文件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [open 打开文件]</span></span><br><span class="line"><span class="comment"> * path      [path 文件路径]</span></span><br><span class="line"><span class="comment"> * flags     [flags 文件打开行为]</span></span><br><span class="line"><span class="comment"> * mode      [mode 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。]</span></span><br><span class="line"><span class="comment"> * callback  [callback 回调函数]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fs.open(path, flags[, mode], callback)</span><br></pre></td></tr></table></figure><ul><li>flags参数为以下值</li></ul><table><thead><tr><th align="left">Flag</th><th align="left">描述</th><th align="center">可读</th><th align="center">可写</th><th align="center">可创建</th><th align="center">可追加</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">以读取模式打开文件，如果文件不存在则抛出异常</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">r+</td><td align="left">以读写模式打开文件，如果文件不存在则抛出异常</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">rs</td><td align="left">以同步的方式读取文件</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left">rs+</td><td align="left">以同步方式读取和写入文件</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">w</td><td align="left">以写入模式打开文件，如果文件不存在则创建</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="left">wx</td><td align="left">类似’w’，但是如果文件路径存在，则文件写入失败</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="left">w+</td><td align="left">以读写模式打开文件，如果文件不存在则创建</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="left">wx+</td><td align="left">类似’w+’，如果文件路径存在，则写入失败</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">a</td><td align="left">以追加模式打开文件，如果文件不存在则创建</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">ax</td><td align="left">类似’a’,但如果文件路径存在，则文件追加失败</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">a+</td><td align="left">以读取追加模式打开文件，如果文件不存在则创建</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">ax+</td><td align="left">类似’a+’，如果文件路径存在，则文件读取追加失败</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步打开文件</span></span><br><span class="line">fs.open(<span class="string">&quot;message.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;打开成功&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;NodeJs模块化&quot;&gt;&lt;a href=&quot;#NodeJs模块化&quot; class=&quot;headerlink&quot; title=&quot;NodeJs模块化&quot;&gt;&lt;/a&gt;NodeJs模块化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;第一部分&lt;ul&gt;
&lt;li&gt;后端的规范与思想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二部分&lt;ul&gt;
&lt;li&gt;基础的API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三部分&lt;ul&gt;
&lt;li&gt;常用的框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四部分（Web项目）&lt;ul&gt;
&lt;li&gt;接收Web请求&lt;/li&gt;
&lt;li&gt;处理业务逻辑&lt;/li&gt;
&lt;li&gt;文件操作&lt;/li&gt;
&lt;li&gt;数据库（MySql，MongoDB）&lt;/li&gt;
&lt;li&gt;反向代理服务器（IP哈希，轮询）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NodeJs" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/NodeJs/"/>
    
    
    <category term="NodeJs" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>Vue2基础</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/02/09/Vue2/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/02/09/Vue2/</id>
    <published>2022-02-09T08:48:33.000Z</published>
    <updated>2022-05-18T07:51:47.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><ul><li><p>什么会影响到Web应用的性能？</p><ul><li>操作DOM影响性能，因为操作DOM是十分昂贵的</li></ul></li><li><p>为什么操作DOM非常昂贵</p><ul><li>JS和DOM是两种东西，每次连接都需要耗费性能</li><li>操作DOM会导致重排和重绘</li></ul></li><li><p>JS与DOM的关系</p><ul><li>DOM是一种独立于语言的，用于操作XML和HTML文档的程序接口（API）。在浏览器中主要用于与HTML文档打交道，并且使用DOM API用来访问文档中的数据</li><li>DOM是个与语言无关的API，他在浏览器中的接口却是用JavaScript来实现的。客户端脚本编程大多数都是在底层文档打交道，DOM就成为现在JS编码的重要部分</li><li>浏览器通常会把DOM和Javascript独立实现</li></ul></li><li><p>DOM的位置和JavaScript的位置</p><ul><li>在IE中，JavaScript的实现名为JScript，位于<code>jscript.dll</code>文件总，DOM的实现则存在另一个库中，名为<code>mshtml.dll</code>（内部称为trident）</li><li>safari中的DOM和渲染是使用<code>webkit</code>中的<code>webcore</code>实现，JavaScript部分是由独立的<code>SquirelFish</code>引擎来实现</li><li>google chrome 使用<code>webkit</code>中的<code>webCore</code>库来渲染页面，但JavaScript引擎是他们自己研发的，名为V8</li><li>firefox的JavaScript引擎名为<code>TraceMonkey</code>，与名为<code>Gecko</code>的渲染引擎相互独立</li></ul></li><li><p>浏览器渲染过程</p><ul><li>浏览器下载完页面的所有组件：HTML、JavaScript、CSS、图片后，开始渲染过程</li><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则树，生成render树</li><li>布局render树，负责各元素尺寸、位置的计算（占用CPU计算）</li><li>绘制render树，绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU将各层合成（占用GPU计算）</li></ul></li><li><p>重排重绘</p><ul><li>当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为<strong>重排</strong>，完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为<strong>重绘</strong>。</li></ul></li><li><p>什么时候触发重排？</p><ul><li>当页面布局和几何属性改变时就需要重排：</li><li>添加或删除可见的DOM元素</li><li>元素位置改变</li><li>元素尺寸改变（外边距、内边距、边框厚度、宽度、高度等）</li><li>内容改变，例：文本改变或图片被另一个不同尺寸的图片替代</li><li>页面渲染器初始化</li><li>浏览器窗口尺寸改变</li><li>各css属性对于重排重绘的影响：<a href="https://csstriggers.com/">CSS 触发器 (csstriggers.com)</a></li></ul></li><li><p>关于GPU</p><ul><li>GPU分类：</li><li>家用GPU（不适合画图型）</li><li>专业GPU（适合画图型）</li><li>DOM操作却都是要求画图型的，但是我们用的都是家用GPU，画图型耗费的性能是专业GPU的几十倍</li></ul></li><li><p>为什么vue的性能会更好？</p><ul><li>Vue的核心是虚拟DOM，使用虚拟DOM可以减少DOM的操作，从而提升应用的性能</li></ul></li><li><p>什么是虚拟DOM</p><ul><li>虚拟dom：virtual dom（也称为vdom）</li><li>所谓虚拟dom，即为伪dom，假的dom，他不是一个真是的dom，而是由JS来模拟出来的具有真实dom结构的一个树形结构</li></ul></li><li><p>为什么要用JS来模拟dom结构</p><ul><li>在前端的三种语言中（html、css、js）中，只有js是一种编程语言，只有js能做到判断、循环、递归、能够实现各种逻辑、实现各种算法</li><li>dom的操作是昂贵的，js的运行效率更高，将dom对比放在js层，减少dom操作，效率更高</li><li>JS模拟DOM结构</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>为师者<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>当传道授业解惑<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vDom = &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    children[</span><br><span class="line">    &#123;</span><br><span class="line"><span class="attr">tag</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line"><span class="attr">class</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [<span class="string">&#x27;为师者&#x27;</span>]</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line"><span class="attr">tag</span>: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line"><span class="attr">class</span>: <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [<span class="string">&#x27;当传道授业解惑&#x27;</span>]</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么要使用vue？<ul><li>性能更好</li><li>视图、数据分离</li><li>维护成本低</li></ul></li><li>什么是vue？<ul><li>是一个渐进式的框架（MVVM）</li><li>MVVM<ul><li>M：Model</li><li>V：View</li><li>VM：ViewModel</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202202111048740.png" alt="image-20220211104817260"></li></ul></li></ul><h2 id="创建一个Vue实例"><a href="#创建一个Vue实例" class="headerlink" title="创建一个Vue实例"></a>创建一个Vue实例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; name &#125;&#125; <span class="comment">&lt;!-- 绑定data中的数据，使用&#123;&#123;data&#125;&#125;来包裹住值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>VUE<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 绑定事件可以不用&#123;&#123;data&#125;&#125;包裹 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;tag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-bind:href =&gt; :href(简写)   用于绑定属性里面的值</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-on:click =&gt; @click(简写)   v-on相当于js中on，事件为click</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-html == innerHTML</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-text == innerText</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// element 元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 用于绑定某个标签</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>, <span class="comment">// el =&gt; element</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 数据，el绑定的标签可以直接访问</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;shan&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">url</span>: <span class="string">&#x27;https://vuejs.bootcss.com/guide/&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">tag</span>: <span class="string">&#x27;&lt;span&gt;我是一个span标签&lt;/span&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;, </span></span><br><span class="line"><span class="javascript">        <span class="comment">// 用来书写方法的</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">changeName</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.name = <span class="built_in">this</span>.name + <span class="string">&#x27;1&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><p>在<code>method</code>中，每次如果重新触发渲染时，则调用的方法将会再次执行函数，无论渲染的数据是不是与函数有关，都会再次执行函数，下面的<strong>describe</strong>函数，如果<code>age</code>改变之后，<code>describe</code>也会再次触发一次，而<code>age</code>改变时<code>describe</code>函数本不应该触发</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;describe&#125;&#125; &#123;&#123;age&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&quot;Long&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">looks</span>: <span class="string">&quot;beautiful&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">describe</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.looks;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;, </span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>watch</code>侦听<code>name</code>和<code>looks</code>之后，不会随着其他属性的改变而触发name和looks函数，<code>name()</code>和<code>looks()</code>会观察<code>name</code>和<code>looks</code>属性，随着它们的改变而改变，但是容易滥用<code>watch</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">     &#123;&#123;describe&#125;&#125; &#123;&#123;age&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&quot;Long&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">looks</span>: <span class="string">&quot;beautiful&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">describe</span>: name + <span class="string">&#x27; &#x27;</span> + looks</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// watch侦听name和looks属性</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">name</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.describe = <span class="built_in">this</span>.name + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.looks;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">looks</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.describe = <span class="built_in">this</span>.name + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.looks;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而更好的方式是使用计算机属性而不是滥用<code>watch</code>，上面的代码重复性很高，下面的代码看起来更好</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;describe&#125;&#125; &#123;&#123;age&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&quot;Long&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">looks</span>: <span class="string">&quot;beautiful&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// describe: &quot;Long beautiful&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算机属性</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 默认只有getter，没有setter，如果需要时，可以自己提供setter，如下</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">/*describe() &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                console.log(&#x27;--computed--&#x27;);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                return this.name + &quot; &quot; + this.looks;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            &#125; */</span></span></span><br><span class="line"><span class="javascript">            <span class="attr">describe</span> : &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// getter 读</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.looks</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="comment">// setter 写</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">set</span>(<span class="params"> value </span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> arr = value.split(<span class="string">&quot; &quot;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.name = arr[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.looks = arr[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(arr[<span class="number">0</span>] == <span class="string">&#x27;yzl&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">this</span>.age = <span class="number">18</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><p>Class绑定</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>  <span class="attr">:class</span>=<span class="string">&quot;&#123;active:activeBool&#125;  [active,action]&quot;</span> </span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">&quot;changeColor&quot;</span>&gt;</span></span><br><span class="line">        Leg</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// class 拥有两个参数，对象和数组 &quot;&#123;&#125; / []&quot;</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 对象中拥有两个值，name和value，name为类名，value是一个布尔值，判断显不显示，&#123;key,value,……&#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#123;&#125; =&gt; key -&gt; name/value -&gt; blue</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 数组中每一项都是name，name就是类名，[classname,classname,……]</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// [] =&gt; 每一项都是类名 class name</span></span></span><br><span class="line"><span class="javascript">        </span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">activeBool</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">active</span>: <span class="string">&quot;active&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">action</span>: <span class="string">&quot;action&quot;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">changeColor</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.activeBool = !<span class="built_in">this</span>.activeBool;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Style绑定</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span> = <span class="string">&quot;&#123;width:&#x27;200px&#x27;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:style</span> = <span class="string">&quot;[styleObj,colorStyleObj]&quot;</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">&quot;changeColor&quot;</span>&gt;</span></span><br><span class="line">                Leg</span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// style</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 对象中key和value分别对应着属性和属性值,&#123;width: &#x27;100px&#x27;&#125;,如line-height变换为小驼峰命名法或加上单引号</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#123;&#125; =&gt; &#123;key/value&#125;</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 数组中是一个又一个对象组成</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// [] =&gt; [&#123;&#125;,&#123;&#125;]</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">activeBool</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">styleObj</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">width</span>: <span class="string">&#x27;200px&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">lineHeight</span>: <span class="string">&#x27;200px&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">colorStyleObj</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">backgroundColor</span>: <span class="string">&quot;yellow&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>条件渲染，它们之间不可以出现第三者，必须紧跟其后</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">v-if ==&gt; if()&#123;&#125;</span></span><br><span class="line"><span class="comment">true -&gt; 显示</span></span><br><span class="line"><span class="comment">false -&gt; 隐藏</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showOrHiden&quot;</span>&gt;</span>显示隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show ==1&quot;</span>&gt;</span></span><br><span class="line">        显示1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;show == 2&quot;</span>&gt;</span></span><br><span class="line">        显示2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        隐藏了</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">show</span>: <span class="string">&quot;1&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">count</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">showOrHiden</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(show == <span class="string">&#x27;1&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    show = <span class="string">&quot;2&quot;</span>;</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(show == <span class="string">&#x27;2&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    show = <span class="string">&quot;3&quot;</span>;</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    show = <span class="string">&#x27;1&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换。但是如果在不同得输入框之间 将会非常有很严重得问题，所以要给不复用的元素添加<code>key</code>值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">show</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">showOrHiden</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.show = !<span class="built_in">this</span>.show</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>v-show</code>条件渲染，v-show和v-if不同的是，<code>v-show</code>渲染的元素总是被保留在DOM中，通过切换元素CSS属性来渲染，<code>v-if</code>渲染的元素都是销毁之后再重新渲染，如果需要频繁的切换，使用<code>v-show</code>比较好</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--总是通过CSS property dislay 来切换--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line">        显示1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">show</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">showOrHiden</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.show = !<span class="built_in">this</span>.show</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p><strong>v-for</strong></p><h3 id="数组列表渲染"><a href="#数组列表渲染" class="headerlink" title="数组列表渲染"></a>数组列表渲染</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">使用v-for来渲染列表，item是别名，newList是数据源，使用v-for时，还需要给每个节点添加一个key值，让性能提升</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in newList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;item.new&quot;</span>&gt;</span>新<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-for</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-bind:key =&gt; :key </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">newList</span>: [</span></span><br><span class="line"><span class="javascript">                &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">title</span>: <span class="string">&quot;第三胎生父&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">new</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">id</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">title</span>: <span class="string">&quot;第一胎生父&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">new</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">id</span>: <span class="number">1</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">title</span>: <span class="string">&quot;第二胎生父&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">new</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">id</span>: <span class="number">2</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">title</span>: <span class="string">&quot;第四胎生父&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">new</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">id</span>: <span class="number">3</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">title</span>: <span class="string">&quot;第七胎生父&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">new</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">id</span>: <span class="number">4</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">            ]</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变更方法，它们会触发视图更新</p><ul><li><strong>push</strong></li><li><strong>pop</strong></li><li><strong>shift</strong></li><li><strong>unshift</strong></li><li><strong>splice</strong></li><li><strong>sort</strong></li><li><strong>reverse</strong></li></ul><p>非变更方法，它们不会变更原始数组，总是返回一个新数组，当使用时，总是替换旧数组</p><ul><li><strong>filter</strong></li><li><strong>concat</strong></li><li><strong>slice</strong></li></ul><h3 id="对象列表渲染"><a href="#对象列表渲染" class="headerlink" title="对象列表渲染"></a>对象列表渲染</h3><p>对象如果想要更新列表视图的话可以直接对对象中的值进行改变，不过不可以添加新的在值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">对象可以列表渲染可以找到key、value、index属于对象的三个值</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key,index) in userInfo&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;key&#125;&#125; --- &#123;&#123;value&#125;&#125; --- &#123;&#123;index&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-for</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// v-bind:key =&gt; :key </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">userInfo</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">name</span>: <span class="string">&#x27;数理逻辑士大夫&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">age</span>: <span class="number">18</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>Vue.set</code> 和 <code>vm.$set</code></p><p>Vue.set是一个全局变量，vm.set是一个局部的，vm就是用一个变量接受了一个Vue实例，他们两个使用方法是一样的</p><p>它们两个可以触发视图更新，和数组的一些方法一样，它可以处理对象和数组两种方式</p><p>数组：<code>Vue.set(vm.数组, 索引,对象)</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(vm.newList, <span class="number">6</span>, &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;第八胎生父&quot;</span>,</span><br><span class="line">    <span class="attr">new</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="number">7</span></span><br><span class="line">&#125;,)</span><br></pre></td></tr></table></figure><p>对象：<code>Vue.set(vm.对象, key, 属性值)</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(vm.userInfo, <span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>v-for 如果和 v-if 一起使用的话，v-for的优先级更高</strong></p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li>监听事件<ul><li>使用<code>v-on</code>或<code>@</code>来监听DOM事件，并在触发时，运行JS代码，和JS事件相同</li></ul></li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li><code>.stop</code>：阻止单击事件继续传播</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.prevent</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交事件不在重载页面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.capture</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.self</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.once</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>passive</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用按键码也是可以的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-on:keyup<span class="number">.13</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>也可以通过全局<code>config.keyCodes</code>对象自定义按键修饰符别名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 v-on:keyup.f1</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure><p>Vue提供了大多数常用的按键码的别名</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>delete</code>：删除键和退格键</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h3 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h3><p>按下相应按键触发鼠标或键盘事件的监听器</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code> :对应键盘上的Window徽标键</li><li><code>.exact</code>：允许控制键盘键组合触发的事件</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>鼠标按钮修饰符</p><ul><li><p>仅响应特定的鼠标按钮</p></li><li><p><code>.left</code></p></li><li><p><code>.right</code></p></li><li><p><code>.middle</code></p></li></ul><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><ul><li><p><code>v-model</code>：双向绑定数据</p></li><li><p>修饰符</p></li><li><p><code>.lazy</code>：在每次<strong>input</strong>事件后将输入框的值与数据进行同步</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在change时而非input时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.number</code>：将输入的值转换为<strong>number</strong>类型</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.trim</code>：过滤用户输入的空白字符</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>例子</strong>：todoList</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;inputValue&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;addTask&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addTask&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123;&#123;propmt&#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in todoList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123;item&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;completeTask(index)&quot;</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>已完成任务<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in completeList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123;item&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">inputValue</span>: <span class="string">&quot;&quot;</span>, <span class="comment">//input的value</span></span></span><br><span class="line"><span class="javascript">            <span class="attr">propmt</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 警告消息</span></span></span><br><span class="line"><span class="javascript">            <span class="attr">todoList</span>: [], <span class="comment">// 发布的任务</span></span></span><br><span class="line"><span class="javascript">            <span class="attr">completeList</span>: [], <span class="comment">//完成任务数组</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">addTask</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(<span class="built_in">this</span>.inputValue == <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.propmt = <span class="string">&quot;不能输入空任务&quot;</span>;</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.todoList.includes(<span class="built_in">this</span>.inputValue)) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.propmt = <span class="string">&quot;不能输入相同的任务&quot;</span>;</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.todoList.push(<span class="built_in">this</span>.inputValue);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.inputValue = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 将索引为index的值裁剪下来，push到completeList中</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">completeTask</span>(<span class="params">index</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> task = <span class="built_in">this</span>.todoList.splice(index,<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.completeList.push(...task);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件And插槽"><a href="#组件And插槽" class="headerlink" title="组件And插槽"></a>组件And插槽</h2><blockquote><p> 组件就是可复用的实例</p></blockquote><p>组件分为全局组件和局部组件</p><h3 id="全局组件-amp-局部组件"><a href="#全局组件-amp-局部组件" class="headerlink" title="全局组件&amp;局部组件"></a>全局组件&amp;局部组件</h3><p>全局组件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span>  <span class="comment">&lt;!--将list作为组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span>  <span class="comment">&lt;!--组件可以重复使用--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">Vue.component(&quot;list&quot;, &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        data: function() &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            return &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                count: 0</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        &#125;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        template: `<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>提交</span><span class="template-variable">&#123;&#123;<span class="name">count</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>局部组件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用v-bind事件来绑定list属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span> <span class="attr">:list</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> list = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通过props向子组件传递数据</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 用来接受父组件的数据</span></span></span><br><span class="line"><span class="javascript">   <span class="attr">list</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">type</span>: <span class="built_in">Array</span>, <span class="comment">//类型</span></span></span><br><span class="line"><span class="javascript">               <span class="attr">default</span>: [], <span class="comment">// 默认数据</span></span></span><br><span class="line"><span class="javascript">               <span class="attr">required</span>: <span class="literal">true</span> <span class="comment">// 必填的</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                ...</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`&lt;button @click=&quot;count++&quot;&gt;提交&#123;&#123;count&#125;&#125;&lt;button&gt;`</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">method</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 方法</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">List</span>: list, <span class="comment">// 将List代表list组件，声明为局部组件</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 数据</span></span></span><br><span class="line"><span class="javascript">            <span class="attr">courseList</span>: [...],</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 方法</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意事项：<ul><li>组件可以重复使用</li><li>组件中的<code>data</code>必须是一个函数，因为如果多个实例使用该组件则各自返回的数据是独立的</li></ul></li></ul><h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><blockquote><p>当我们使用组件时，避免不了使用事件来和父级组件进行交互沟通。</p></blockquote><p>当我们使用组件时，想利用点击事件来和父级组件进行交互，则使用<code>native</code>属性</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">List</span> <span class="attr">:list</span>=<span class="string">&quot;courseList&quot;</span>  @<span class="attr">click.native</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">List</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用native属性可以进行调用父级组件中的方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> course = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123; &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">``</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">List</span>: course,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><p><strong>$emit(“事件名”)</strong></p><p>原生事件绑定到组件</p><p>如果多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这样就直接绑定了原生onClick事件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">List</span> @<span class="attr">click.native</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">List</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> list = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;&#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`&lt;input</span></span></span><br><span class="line"><span class="string"><span class="javascript">                      type=&quot;checkbox&quot;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                      v-bind:checked=&quot;checked&quot;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &gt;`</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">List</span>: list</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。比如上述的组件可能做了如下重构，所以根元素实际上是一个 <code>&lt;label&gt;</code> 元素：这时，父级的 <code>.native</code> 监听器将静默失败。它不会产生任何报错，但是 <code>click</code> 处理函数不会如你预期地被调用。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，Vue提供了<code>$listeners</code> property，它是一个对象，里面包含了作用在这个组建的所有监视器，如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">focus</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="attr">input</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<code>$listeneres</code> property，就可以配合<code>v-on:$listeners</code>，将所有的事件监听器执行这个组件的某个特定的子元素，所以，为了这些监听器创建一个下述的<code>inputListeners</code>属性是非常有用的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;base-input&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">inheritAttrs</span>:<span class="literal">false</span>, <span class="comment">// </span></span><br><span class="line">    <span class="attr">props</span>: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">inputListeners</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="comment">// 将所有的对象合并成一个新对象</span></span><br><span class="line">              <span class="comment">// 从父级添加所有的监听器</span></span><br><span class="line"><span class="built_in">this</span>.$listeners,</span><br><span class="line">                                 </span><br><span class="line">   <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">   &#123;</span><br><span class="line">                <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">                <span class="attr">input</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                        vm.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;label&gt;</span></span><br><span class="line"><span class="string">          &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">          &lt;input</span></span><br><span class="line"><span class="string">            v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">            v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">            v-on=&quot;inputListeners&quot;</span></span><br><span class="line"><span class="string">          &gt;</span></span><br><span class="line"><span class="string">        &lt;/label&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h4><p>我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件两侧都没有明显的变更来源。</p><p>所以使用<code>update:myPropName</code>的模式来触发事件取而代之</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;doc.title&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">&quot;doc.title = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">&quot;doc.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<code>.sync</code>修饰符的<code>v-bind</code>不可以使用表达式，只可以提供想要绑定的property名</p></blockquote><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><blockquote><p><code>&lt;slot&gt;&lt;/slot&gt;</code>插槽可以将一些数据写在组件内部，替换组件中的某些数据</p></blockquote><p>以下就是简单的插槽的应用，可以在组件中写</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cmp-two</span> <span class="attr">:list</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        我是一个简单的插槽！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">cmp-two</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> cmpTwo = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">list</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">type</span>: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">required</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">default</span>: [],</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`&lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;slot&gt;&lt;/slot&gt; </span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &lt;slot&gt;&lt;/slot&gt; 就是一个插槽，可以用来存放数据</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">            cmpTwo,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>有时我们需要多个插槽，来存放不同的内容，所有我们要给每一个插槽一个名字，例如如下模板的<code>&lt;cmp-one&gt;</code>组件</p><p>但是我们在向具名插槽提供内容的时候，我们要在一个<code>template</code>元素上使用<code>v-solt</code>指令，并在<code>v-slot</code>后面一参数的形式提供<code>slot</code>名称</p><p><code>v-slot:</code>指令可以简写成<code>#</code>号，例如<code>v-slot:header</code>可以重写为<code>#header</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cmp-one</span> <span class="attr">v-if</span>=<span class="string">&quot;showOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要向具名插槽中提供您内容时，要使用template元素并使用v-slot指令 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:before</span>&gt;</span> before <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:after</span>&gt;</span> after <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cmp-one</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;slot&gt;&lt;/slot&gt; 插槽 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;slot name=&#x27;&#x27;&gt;&lt;/slot&gt; 具名插槽 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    const cmpOne = &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        // 组件中有两个slot，第一个name为before,第二个name为after</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span> cmp-one组件：</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;before&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;after&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    const vm = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        el: &#x27;#app&#x27;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            cmpOne,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        &#125;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        data: &#123;&#125;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        methods: &#123;&#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>有时我们想要将插槽里面的内容可以访问组件里面的数据，那么可以使用作用域插槽</p><p>需要使用<code>v-list-property=&quot;data&quot;</code>来绑定作用于插槽绑定的数据</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">在这里使用cmp-two组件时，绑定list，在template元素中使用v-slot-prop=&quot;data&quot;获取作用域插槽绑定的数据 ，然后再插槽中使用绑定的数据</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cmp-two</span> <span class="attr">:list</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;list.item&#125;&#125; - &#123;&#123;list.index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cmp-two</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cmp-two</span> <span class="attr">:list</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;list.index&#125;&#125; - &#123;&#123;list.item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cmp-two</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    const cmpTwo = &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        props: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            list: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                type: Array,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                required: true,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                default: [],</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        &#125;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        // slot来v-for循环了list数组，绑定了list中的item和index</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>组件2：</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">slot</span> </span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="handlebars"><span class="attr">v-for</span>=<span class="string">&quot;(item,index) in list&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="handlebars"><span class="attr">:item</span>=<span class="string">&#x27;item&#x27;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="handlebars"><span class="attr">:index</span>=<span class="string">&#x27;index&#x27;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span><span class="template-variable">&#123;&#123;<span class="name">item</span>&#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123;<span class="name">index</span>&#125;&#125;</span><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                            <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    const vm = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        el: &#x27;#app&#x27;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            cmpTwo,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        &#125;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        data: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            list: [1,2,3,4,5],</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        &#125;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        methods: &#123;&#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li><code>v-list-default</code>的缩写默认为<code>v-list</code></li><li><code>v-list</code>不可以和具名插槽同时使用，容易造成作用域不明确</li><li>如果出现多个插槽，那么给所有的插槽都使用<code>&lt;template&gt;&lt;/template&gt;</code>元素</li></ul></li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>后备内容<ul><li>插槽在没有提供内容的时候被渲染，如果提供了内容就渲染提供的数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">slot中的Submit就是提供的后备内容，如果我使用组件时没有传入插槽数据，则就使用Submit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;submit-button&gt;</span></span><br><span class="line"><span class="comment">      Save</span></span><br><span class="line"><span class="comment">    &lt;/submit-button&gt;</span></span><br><span class="line"><span class="comment">但是当我像上面提供了数据，那么slot插槽中的数据就变成了Save</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0">动态指令参数</a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>动态组件就是在一个多标签的界面中使用<code>is</code>属性来切换不同的组件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过点击按钮赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCmp&quot;</span>&gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cmp-one</span>&gt;</span><span class="tag">&lt;/<span class="name">cmp-one</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cmp-two</span>&gt;</span><span class="tag">&lt;/<span class="name">cmp-two</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--通过component元素来实现动态组件，通过is属性实现切换组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;type&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;slot&gt;&lt;/slot&gt; 插槽 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;slot name=&#x27;&#x27;&gt;&lt;/slot&gt; 具名插槽 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> cmpOne = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件1：</span></span></span><br><span class="line"><span class="string"><span class="javascript">                        组件one</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> cmpTwo = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">list</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">type</span>: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">required</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">default</span>: [],</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件two&lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">            cmpOne,</span></span><br><span class="line"><span class="javascript">            cmpTwo,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">type</span>:<span class="string">&#x27;cmp-one&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 使用方法来进行变换组件赋值</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">changeCmp</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.type = <span class="built_in">this</span>.type == <span class="string">&#x27;cmp-one&#x27;</span> ? <span class="string">&#x27;cmp-two&#x27;</span> : <span class="string">&#x27;cmp-one&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在动态组件中使用<code>keep-alive</code>，我们使用动态组件来回切换的时候总是不会保存状态，会回到初始状态，我们更希望那些标签的组件实例在创建的时候缓存下来，这时候就可以用<code>keep-alive</code>包裹住</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--component中切换的组件就会被缓存下来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;type&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生命周期And挂载元素方式"><a href="#生命周期And挂载元素方式" class="headerlink" title="生命周期And挂载元素方式"></a>生命周期And挂载元素方式</h2><h3 id="挂载元素方式"><a href="#挂载元素方式" class="headerlink" title="挂载元素方式"></a>挂载元素方式</h3><p>挂载元素不仅仅只有<code>el</code>可以，也可以使用<code>vm.$mount(&quot;dom&quot;)</code>来挂载<strong>dom</strong>元素</p><ul><li><code>$mount(&quot;dom&quot;)</code></li><li><code>el：&quot;dom&quot;</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vm.#mount(&quot;#app&quot;);</span></span><br></pre></td></tr></table></figure><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><blockquote><p><code>template:String -&gt; AST(&#123;&#125;) -&gt; render -&gt; vNode -&gt; 真实的dom</code></p></blockquote><p><code>template</code>是一个字符串，vue通过一个操作，解析成一个抽象语法树<code>AST</code>，<code>AST</code>相当于一个对象，然后把<code>AST</code>把<code>ASP</code>传入到一个函数里面，叫做<code>render</code>函数，通过<code>render</code>函数得到一个虚拟节点<code>vNode</code>，通过<code>vNode</code>得到一个真实的DOM</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// el: &#x27;#app&#x27;,</span></span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">        <span class="attr">red</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">green</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// template优先级比el高，有template就不会找el或者$mount</span></span><br><span class="line">    <span class="attr">template</span>: <span class="string">&quot;&lt;div&gt;我是一个模板&lt;/div&gt;&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line">           </span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>使用<code>vue</code>时，刚开始会进行初始化，初始化完成之后会检查有没有<code>el</code>元素，如果有<code>el</code>时，会检查有没有<code>template</code>模板，如果有，那么会进行<code>template</code>操作，如果没有<code>el</code>时，会判断是否调用<code>$mount</code>方法，如果两个都没有实例就会结束，如果有<code>$mount</code>则会检查<code>template</code>是否存在，如果存在则会进行<code>template</code>操作，如果没有<code>template</code>，那么会找到挂载的元素，然后拿到挂载元素的<code>outerHTML</code>，然后把<code>outerHTML</code>作为一个模板进行一系列的处理<img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202202171511088.png" alt="image-20220217151145881"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// el: &#x27;#app&#x27;,</span></span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">        <span class="attr">red</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">green</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// template优先级比el高，有template就不会找el或者$mount</span></span><br><span class="line">    <span class="attr">template</span>: <span class="string">&quot;&lt;div&gt;我是一个模板&lt;/div&gt;&quot;</span>,</span><br><span class="line">    <span class="comment">// render函数优先级比template高，如果有render函数则先执行render函数</span></span><br><span class="line">    <span class="comment">// render函数的参数是一个函数</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"> createElement </span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">&quot;p&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">style</span>: &#123;</span><br><span class="line">                <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">                <span class="attr">fontSize</span>: <span class="string">&#x27;18px&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// class: [&quot;red&quot;,&#x27;green&#x27;],</span></span><br><span class="line">            <span class="attr">class</span>: &#123;</span><br><span class="line">                <span class="attr">red</span>: <span class="built_in">this</span>.red,</span><br><span class="line">                <span class="attr">green</span>: <span class="built_in">this</span>.green</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// domProps优先级高于createElement第三个参数</span></span><br><span class="line">            <span class="comment">// domProps: &#123;</span></span><br><span class="line">            <span class="comment">//     innerHTML: &quot;222&quot;</span></span><br><span class="line">            <span class="comment">// &#125; </span></span><br><span class="line">        &#125;,[</span><br><span class="line">            createElement(<span class="string">&#x27;h1&#x27;</span>,&#123;&#125;,<span class="string">&#x27;h1&#x27;</span>),</span><br><span class="line">            createElement(<span class="string">&#x27;h2&#x27;</span>,&#123;&#125;,<span class="string">&#x27;h2&#x27;</span>),</span><br><span class="line">            createElement(<span class="string">&#x27;h3&#x27;</span>,&#123;&#125;,<span class="string">&#x27;h3&#x27;</span>)</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vm.$mount(&quot;#app&quot;);</span></span><br></pre></td></tr></table></figure><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202202171540126.png" alt="Vue 实例生命周期"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.msg = <span class="string">&#x27;iiiii&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">destroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 第一个生命周期函数,表示实例完全被创建出来之前,会执行它</span></span><br><span class="line"><span class="comment">// 注意:在 beforeCreate 生命周期函数执行的时候, data 和 methods 中的 数据都还没有初始化</span></span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;----beforeCreate----&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">        alert(<span class="string">&quot;beforeCreate&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个生命周期函数</span></span><br><span class="line">    <span class="comment">// 在 created 中,data 和 methods 都已经被初始化好了!</span></span><br><span class="line">    <span class="comment">// 如果要调用 methods 中的方法,或者操作 data 中的数据,最早,只能在 created 中操作</span></span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;----Create----&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">        <span class="built_in">this</span>.a();</span><br><span class="line">        alert(<span class="string">&quot;Create&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第3个生命周期函数,表示 模板已经在内存中编辑完成了,但是尚未把模板渲染到 页面中</span></span><br><span class="line"><span class="comment">// 在 beforeMount 执行的时候,页面中的元素,还没有被真正替换过来,只是之前写的一些模板字符串</span></span><br><span class="line">    <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;beforeMount&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第4个生命周期函数,表示,内存中的模板,已经真实的挂载到了页面中,用户已经可以看到渲染好的页面了</span></span><br><span class="line"><span class="comment">// 注意:mounted 是实例创建期间的最后一个生命周期函数,当执行完 mounted 就表示,实例已经被完全创建好了,</span></span><br><span class="line"><span class="comment">// 此时,如果没有其它操作的话,这个实例,就静静的 躺在我们的内存中,一动不动</span></span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第五个生命周期函数，当执行的时候，页面显示的数据还是旧的，此时data的数据是最新的，页面尚未和最新的数据同步</span></span><br><span class="line">    <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第六个生命周期函数，执行updated时候，则页面和data数据已经保持同步了，都是最新的</span></span><br><span class="line">    <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;updated&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第七个生命周期函数</span></span><br><span class="line">    <span class="comment">// 当执行beforeDestroy时，Vue实例就从运行阶段进入到了销毁阶段；</span></span><br><span class="line">    <span class="comment">// 当执行beforeDestroy时，实例上所有的data和所有的methods，以及过滤器、指令……都处于可用状态，此时还没有真正执行销毁的过程</span></span><br><span class="line">    <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;beforeDestroy&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第八个生命周期函数</span></span><br><span class="line">    <span class="comment">// 当执行到destroyed函数的时候，组件已经被完全销毁了，此时，组件中所有的数据、方法、指令、过滤器……都已经不可用了</span></span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="初始路由"><a href="#初始路由" class="headerlink" title="初始路由"></a>初始路由</h3><p>路由<code>Vue Router</code>可以一个单页面应用程序跳转不刷新，更加的自然</p><p>如果只是想用一下简单的路由，不引入一个完成的<code>vue-Router</code>库，可以动态渲染一个页面的组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;Page not found&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Home = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;home page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> About = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;about page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: Home,</span><br><span class="line">  <span class="string">&#x27;/about&#x27;</span>: About</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">currentRoute</span>: <span class="built_in">window</span>.location.pathname</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ViewComponent () &#123;</span><br><span class="line">      <span class="keyword">return</span> routes[<span class="built_in">this</span>.currentRoute] || NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (h) &#123; <span class="keyword">return</span> h(<span class="built_in">this</span>.ViewComponent) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>使用vue-cli创建项目使用</strong></p><p>App.vue使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入script可以使用路由，也可以使用vue-cli创建脚手架后使用npm进行vue add router下载router引入使用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- router-link是一个vue自定义组件来创建链接，让vue router再不加载页面的情况下更改url --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 router-link 组件进行导航 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过传递 `to` 来指定路径链接 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--`&lt;router-link to=&#x27;/&#x27;&gt;` 和 `&lt;a href=&#x27;/&#x27;&gt;` 是一样的，但是如果使用a标签还是会刷新--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Go to Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>Go to About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 router-view是与url对应的自定义组件，可以放在任何地方，适应布局--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将使用路由的组件渲染到页面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>router.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义路由组件.</span></span><br><span class="line"><span class="comment">// 从可以在这里面写</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> <span class="comment">// 引用的vue文件</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span> <span class="comment">// 引用的vue-router文件</span></span><br><span class="line"><span class="keyword">import</span> HomeView <span class="keyword">from</span> <span class="string">&#x27;../views/HomeView.vue&#x27;</span> <span class="comment">// 引用的HomeView组件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;template&gt;</span></span><br><span class="line"><span class="comment">&lt;h1&gt;This is an Home page&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">&lt;/template&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> AboutView <span class="keyword">from</span> <span class="string">&#x27;../views/AboutView.vue&#x27;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;template&gt;</span></span><br><span class="line"><span class="comment">&lt;h1&gt;This is an about page&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">&lt;/template&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保 _use_ 路由实例使</span></span><br><span class="line"><span class="comment">// 整个应用支持路由。</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些路由</span></span><br><span class="line"><span class="comment">// 每个路由都需要映射到一个组件。</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: HomeView</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: AboutView</span><br><span class="line">    <span class="comment">// component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/AboutView.vue&#x27;)</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由实例并传递 `routes` 简单配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span> <span class="comment">// 将导航中的/#/消除</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router <span class="comment">// 导出路由，现在就可以全局使用了</span></span><br></pre></td></tr></table></figure><p><strong>main.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> <span class="comment">//引入vue</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span> <span class="comment">// 引入HTML</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span> <span class="comment">// 引入上面创建的router文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router, <span class="comment">//使用router</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">//</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">//挂载到#app上面</span></span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>一些应用程序的UI是由多层组件嵌套组成的，这种情况下，</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202202201900277.png" alt="image-20220220190014773"></p><p>通过<code>vue-Router</code>可以使用嵌套路由来表达这种嵌套关系</p><p>只需要在需要被嵌套的页面下配置<code>childeren</code></p><p>Router.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> HomeView <span class="keyword">from</span> <span class="string">&#x27;../views/HomeView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Home页面下面的嵌套路由</span></span><br><span class="line"><span class="keyword">import</span> HomeFile <span class="keyword">from</span> <span class="string">&#x27;../components/HomeView/HomeFile.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Download <span class="keyword">from</span> <span class="string">&#x27;../components/HomeView/HomePosts.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: HomeView,</span><br><span class="line">    <span class="comment">// HomeView的子页面，配置children就可以实现嵌套路由，children的配置方式和routes一样</span></span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;/home/homefile&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: HomeFile,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;homefile&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/home/homeposts&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: HomePosts,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;homeposts&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Home页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;homefile&#x27;&#125;&quot;</span>&gt;</span>文件<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;homeposts&#x27;&#125;&quot;</span>&gt;</span>邮件<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">    vue路由内置类名，用于路由被选中状态</span></span></span><br><span class="line"><span class="comment"><span class="css">    .router-link-active &#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">    .router-link-exact-active &#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">    */</span></span></span><br><span class="line"><span class="css">    </span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他配置都一样</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>很多时候，我们需要将给定匹配模式的路由映射到同一个组件。例如，我们可能有一个<code>Question</code>组件，它应该对所有用户进行渲染，但用户 ID 不同。在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，我们称之为 <em>路径参数</em> </p><p>router.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Question <span class="keyword">from</span> <span class="string">&#x27;../components/Question.vue&#x27;</span> <span class="comment">//question组件</span></span><br><span class="line"><span class="keyword">import</span> Err <span class="keyword">from</span> <span class="string">&#x27;../components/Err.vue&#x27;</span> <span class="comment">//404组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// community页面下面的路由</span></span><br><span class="line"><span class="keyword">import</span> Academic <span class="keyword">from</span> <span class="string">&#x27;../components/community/Academic.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Community <span class="keyword">from</span> <span class="string">&#x27;../views/Community.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/community&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;community&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Community, <span class="comment">//组件</span></span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/community/academic&#x27;</span>, <span class="comment">//重定向,当到达这个路径的时候，重定向到另外一个路径下去</span></span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;academic&#x27;</span>, <span class="comment">// 当path不写/号的时候可以直接写名字，代表是父路径下面的</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;academic&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: Academic</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 动态路由匹配</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/question/:id&#x27;</span>, <span class="comment">// :id就是一个动态字段</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;question&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Question</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/err.html&#x27;</span>, <span class="comment">// :id就是一个动态字段</span></span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;err&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: Err</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Academic.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">tag: 代表渲染成li</span></span><br><span class="line"><span class="comment">:to 相当于href,</span></span><br><span class="line"><span class="comment">&#123;name:&#x27;question&#x27;&#125; 就是router.js中配置name为question的组件，</span></span><br><span class="line"><span class="comment">&#123;params: &#123;id: item.questionId&#125;&#125; 当一个路由被匹配到的时候，他的params的值将在每个组件中以this.$route.params的形式暴露出来。因此，我们可以通过id来传输给打开的组件页面</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tag</span>=<span class="string">&quot;li&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;question&#x27;, params:&#123;id: item.questionId&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-for</span>=<span class="string">&quot;item in questionList&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:key</span>=<span class="string">&quot;item.questionList&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 数据</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">questionList</span>: [</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">questionId</span>: <span class="number">202202</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">title</span>: <span class="string">&#x27;到底什么是es6中的clss（类）？怎么实现class类&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">questionId</span>: <span class="number">202203</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">title</span>: <span class="string">&#x27;到底什么是es6箭头函数？与普通函数主要区别在哪里？到底该不该使用箭头函数&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">questionId</span>: <span class="number">202204</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">title</span>: <span class="string">&#x27;什么是es6的解构赋值，每次都创建一个对象吗？会加重GC的负担吗？为什么&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">      ]</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Question.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      问题:&#123;&#123; question &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取参数id</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> questionId = <span class="built_in">this</span>.$route.params.id;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// findIndex 返回当前值与数据匹配的第一个索引</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> index = <span class="built_in">this</span>.questionList.findIndex(</span></span><br><span class="line"><span class="javascript">      <span class="function">(<span class="params">item</span>) =&gt;</span> item.questionId == questionId</span></span><br><span class="line"><span class="javascript">    );</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 找不到页面时返回-1，则跳转到err（404页面）</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 跳转</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.$router.go(-1);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// replace 替换，[a&gt;b&gt;c&gt;d]四个页面 使用repleace之后，变成了[a&gt;b&gt;c&gt;e]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$router.replace(&#123;<span class="attr">name</span>: <span class="string">&#x27;err&#x27;</span>&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// push 添加，[a&gt;b&gt;c&gt;d]四个页面 使用push之后,变成了[a&gt;b&gt;c&gt;d&gt;e]</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.$router.push(&#123;naem: &#x27;err&#x27;&#125;)</span></span></span><br><span class="line"><span class="javascript">    &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 根据获取的index索引来获取数据中的第index个数据中的title</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.question = <span class="built_in">this</span>.questionList[index].title;</span></span><br><span class="line"><span class="javascript">    &#125; </span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 用来存储每个id的title</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">question</span>: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 数据，模拟网络请求</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">questionList</span>: [</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">questionId</span>: <span class="number">202202</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">title</span>: <span class="string">&quot;到底什么是es6中的clss（类）？怎么实现class类&quot;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">questionId</span>: <span class="number">202203</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">title</span>:</span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;到底什么是es6箭头函数？与普通函数主要区别在哪里？到底该不该使用箭头函数&quot;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">questionId</span>: <span class="number">202204</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">title</span>:</span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;什么是es6的解构赋值，每次都创建一个对象吗？会加重GC的负担吗？为什么&quot;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">      ],</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="router-view复用"><a href="#router-view复用" class="headerlink" title="router-view复用"></a>router-view复用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line"><span class="comment">// 组件可以进行对象管理，默认显示为HomeView组件，如果router-view使用&#x27;academic&#x27;，则使用Academic组件</span></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="attr">default</span>: HomeView,</span><br><span class="line">    <span class="string">&#x27;academic&#x27;</span>: Academic</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 路由视图 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认显示为default --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;router-view&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果属性中添加name，则显示name为academic的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;academic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;router-view&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由重定向和别名"><a href="#路由重定向和别名" class="headerlink" title="路由重定向和别名"></a>路由重定向和别名</h3><ul><li>重定向</li></ul><p>路由重定向也是在<code>router.js</code>中配置的，重定向的目标也可以是一个别名，或者方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="comment">// *除了配置过之外的页面都是*</span></span><br><span class="line"><span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> <span class="comment">// 重定向到/home组件</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>, <span class="comment">// *除了配置过之外的页面都是*</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 方法接收目标路由作为参数</span></span><br><span class="line">    <span class="comment">// return 重定向的字符串路径/路径对象</span></span><br><span class="line">    <span class="function"><span class="title">redirect</span>(<span class="params">to</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(to.path == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;err&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>别名</li></ul><p>重定向是指当用户访问 <code>/home</code> 时，URL 会被 <code>/</code> 替换，然后匹配成 <code>/</code>。那么什么是别名呢？</p><p><strong>将 <code>/</code> 别名为 <code>/home</code>，意味着当用户访问 <code>/home</code> 时，URL 仍然是 <code>/home</code>，但会被匹配为用户正在访问 <code>/</code>。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">     <span class="attr">components</span>: &#123;</span><br><span class="line">     <span class="attr">default</span>: HomeView,</span><br><span class="line">       <span class="attr">academic</span>: Academic,</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// 别名</span></span><br><span class="line">     <span class="attr">alias</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制。使别名以 <code>/</code> 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: UsersLayout,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      <span class="comment">// 为这 3 个 URL 呈现 UserList</span></span><br><span class="line">      <span class="comment">// - /home</span></span><br><span class="line">      <span class="comment">// - /home/list</span></span><br><span class="line">      <span class="comment">// - /people</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: UserList, <span class="attr">alias</span>: [<span class="string">&#x27;/people&#x27;</span>, <span class="string">&#x27;list&#x27;</span>] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果路由有参数，请确保在任何绝对别名中包含他们</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: UsersByIdLayout,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      <span class="comment">// 为这 3 个 URL 呈现 UserDetails</span></span><br><span class="line">      <span class="comment">// - /home/24</span></span><br><span class="line">      <span class="comment">// - /home/24/profile</span></span><br><span class="line">      <span class="comment">// - /24</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;profile&#x27;</span>, <span class="attr">component</span>: UserDetails, <span class="attr">alias</span>: [<span class="string">&#x27;/:id&#x27;</span>, <span class="string">&#x27;&#x27;</span>] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><blockquote><p>导航守卫，<code>vue-router</code>提供的导航首位主要用来通过跳转或取消的方式守卫导航。路由导航有好几种方式，分别为全局所有的、单个路由所有的、单个组件所有的</p></blockquote><h4 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h4><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><p>创建一个全局前置导航守卫</p><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// to: 要到哪里去，即将要进入的目标页面</span></span><br><span class="line">    <span class="comment">// from：从哪里来，当前导航正要离开的路由页面</span></span><br><span class="line">    <span class="comment">// next(): 通过   </span></span><br><span class="line">    <span class="comment">// next(false)不通过,返回false不通过</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断目标路径是否是academic</span></span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">&#x27;/community/academic&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> answer = confirm(<span class="string">&quot;你还没有登陆，要登陆后才能浏览信息，要登陆吗？&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是，则导航name为:personal的路由</span></span><br><span class="line">        <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">            next(&#123; <span class="attr">name</span>: <span class="string">&#x27;personal&#x27;</span> &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回false取消导航</span></span><br><span class="line">            next(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h5 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h5><p><code>router-beforeResolve</code>注册一个全局解析守卫，这和<code>router.beforeEach</code>类似，因为它没导航时都触发，但是确保在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用</strong>。这里有一个例子，确保用户可以访问<a href="https://router.vuejs.org/zh/guide/advanced/meta.html">自定义 meta</a> 属性 <code>requiresCamera</code> 的路由：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeResolve(<span class="keyword">async</span> to =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.meta.requiresCamera) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> askForCameraPermission()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error <span class="keyword">instanceof</span> NotAllowedError) &#123;</span><br><span class="line">        <span class="comment">// ... 处理错误，然后取消导航</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 意料之外的错误，取消导航并把错误传给全局处理器</span></span><br><span class="line">        <span class="keyword">throw</span> error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>router.beforeResolve</code> 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。</p><h5 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h5><p>全局后置钩子，和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  sendToAnalytics(to.fullPath)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。</p><p>它们也反映了 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-failures.html">navigation failures</a> 作为第三个参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, failure</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!failure) sendToAnalytics(to.fullPath)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h4><p>直接在路由配置中配置<code>beforeEnter</code>守卫</p><p><code>beforeEnter</code>守卫只在进入路由时触发，不会在<code>params</code>、<code>query</code>、<code>hash</code>等改变时触发，例如<code>/community/download</code>进入到<code>/community/academic</code>，或<code>/community/personal</code>进入到<code>/community/academic</code>。<code>beforeEnter</code>只会在从一个不同的路由导航时才会触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/community/academic&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;academic&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: Academic,</span><br><span class="line">    <span class="comment">// 2.路由独享守卫</span></span><br><span class="line">    beforeEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 参数和全局守卫一样</span></span><br><span class="line">      <span class="keyword">const</span> answer = confirm(<span class="string">&quot;你还没有登陆，要登陆后才能浏览信息，要登陆吗？&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">      next(&#123; <span class="attr">name</span>: <span class="string">&#x27;personal&#x27;</span> &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>你也可以将一个函数数组传递给 <code>beforeEnter</code>，这在为不同的路由重用守卫时很有用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeQueryParams</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(to.query).length)</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">path</span>: to.path, <span class="attr">query</span>: &#123;&#125;, <span class="attr">hash</span>: to.hash &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHash</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (to.hash) <span class="keyword">return</span> &#123; <span class="attr">path</span>: to.path, <span class="attr">query</span>: to.query, <span class="attr">hash</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: UserDetails,</span><br><span class="line">    <span class="attr">beforeEnter</span>: [removeQueryParams, removeHash],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: UserDetails,</span><br><span class="line">    <span class="attr">beforeEnter</span>: [removeQueryParams],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="组件内守卫"><a href="#组件内守卫" class="headerlink" title="组件内守卫"></a>组件内守卫</h4><p>组件内守卫可用配置API：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Details = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被验证前调用</span></span><br><span class="line">    <span class="comment">// 不能获取组件实例 `this` ！</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行时，组件实例还没被创建！</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在导航离开渲染该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beforeRouteEnter</code>守卫不可以访问<code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建</p><p>可以通过传一个回调给<code>next</code>来访问实例，在被确认的时候执行回调，把组件实例作为参数，或者使用<code>to</code>参数来代替<code>this</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.通过回调next访问实例</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(vm = &#123;</span><br><span class="line">  <span class="comment">// 通过vm访问组件实例 </span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过to访问实例</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">const</span> Flag = to.matched[<span class="number">0</span>].meta.login;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<em>不支持</em> 传递回调，因为没有必要了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">  <span class="comment">// just use `this`</span></span><br><span class="line">  <span class="built_in">this</span>.name = to.params.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <strong>离开守卫</strong> 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 <code>false</code> 来取消。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, form, next) &#123;</span><br><span class="line">    <span class="keyword">const</span> answer = confirm(<span class="string">&quot;确定要离开吗&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h4 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h4><p>有时候我们希望把一些信息附加到路由上，方便路由之间调用，如登陆信息，过渡名称，这些事情可以通过接受路由属性对象的<code>meta</code>属性来实现，并且它可以在路由地址和导航守卫上都可以被访问到。定义路由时也可以配置<code>meta</code>字段</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/posts&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: PostsLayout,</span><br><span class="line"><span class="comment">// 只有经过身份验证的用户才能创建帖子</span></span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: PostsNew,</span><br><span class="line">       </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;:id&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: PostsDetail</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么如何访问这个 <code>meta</code> 字段呢？</p><p>首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 <strong>路由记录</strong>。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。</p><p>例如，根据上面的路由配置，<code>/posts/new</code> 这个 URL 将会匹配父路由记录 (<code>path: &#39;/posts&#39;</code>) 以及子路由记录 (<code>path: &#39;new&#39;</code>)。</p><p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象(还有在导航守卫中的路由对象)的<code>$route.matched</code> 数组。我们需要遍历这个数组来检查路由记录中的 <code>meta</code> 字段，但是 Vue Router 还为你提供了一个 <code>$route.meta</code> 方法，它是一个非递归合并<strong>所有 <code>meta</code></strong> 字段的（从父字段到子字段）的方法。这意味着你可以简单地写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 而不是去检查每条路由记录</span></span><br><span class="line">  <span class="comment">// to.matched.some(record =&gt; record.meta.requiresAuth)</span></span><br><span class="line">  <span class="keyword">if</span> (to.meta.requiresAuth &amp;&amp; !auth.isLoggedIn()) &#123;</span><br><span class="line">    <span class="comment">// 此路由需要授权，请检查是否已登录</span></span><br><span class="line">    <span class="comment">// 如果没有，则重定向到登录页面</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      <span class="comment">// 保存我们所在的位置，以便以后再来</span></span><br><span class="line">      <span class="attr">query</span>: &#123; <span class="attr">redirect</span>: to.fullPath &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</p><p>我们平时加载路由习惯用<code>import</code>加载页面了，但是这会让浏览器一股脑全加载进来，不会按需加载，所以就需要路由懒加载，把<code>import</code>放入到函数中去，访问到函数时在进行<code>import</code>加载</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将这样引入 </span></span><br><span class="line"><span class="comment">// import HomeView from &quot;../views/HomeView.vue&quot;;</span></span><br><span class="line"><span class="comment">// 替换为</span></span><br><span class="line"><span class="keyword">const</span> HomeView = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/HomeView.vue&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="非父子组件传值"><a href="#非父子组件传值" class="headerlink" title="非父子组件传值"></a>非父子组件传值</h2><p>我们很多时候会遇到非父子组件传值的情况，如兄弟组件要传值，这时有几种方法来解决：</p><ol><li>通过点击事件进行传递：子组件($emit触发事件) — 父组件 —props — 子组件</li><li>通过总线/Bus/发布订阅模式/观察者模式来解决</li><li>通过Vue官方提供的数据框架—vuex，安装方法：vue add vuex</li></ol><h3 id="点击事件传递"><a href="#点击事件传递" class="headerlink" title="点击事件传递"></a>点击事件传递</h3><p>子组件一</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    添加学生：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>确认添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">      data () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        add () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 通过v-model来双向绑定数据，然后使用$emit来传值给父组件</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&#x27;add&#x27;</span>, <span class="built_in">this</span>.name);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 学员展示 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用add方法来获取参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add-student</span> @<span class="attr">add</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">add-student</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 把studentList数组绑定studentList组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student-list</span> <span class="attr">:student-list</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">student-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> AddStudent <span class="keyword">from</span> <span class="string">&quot;@/components/student/AddStudent&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> StudentList <span class="keyword">from</span> <span class="string">&quot;@/components/student/StudentList&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    AddStudent,</span></span><br><span class="line"><span class="javascript">    StudentList</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 先声明参数数组，进行存放</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">studentList</span>: [],</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// add方法，如果点击则存放参数数组</span></span></span><br><span class="line"><span class="javascript">    add (name) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.studentList.push(name);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件二</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    学生列表</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in studentList&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">&quot;index+item&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// vuex  vue add vuex</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// props获取数据</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">props</span>: [<span class="string">&#x27;student-list&#x27;</span>],</span></span><br><span class="line"><span class="javascript">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">studentList</span>: []</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总线-Bus-发布订阅模式-观察者模式传递"><a href="#总线-Bus-发布订阅模式-观察者模式传递" class="headerlink" title="总线/Bus/发布订阅模式/观察者模式传递"></a>总线/Bus/发布订阅模式/观察者模式传递</h3><p>通过<code>bus</code>来传值就不用给父级传值再传值给子级了</p><p>main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Bus原型来进行传值</span></span><br><span class="line"><span class="comment">// 在Vue 的 prototype上挂载了一个bus的属性，该 bus 属性指向一个 Vue 的实例。在之后，只要调用 new.Vue 或者创建组件时，每个组件上都会有 bus 这个属性（为什么？因为每个Vue实例和组件都是通过 Vue 这个类进行创建，而在Vue的 prototype 挂载一个 bus 的属性，都指向同一个 Vue 的实例）</span></span><br><span class="line">Vue.prototype.bus = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>组件1</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    添加学生：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>确认添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    add () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过bus来进行传递事件，和参数</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.bus 指的就是 Vue.prototype.bus = new Vue () 上挂载的 bus ，同时 bus 作为Vue实例，有其方法，这里为 $emit ,以此 向外触发事件并同时 携带要传递的 内容数据</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.bus.$emit(<span class="string">&#x27;add&#x27;</span>, <span class="built_in">this</span>.name);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件2</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    学生列表</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in studentList&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">&quot;index+item&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// vuex  vue add vuex</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// props: [&#x27;student-list&#x27;],</span></span></span><br><span class="line"><span class="javascript">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">studentList</span>: []</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 借助生命周期钩子来监听</span></span></span><br><span class="line"><span class="javascript">  created () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 向外触发事件之后，其他组件将通过 监听 的方式接收数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.bus.$on(<span class="string">&quot;add&quot;</span>, <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.studentList.push(name);</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>安装：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/path/to/vuex.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">vue add <span class="string">&#x27;vuex&#x27;</span> || npm install vuex@next --save</span><br></pre></td></tr></table></figure><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p><ol><li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li><li><p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p></li></ol><h3 id="创建一个store"><a href="#创建一个store" class="headerlink" title="创建一个store"></a>创建一个store</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="comment">// 公共数据池</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;shan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">look</span>: <span class="string">&#x27;beautiful&#x27;</span>,</span><br><span class="line">    <span class="attr">studentList</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>Vuex使用单一状态数树，用一个对象就包含了全部的应用层级状态，意味和他是一个唯一数据源，每一个应用仅仅包含一个store实例</p><p>怎么再Vue组件中获得State呢，Vuex通过Vue将store从根组件中注入到所有的子组件中，子组件可以通过<code>this.$store</code>访问到</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>确认添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      add () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 执行函数时更改store中state里面的studnetList数组</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$store.state.studentList.push(<span class="built_in">this</span>.name);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="comment">// 访问store中state的数据</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当我们使用的状态多的时候，都使用computed声明会非常的重复和冗余，如：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    添加学生：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>确认添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">      data () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 将状态值都声明为了computed，这样会非常的冗余，而且每一个组件中使用的话还需要再复制一份，这样很麻烦</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">computed</span>:&#123;</span></span><br><span class="line"><span class="javascript">        storeName () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.name;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        storeAge () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.age;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">storeLook</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.look;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        add () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$store.state.studentList.push(<span class="built_in">this</span>.name);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>像上面的代码，把状态都声明成computed，看起来很不好，而且用起来很麻烦，所以就有了mapState方法</strong></p><p><strong>mapState</strong>辅助函数</p><ul><li><p>返回值是一个对象，对象中有一些<code>key</code>和<code>value</code>，<code>key</code>的<code>value</code>都是函数 </p></li><li><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// mapState([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;look&#x27;]),</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">      <span class="comment">// 为什么要加入...展开符，因为mapState返回的是一个对象，如果不展开是访问不到的，所以需要用...来展开mapState对象，混入computed对象</span></span><br><span class="line">      ...mapState(&#123;</span><br><span class="line">          <span class="comment">// 通过箭头函数访问</span></span><br><span class="line">          <span class="attr">name</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.name,</span><br><span class="line">          <span class="comment">// 传入字符串 &#x27;name&#x27; 就相当于 state =&gt; state.name</span></span><br><span class="line">          <span class="attr">nameAlias</span>: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">          <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">          namePlusLocalState (state) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.name + <span class="built_in">this</span>.localName</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    mapState([</span><br><span class="line">      <span class="comment">// 映射 this.name 为 store.state.name</span></span><br><span class="line">      <span class="string">&#x27;name&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p><code>getters</code>相当于vue中的计算属性，通过一些操作将<code>state</code>中的值过滤并计数，<code>getters</code>就是<code>store</code>自己的计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">studentList</span>: [<span class="string">&quot;shen&quot;</span>,<span class="string">&quot;hao&quot;</span>,<span class="string">&quot;zhe&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="comment">// 相当于计算属性，通过数据池中进行更改得到一个新的值</span></span><br><span class="line">    <span class="comment">// Getter第一个参数就是state，第二个参数就是自己，方便自己调用自身的函数</span></span><br><span class="line">    newStudent (state, getters) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.studentList.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;**&#x27;</span> + item + getters.acorn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> item + <span class="string">&#x27;**&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;++&quot;</span> + item + <span class="string">&quot;++&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    acorn () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;1111&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>mapGetters辅助函数</strong></p><ul><li><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，就和<code>mapState</code>一样</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">        ...mapGetters(&#123;</span><br><span class="line">          <span class="attr">student</span>: <span class="string">&#x27;newStudent&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// ...mapGetters([&#x27;newStudent&#x27;]),</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的**事件类型 (type)**和一个**回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，同时也可以传入额外的参数，第二个参数用对象来传入，这样可以包含多个参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">studentList</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// store中只有mutations中才可以更改state里面的值</span></span><br><span class="line">    changeStudent (state, &#123; name, number &#125;) &#123;</span><br><span class="line">      state.studentList.push(name + number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>提交方式</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 提交方式使用commit来提交mutation函数，并且需要加入函数和其的参数</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;changeStudent&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;lll&#x27;</span>, <span class="attr">number</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提交 mutation 的另一种方式是直接使用包含 type 属性的对象</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;changeStudent&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;lll&#x27;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="number">10</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 我们提交的时候也可以使用mapAction来提交</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...mapMutation(&#123;</span><br><span class="line">      <span class="attr">changeStudent</span>: <span class="string">&#x27;changeStudent&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">      </span><br><span class="line">    ...mapMutation([</span><br><span class="line">      <span class="string">&#x27;changeStudent&#x27;</span>,</span><br><span class="line">    ]),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;button @click=&quot;changeStudent(&#123; name, number: 1 &#125;)&quot;&gt;确认添加&lt;/button&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Mutation中必须是同步函数，不可以是异步函数</strong>：具体可见<a href="https://vuex.vuejs.org/zh/guide/mutations.html#mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0">详情</a></p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Mutation不可以进行异步函数的执行，那么就可以使用Action来提交Mutation，不是变更状态，是提交Mutation</p><p>Action可以包含任何异步操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">studentList</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    changeStudent (state, &#123; name, number &#125;) &#123;</span><br><span class="line">      state.studentList.push(name + number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">// 执行异步操作</span></span><br><span class="line">    changeStudent (context, &#123; name, number &#125;) &#123;</span><br><span class="line">      <span class="comment">// context看作是一个上下文对象，是与store实例具有相同方法和属性的对象，但不是store对象</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 然后使用context.commit提交一个mutation</span></span><br><span class="line">        context.commit(<span class="string">&quot;changeStudent&quot;</span>, &#123; </span><br><span class="line">            name, number </span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>提交Action方法</strong></p><p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 <strong>mutation 必须同步执行</strong>这个限制么？Action 就不受约束！我们可以在 action 内部执行<strong>异步</strong>操作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 提交方式使用dispath来提交mutation函数，并且需要加入函数和其的参数</span></span><br><span class="line">store.dispatch(<span class="string">&#x27;changeStudent&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;changeStudent&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lll&#x27;</span></span><br><span class="line">  <span class="attr">number</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用mapActions分发</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      <span class="attr">changeStudent</span>: <span class="string">&#x27;changeStudent&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;button @click=&quot;changeStudent(&#123; name, number: 1 &#125;)&quot;&gt;确认添加&lt;/button&gt;</span></span><br></pre></td></tr></table></figure><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// &#123;&#123;commit&#125;&#125; 使用ES2015中的方法解构</span></span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">      </span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;someOtherMutation&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用多个组合<code>actions</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用async / await进入组合</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;gotData&#x27;</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">&#x27;gotOtherData&#x27;</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><h4 id="模块局部状态"><a href="#模块局部状态" class="headerlink" title="模块局部状态"></a>模块局部状态</h4><p>我们平时使用Store时，把所有的数据放进去会集中到一个比较大的对象，当应用逐渐增大的时候，store对象就会变得十分的臃肿</p><p>为了解决这些问题，Vue可以将store分割成一个一个的模块（module）。每个模块都拥有着自己的state、mutation、action、getter和嵌套字模块</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// 命名空间</span></span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; </span><br><span class="line"><span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line"><span class="comment">// 对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">// 再开启命名空间后，getter中的getters就别局部化了，可以使用第四个参数来调用rootGetters</span></span><br><span class="line">incrementIfOddOnRootSum (&#123; state, commit, rootState, rootGetters &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; </span><br><span class="line">    <span class="comment">// 对于模块内部的 getter，根节点rootState状态会作为第三个参数暴露出来</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 再开启命名空间后</span></span><br><span class="line">    <span class="comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span></span><br><span class="line">    <span class="comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span></span><br><span class="line">  sumWithRootCount (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>默认情况下，模块内部的 action 和 mutation 仍然是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。Getter 同样也默认注册在全局命名空间，但是目前这并非出于功能上的目的（仅仅是维持现状来避免非兼容性变更）。必须注意，不要在不同的、无命名空间的模块中定义两个相同的 getter 从而导致错误。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">account</span>: &#123;</span><br><span class="line">      <span class="comment">// 命名空间</span></span><br><span class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;), <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      <span class="attr">getters</span>: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">actions</span>: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">mutations</span>: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      <span class="attr">modules</span>: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        <span class="attr">myPage</span>: &#123;</span><br><span class="line">          <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">          <span class="attr">getters</span>: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/profile&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        <span class="attr">posts</span>: &#123;</span><br><span class="line">          <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">          <span class="attr">getters</span>: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p><p><strong>再开启命名空间的模块中注册全局action</strong></p><p>可以添加<code>root:true</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    someOtherAction (&#123;dispatch&#125;) &#123;</span><br><span class="line">      dispatch(<span class="string">&#x27;someAction&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="attr">someAction</span>: &#123;</span><br><span class="line">          <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">          handler (namespacedContext, payload) &#123; ... &#125; <span class="comment">// -&gt; &#x27;someAction&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么在组件中使用带有命名空间独立的模块，将模块的名称作为第一个字符串传递给<code>mapStatte</code>等参数，这样就会访问到该模块了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">&#x27;模块名&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    <span class="attr">b</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...mapActions(<span class="string">&#x27;模块名&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;foo&#x27;</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">&#x27;bar&#x27;</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...mapState(&#x27;course&#x27;, [&#x27;courseList&#x27;])</span></span><br></pre></td></tr></table></figure><p>也可以使用<code>createNamespacedHelpers</code>中创建某个命名空间的模块，返回的是一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">&#x27;some/nested/module&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      <span class="attr">b</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h4><p>在 store 创建<strong>之后</strong>，你可以使用 <code>store.registerModule</code> 方法注册模块：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123; <span class="comment">/* 选项 */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">&#x27;myModule&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">&#x27;nested&#x27;</span>, <span class="string">&#x27;myModule&#x27;</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p><p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<a href="https://github.com/vuejs/vuex-router-sync"><code>vuex-router-sync</code></a> 插件就是通过动态注册模块将 Vue Router 和 Vuex 结合在一起，实现应用的路由状态管理。</p><p>你也可以使用 <code>store.unregisterModule(moduleName)</code> 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p><p>注意，你可以通过 <code>store.hasModule(moduleName)</code> 方法检查该模块是否已经被注册到 store。需要记住的是，嵌套模块应该以数组形式传递给 <code>registerModule</code> 和 <code>hasModule</code>，而不是以路径字符串的形式传递给 module。</p><h4 id="保留-state"><a href="#保留-state" class="headerlink" title="保留 state"></a>保留 state</h4><p><a href="https://vuex.vuejs.org/zh/guide/modules.html#%E4%BF%9D%E7%95%99-state">保留-state</a></p><p>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 <code>preserveState</code> 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, &#123; preserveState: true &#125;)</code>。</p><p>当你设置 <code>preserveState: true</code> 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;h2 id=&quot;前导&quot;&gt;&lt;a href=&quot;#前导&quot; class=&quot;headerlink&quot; title=&quot;前导&quot;&gt;&lt;/a&gt;前导&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="Vue" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-03T10:24:00.000Z</published>
    <updated>2022-05-17T01:12:47.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-观察者模式"><a href="#设计模式-观察者模式" class="headerlink" title="设计模式-观察者模式"></a>设计模式-观察者模式</h1><ul><li>观察者模式，定义对象的一种一对多的依赖关系，当一个对象的状态发生比改变时，所有依赖于它的对象都将得到通知。事实上，只要你曾经在<code>DOM</code>节点上绑定过事件函数，那么你就曾经使用过观察者模式了！</li></ul><span id="more"></span><p>事件方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Event</span></span><br><span class="line"><span class="comment">// 1. Event on emmit remove once</span></span><br><span class="line"><span class="comment">// 2. 有助于观察者模式</span></span><br><span class="line"><span class="comment">// 3. node模块中经常会使用到 fs http</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Event</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储不同事件类型中对应的不同处理函数</span></span><br><span class="line">    <span class="built_in">this</span>.cache = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.cache[type]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache[type] = [handle];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache[type].push(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.emmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//arguments</span></span><br><span class="line">    <span class="keyword">var</span> type = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> arg = [].splice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="built_in">this</span>.cache[type].length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache[i].apply(<span class="built_in">this</span>,arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cache[type] = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">type,handle</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cache[type] = <span class="built_in">this</span>.cache[type].filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(ele == handlea)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>飞机应用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Event</span></span><br><span class="line"><span class="comment">// 1. Event on emmit remove once</span></span><br><span class="line"><span class="comment">// 2. 有助于观察者模式</span></span><br><span class="line"><span class="comment">// 3. node模块中经常会使用到 fs http</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Event</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储不同事件类型中对应的不同处理函数</span></span><br><span class="line">    <span class="built_in">this</span>.cache = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.cache[type]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache[type] = [handle];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache[type].push(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.emmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//arguments</span></span><br><span class="line">    <span class="keyword">var</span> type = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> arg = [].splice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="built_in">this</span>.cache[type].length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache[s][i].apply(<span class="built_in">this</span>,arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cache[type] = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Event.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">type,handle</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cache[type] = <span class="built_in">this</span>.cache[type].filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(ele == handlea)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法模式</span></span><br><span class="line">PlaneFactory.prototype = <span class="keyword">new</span> Event();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlaneFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 资源装饰池池</span></span><br><span class="line">    <span class="built_in">this</span>.decorate_list = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合所有装饰方法</span></span><br><span class="line">PlaneFactory.prototype.decorators = &#123;</span><br><span class="line">    <span class="attr">eatOneLife</span>: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj.blood += <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">eatTwoLife</span>: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj.blood += <span class="number">200</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">eatShrinkLife</span>: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj.blood -= <span class="number">50</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 装饰方法</span></span><br><span class="line"><span class="comment">// 搜集对某对象的装饰描述</span></span><br><span class="line">PlaneFactory.prototype.decorate = <span class="function"><span class="keyword">function</span> (<span class="params">decorator</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this.decorate_list_self =</span></span><br><span class="line">    <span class="built_in">this</span>.decorate_list.push(decorator);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让装饰方法作用在该对象的身上</span></span><br><span class="line">PlaneFactory.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.decorate_list.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.decorators[<span class="built_in">this</span>.decorate_list[i]] &amp;&amp; <span class="built_in">this</span>.decorators[<span class="built_in">this</span>.decorate_list[i]](<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空装饰池</span></span><br><span class="line">PlaneFactory.prototype.empty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.decorate_list = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某个装饰</span></span><br><span class="line">PlaneFactory.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.decorate_list = <span class="built_in">this</span>.decorate.list.filter(<span class="function"><span class="keyword">function</span> (<span class="params">eleType, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(eleType == type);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂都可以使用的公共方法</span></span><br><span class="line">PlaneFactory.prototype.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.die();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">PlaneFactory.prototype.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;boomb&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建对象的接口</span></span><br><span class="line">PlaneFactory.create = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判定是否存在该类型的子类工厂</span></span><br><span class="line">    <span class="keyword">if</span> (PlaneFactory.prototype[type] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;no this constructor&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承</span></span><br><span class="line">    <span class="comment">// 判定PlaneFactory中该类型的子类工厂是否已经继承</span></span><br><span class="line">    <span class="keyword">if</span> (PlaneFactory.prototype[type].prototype.__proto__ != PlaneFactory.prototype) &#123;</span><br><span class="line">        PlaneFactory.prototype[type].prototype = <span class="keyword">new</span> PlaneFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坐标参数</span></span><br><span class="line">    <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// arg =&gt; [10,20]</span></span><br><span class="line">    <span class="keyword">var</span> newPlane = <span class="keyword">new</span> PlaneFactory.prototype[type](...arg);</span><br><span class="line">    <span class="keyword">return</span> newPlane;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 真正定义子类工厂</span></span><br><span class="line">PlaneFactory.prototype.SmallPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;smallPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">PlaneFactory.prototype.BigPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;BigPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line">PlaneFactory.prototype.AttackPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">125</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;AttackPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.attack = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;biu~ biu~ biu~&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oAp = PlaneFactory.create(<span class="string">&#x27;AttackPlane&#x27;</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> oSp = PlaneFactory.create(<span class="string">&#x27;SmallPlane&#x27;</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> oBp = PlaneFactory.create(<span class="string">&#x27;BigPlane&#x27;</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰者模式</span></span><br><span class="line">oAp.decorate(<span class="string">&#x27;eatOneLife&#x27;</span>);</span><br><span class="line">oAp.decorate(<span class="string">&#x27;eatTwoLife&#x27;</span>);</span><br><span class="line">oAp.update();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给oAp添加over事件方法</span></span><br><span class="line">oAp.on(<span class="string">&#x27;over&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.die();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行oAp绑定的over事件方法</span></span><br><span class="line">oAp.emmit(<span class="string">&quot;over&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式-观察者模式&quot;&gt;&lt;a href=&quot;#设计模式-观察者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-观察者模式&quot;&gt;&lt;/a&gt;设计模式-观察者模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;观察者模式，定义对象的一种一对多的依赖关系，当一个对象的状态发生比改变时，所有依赖于它的对象都将得到通知。事实上，只要你曾经在&lt;code&gt;DOM&lt;/code&gt;节点上绑定过事件函数，那么你就曾经使用过观察者模式了！&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰者模式</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-01T11:32:39.000Z</published>
    <updated>2022-05-17T01:12:47.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><ul><li>定义<ul><li>在不改变元对象的基础上，通过对其进行包装拓展（添加属性方法）</li></ul></li><li>装饰者（<strong>decorator</strong>）模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。可以当脚本运行时，在子类中增加行为会影响原有类所有的实例，给不同对象各自添加新行为和属性</li><li>实现：构造函数需要一个装饰资源池，提供相应的装饰方法，提供添加装饰方法的方法</li></ul><span id="more"></span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂方法模式 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlaneFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 资源装饰池池</span></span><br><span class="line">    <span class="built_in">this</span>.decorate_list = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合所有装饰方法</span></span><br><span class="line">PlaneFactory.prototype.decorators = &#123;</span><br><span class="line">    <span class="attr">eatOneLife</span>: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj.blood += <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">eatTwoLife</span>: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj.blood += <span class="number">200</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">eatShrinkLife</span>: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj.blood -= <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰方法</span></span><br><span class="line"><span class="comment">// 搜集对某对象的装饰描述</span></span><br><span class="line">PlaneFactory.prototype.decorate = <span class="function"><span class="keyword">function</span> (<span class="params">decorator</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this.decorate_list_self =  </span></span><br><span class="line">    <span class="built_in">this</span>.decorate_list.push(decorator); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让装饰方法作用在该对象的身上</span></span><br><span class="line">PlaneFactory.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.decorate_list.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.decorators[<span class="built_in">this</span>.decorate_list[i]] &amp;&amp; <span class="built_in">this</span>.decorators[<span class="built_in">this</span>.decorate_list[i]](<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空装饰池</span></span><br><span class="line">PlaneFactory.prototype.empty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.decorate_list = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某个装饰</span></span><br><span class="line">PlaneFactory.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.decorate_list = <span class="built_in">this</span>.decorate.list.filter(<span class="function"><span class="keyword">function</span> (<span class="params">eleType,index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(eleType == type);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂都可以使用的公共方法</span></span><br><span class="line">PlaneFactory.prototype.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.die();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PlaneFactory.prototype.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;boomb&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象的接口</span></span><br><span class="line">PlaneFactory.create = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判定是否存在该类型的子类工厂</span></span><br><span class="line">    <span class="keyword">if</span>(PlaneFactory.prototype[type] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;no this constructor&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承</span></span><br><span class="line">    <span class="comment">// 判定PlaneFactory中该类型的子类工厂是否已经继承</span></span><br><span class="line">    <span class="keyword">if</span>(PlaneFactory.prototype[type].prototype.__proto__ != PlaneFactory.prototype) &#123;</span><br><span class="line">        PlaneFactory.prototype[type].prototype = <span class="keyword">new</span> PlaneFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坐标参数</span></span><br><span class="line">    <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// arg =&gt; [10,20]</span></span><br><span class="line">    <span class="keyword">var</span> newPlane = <span class="keyword">new</span> PlaneFactory.prototype[type](...arg);</span><br><span class="line">    <span class="keyword">return</span> newPlane;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正定义子类工厂</span></span><br><span class="line">PlaneFactory.prototype.SmallPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;smallPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">PlaneFactory.prototype.BigPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;BigPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">PlaneFactory.prototype.AttackPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">125</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;AttackPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.attack = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;biu~ biu~ biu~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oAp = PlaneFactory.create(<span class="string">&quot;AttackPlane&quot;</span>,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> oSp = PlaneFactory.create(<span class="string">&quot;SmallPlane&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> oBp = PlaneFactory.create(<span class="string">&quot;BigPlane&quot;</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰者模式</span></span><br><span class="line">oAp.decorate(<span class="string">&quot;eatOneLife&quot;</span>); <span class="comment">// blood+100</span></span><br><span class="line">oAp.decorate(<span class="string">&quot;eatTwoLife&quot;</span>); <span class="comment">// blood+200</span></span><br><span class="line">oAp.update(); <span class="comment">//将装饰方法成功作用于oAp</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式&quot;&gt;&lt;/a&gt;装饰者模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定义&lt;ul&gt;
&lt;li&gt;在不改变元对象的基础上，通过对其进行包装拓展（添加属性方法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;装饰者（&lt;strong&gt;decorator&lt;/strong&gt;）模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。可以当脚本运行时，在子类中增加行为会影响原有类所有的实例，给不同对象各自添加新行为和属性&lt;/li&gt;
&lt;li&gt;实现：构造函数需要一个装饰资源池，提供相应的装饰方法，提供添加装饰方法的方法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2022/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2022/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-01T07:49:12.000Z</published>
    <updated>2022-05-17T01:12:47.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><ul><li>定义<ul><li>工厂模式定义创建对象的接口，但是让子类去真正的实例化。也就是工厂方法将类的实例化延迟到子类    </li></ul></li></ul><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul><li>工厂类集中了所有对象的创建，便于对象创建的统一管理</li><li>对象的使用者仅仅是使用产品，实现了单一职责</li><li>便于拓展，如果新增了一种业务，只需要增加相关的业务对象类和工厂类中的生产业务对象的方法，不需要修改其他的地方</li><li>确实违反了开闭原则</li></ul><span id="more"></span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始模式</span></span><br><span class="line"><span class="comment">// 如果想要各种类型的飞机的话，只能一个一个的复制，这样会很笨拙</span></span><br><span class="line"><span class="keyword">var</span> plane = &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">blood</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">touch</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;die&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 使用构造函数也是可以进行声明飞机，但是也要一个一个复制声明不同类型飞机</span></span><br><span class="line"><span class="comment">// 也可以创造一个父类Plane，子类继承父类，然后子类往父类身上加属性，使用继承来完善</span></span><br><span class="line"><span class="comment">// function BigPlane() &#123;&#125; </span></span><br><span class="line"><span class="comment">// function SmallPlane() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmallPlane</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;smallPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.blood -= <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;die&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BigPlane</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;BigPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;die&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AttackPlane</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;BigPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;die&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.attack = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;attack&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类模式 </span></span><br><span class="line"><span class="comment">// 工厂类仅仅是集中了对象的创建，该对象的功能还是要该对象自己实现，同时也违反了开闭原则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlaneFactory</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newPlane = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;SmallPlane&quot;</span>:</span><br><span class="line">            newPlane = <span class="keyword">new</span> SmallPlane();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;BigPlane&quot;</span>:</span><br><span class="line">            newPlane = <span class="keyword">new</span> BigPlane();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newPlane.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;boomb&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newPlane;</span><br><span class="line">&#125;</span><br><span class="line">PlaneFactory(<span class="string">&quot;SmallPlane&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul><li><p>不再有一个唯一的工厂类就创建产品，而是将不同的产品交给对应的工厂子类去实现。每个产品由负责生产的子工厂来创造。如果添加新的产品，需要做的是添加新的子工厂和产品，而不需要修改其他的工厂代码</p></li><li><p>工厂方法模式组成：</p><ul><li>抽象工厂类：负责定义创建产品的公共接口</li><li>产品子工厂：继承抽象工厂类，实现抽象工厂类提供的接口</li><li>每一种产品都用每一种产品的类</li></ul></li><li><p>代码比简单工厂模式复杂了，引入了抽象层，还有子工厂，这回增加代码的复杂度和理解难度。但是相比于简单工厂模式，代码的维护性和拓展性提高了，新增产品时，只需要增加对应的产品类和产品工厂类，不需要修改到抽象工厂类和其他子工厂。更加符合面向对象的开放封闭原则</p></li><li><p>具体场景具体分析，复杂性和拓展性相比如何舍去，在使用时要结合实际场景去分析</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂方法模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlaneFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类工厂都可以使用的公共方法</span></span><br><span class="line">PlaneFactory.prototype.touch = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.die()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PlaneFactory.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;boomb&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象的接口</span></span><br><span class="line">PlaneFactory.create = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判定是否存在该类型的子类工厂</span></span><br><span class="line">    <span class="keyword">if</span>(PlaneFactory.prototype[type] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;no this constructor&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承</span></span><br><span class="line">    <span class="comment">// 判定PlaneFactory中该类型的子类工厂是否已经继承</span></span><br><span class="line">    <span class="keyword">if</span>(PlaneFactory.prototype[type].prototype.__proto__ != PlaneFactory.prototype) &#123;</span><br><span class="line">        PlaneFactory.prototype[type].prototype = <span class="keyword">new</span> PlaneFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 坐标参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [].splice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// args =&gt; [10,20]，...args =&gt; 10,20</span></span><br><span class="line">    <span class="keyword">var</span> newPlane = <span class="keyword">new</span> PlaneFactory.prototype[type](...args);</span><br><span class="line">    <span class="keyword">return</span> newPlane;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正定义子类工厂</span></span><br><span class="line">PlaneFactory.prototype.SmallPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;smallPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">PlaneFactory.prototype.BigPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;BigPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">PlaneFactory.prototype.AttackPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">125</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;AttackPlane&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.blood = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">this</span>.attack = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;biu~ biu~ biu~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> oAp = PlaneFactory.create(<span class="string">&quot;AttackPlane&quot;</span>,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> oSp = PlaneFactory.create(<span class="string">&quot;SmallPlane&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> oBp = PlaneFactory.create(<span class="string">&quot;BigPlane&quot;</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定义&lt;ul&gt;
&lt;li&gt;工厂模式定义创建对象的接口，但是让子类去真正的实例化。也就是工厂方法将类的实例化延迟到子类    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简单工厂模式&quot;&gt;&lt;a href=&quot;#简单工厂模式&quot; class=&quot;headerlink&quot; title=&quot;简单工厂模式&quot;&gt;&lt;/a&gt;简单工厂模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工厂类集中了所有对象的创建，便于对象创建的统一管理&lt;/li&gt;
&lt;li&gt;对象的使用者仅仅是使用产品，实现了单一职责&lt;/li&gt;
&lt;li&gt;便于拓展，如果新增了一种业务，只需要增加相关的业务对象类和工厂类中的生产业务对象的方法，不需要修改其他的地方&lt;/li&gt;
&lt;li&gt;确实违反了开闭原则&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/12/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/12/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-29T08:48:33.000Z</published>
    <updated>2022-05-17T01:12:47.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-代理模式"><a href="#设计模式-代理模式" class="headerlink" title="设计模式-代理模式"></a>设计模式-代理模式</h1><ul><li>定义：为一个对象提供一种代理以控制对这个对象的访问</li><li>代理对象起到类似中介的作用，会增加一些功能（如，校验，合并等等），也会去掉一些原有对象的功能</li></ul><p>代理示范</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子 给女神送花</span></span><br><span class="line"><span class="comment">// 有一个人，有一个送花的功能，要给女神target送花</span></span><br><span class="line"><span class="keyword">var</span> mrPerson = &#123;</span><br><span class="line">    <span class="attr">sendFlower</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 送的什么花呢？向日葵</span></span><br><span class="line">        <span class="keyword">var</span> Flower = <span class="string">&#x27;sunFlower&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后女神开始考虑接不接受送的花</span></span><br><span class="line">        target.receiveFlower(Flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女神呢，要有一个接受花的功能，同时还有一个心情的好坏，心情好的话就接受了，心情不好的话就拒绝了，那就要有一个改变心情的功能</span></span><br><span class="line"><span class="keyword">var</span> goddess = &#123;</span><br><span class="line">    <span class="comment">// 女神的心情</span></span><br><span class="line">    <span class="attr">mood</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 女神考虑接不接受送的花</span></span><br><span class="line">    <span class="attr">receiveFlower</span>: <span class="function"><span class="keyword">function</span> (<span class="params">flower</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// true 心情好</span></span><br><span class="line">        <span class="comment">// false 心情不好</span></span><br><span class="line">        <span class="comment">// 如果是好的话就ok了，我接受了，否则就get out了</span></span><br><span class="line">        <span class="built_in">this</span>.mood ? <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>) : <span class="built_in">console</span>.log(<span class="string">&quot;get out&quot;</span>);;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变女神心情，如果随机数大于0.5就是true，心情好</span></span><br><span class="line">    <span class="attr">changeMood</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mood = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>;</span><br><span class="line">        <span class="comment">// console.log(this.mood);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//切换心情</span></span><br><span class="line">    <span class="attr">createMood</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 女神一开始要有一个心情，否则就是null</span></span><br><span class="line">        self.changeMood();</span><br><span class="line">        <span class="comment">// 然后每隔400毫秒改变一次心情</span></span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.changeMood();</span><br><span class="line">        &#125;,<span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 女神一开始就要切换心情了</span></span><br><span class="line">goddess.createMood();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写完之后，有一个问题，我们的功能不能时好时坏呀，也不有看心情来触发啊，我们同时也要保证绝对的可行性，这个时候就要添加一个代理，来控制送花的人的访问</span></span><br><span class="line"><span class="comment">// 添加一个代理代理</span></span><br><span class="line"><span class="keyword">var</span> addProxy = &#123;</span><br><span class="line">    <span class="attr">proxyFlower</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// mrPerson.sendFlower(target);</span></span><br><span class="line">        <span class="built_in">this</span>.listenMood(target,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            mrPerson.sendFlower(target);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果直接调用proxyFlower的话那么和没有代理也没有区别了，这时，就需要来判断女神的心情来考虑把花给送到女神手中，来确保成功率</span></span><br><span class="line">    <span class="attr">listenMood</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target,callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 代理每隔300毫秒去看看女神心情好不好，然后决定送不送花</span></span><br><span class="line">        <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果心情好的话就帮人给女神送花了</span></span><br><span class="line">            <span class="keyword">if</span>(target.mood) &#123;</span><br><span class="line">                callback();</span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">300</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后某一人开始给给女神送花</span></span><br><span class="line"><span class="comment">// mrPerson.sendFlower(goddess);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托代理给女神送花</span></span><br><span class="line">addProxy.proxyFlower(goddess);</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><ul><li>虚拟代理是把一些开销很大的对象，延迟到真正需要它的时候才去创建执行</li><li>常用功能：图片懒加载、文件上传</li></ul><p>单个图片懒加载</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 预加载 -&gt; https://pic2.zhimg.com/v2-3b4fc7e3a1195a081d0259246c38debc_720w.jpg?source=172ae18b</span></span><br><span class="line"><span class="comment">// 首先要在计算机性能较好的时候，先发送一次，之后再用就是取缓存了</span></span><br><span class="line"><span class="comment">// 2. 懒加载 -&gt; 监控真正要展示的图片内容，是否有被加载成功，https://img95.699pic.com/photo/50046/5562.jpg_wh300.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提高用户体验的同时，减少对性能的伤害</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyImage</span>(<span class="params">_id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oImg = <span class="keyword">new</span> Image();</span><br><span class="line">    <span class="built_in">this</span>.setSrc = <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">        oImg.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(_id).appendChild(oImg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">var</span> ProxyImage = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oImg = <span class="keyword">new</span> Image();</span><br><span class="line">    <span class="keyword">var</span> oMyImage = <span class="keyword">new</span> MyImage(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    oImg.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        oMyImage.setSrc(oImg.src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 占位图片，请求的图片</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">occupySrc,src</span>) </span>&#123;</span><br><span class="line">        oImg.src = src;</span><br><span class="line">        oMyImage.setSrc(occupySrc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">ProxyImage(<span class="string">&quot;https://pic2.zhimg.com/v2-3b4fc7e3a1195a081d0259246c38debc_720w.jpg?source=172ae18b&quot;</span>,<span class="string">&quot;https://img95.699pic.com/photo/50046/5562.jpg_wh300.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><p>点击按钮集中添加样式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;bg&quot;</span>&gt;</span>添加颜色（绿色）<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;cl&quot;</span>&gt;</span>添加字体颜色（蓝色）<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;fs&quot;</span>&gt;</span>添加字体大小（24px）<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;fw&quot;</span>&gt;</span>添加字体粗体（bold）<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;op&quot;</span>&gt;</span>添加透明度（0.3）<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oButtonArray = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//代理</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ProxyRequest = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 样式缓存</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> cache = [];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 每次点击之后就将type属性添加到cache</span></span></span><br><span class="line"><span class="javascript">            cache.push(<span class="built_in">this</span>.getAttribute(<span class="string">&#x27;type&#x27;</span>));</span></span><br><span class="line"><span class="javascript">            <span class="built_in">clearTimeout</span>(timer);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//每隔2秒执行一次</span></span></span><br><span class="line"><span class="javascript">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// cache =》 changeStyle</span></span></span><br><span class="line"><span class="javascript">                func(oDiv,cache)</span></span><br><span class="line"><span class="javascript">                cache = [];</span></span><br><span class="line"><span class="javascript">            &#125;,<span class="number">2000</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> realChangeStyle = ProxyRequest(changeStyle);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//添加点击事件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; oButtonArray.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        oButtonArray[i].onclick = realChangeStyle;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 更改样式 </span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">changeStyle</span>(<span class="params">dom,typeArr</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// type =&gt; dom  style =&gt; value</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> typeObj = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">bg</span>: [<span class="string">&#x27;backgroundColor&#x27;</span>,<span class="string">&#x27;green&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="attr">cl</span>: [<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="attr">fs</span>: [<span class="string">&#x27;fontSize&#x27;</span>,<span class="string">&#x27;24px&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="attr">fw</span>: [<span class="string">&#x27;fontWeight&#x27;</span>,<span class="string">&#x27;bold&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="attr">op</span>: [<span class="string">&#x27;opacity&#x27;</span>,<span class="string">&#x27;0.3&#x27;</span>]</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(typeArr.constructor == <span class="built_in">Array</span>) &#123;</span></span><br><span class="line"><span class="javascript">            typeArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                dom.style[typeObj[ele][<span class="number">0</span>]] = typeObj[ele][<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            dom.style[typeObj[typeArr][<span class="number">0</span>]] = typeObj[typeArr][<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="安全代理（保护代理）"><a href="#安全代理（保护代理）" class="headerlink" title="安全代理（保护代理）"></a>安全代理（保护代理）</h2><ul><li>控制真实对象的访问权限</li><li>保护代理就是起到保护作用，用来过滤掉一下不必要的请求，将真正需要的提给本体，譬如：验证用户名，如果用户名不合法，则不会将该请求给本体执行</li><li>常用功能：登陆操作后才能看到全功能，前端校验</li></ul><p>前端登陆校验-没有使用安全代理模式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userDom&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;showUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;psDom&quot;</span> <span class="attr">name</span>=<span class="string">&quot;code&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;showCode&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 不能为空，用户名长度不可以超过四个</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 不能为空，密码长度不能低于6</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 假定数据可以发送成功</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    submit.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        showUser.innerText = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        showCode.innerText = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(userDom.value == <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">            flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            showUser.innerText = <span class="string">&quot;用户名不能为空&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userDom.value.length &gt;= <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="javascript">            flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            showUser.innerText = <span class="string">&#x27;用户名不能大于四&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(psDom.value == <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">            flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            showCode.innerText = <span class="string">&quot;密码不能为空&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(psDom.value.length &lt; <span class="number">6</span>) &#123;</span></span><br><span class="line"><span class="javascript">            flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            showCode.innerText = <span class="string">&quot;密码不能小于6&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(flag) &#123;</span></span><br><span class="line"><span class="javascript">            Request();</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">Request</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//请求数据内容</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">这样编写代码，的确可以完成业务的需求，能够完成表单的验证，但是存在很多问题</span></span><br><span class="line"><span class="comment">1. 绑定的函数比较庞大，包含了很多的if-else语句，这些语句需要覆盖素有的校验规则</span></span><br><span class="line"><span class="comment">2. 绑定的函数缺乏弹性，如果增加了一种新的校验规则，或者想要把密码的长度校验从6改成8，我们都必须深入</span></span><br><span class="line"><span class="comment">3. 绑定的函数的内部实现，这是违反了开放-封闭原则的</span></span><br><span class="line"><span class="comment">4. 算法的复用性差，如果程序中增加了另一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制得漫天遍野</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>前端登录校验-使用安全代理+策略模式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">策略模式定义：策略模式是指对一系列的算法定义，并将每一个算法封装起来，而且使他们还可以相互转换，策略模式让算法独立于使用它的客户而独立变化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">策略模式的优点有：策略模式提供了管理相关的算法族的办法，策略模式提供了可以调换继承关系的办法，使用策略模式可以避免使用多重条件转移语句</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">策略模式-特点说明</span></span><br><span class="line"><span class="comment">策略模式支持您再运行时选择算法，把他们一个个封装起来，并且使他们可以相互替换</span></span><br><span class="line"><span class="comment">决定用一个类对象实例来管理规则的校验</span></span><br><span class="line"><span class="comment">该对象要能，相应的主动添加对规则的相应处理办法</span></span><br><span class="line"><span class="comment">校验数据的时候可以相应的返回相关信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">业务复杂到一定程度了我们才选用设计模式取解决复杂的问题，拓展性，复用性，冗余度，小的情况没必要使用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    用户名：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userDom&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;showUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    密码：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pwdDom&quot;</span> <span class="attr">name</span>=<span class="string">&quot;code&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;showPwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    邮箱：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;emDom&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;showEmail&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     submit.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        ProxyRequest();</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// A =&gt; C =&gt; B</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">Request</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;send&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 构造函数 =&gt; 对象实例</span></span></span><br><span class="line"><span class="javascript">    Validator.prototype.strategies = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">isNonEmpty</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value, errorMsg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (value == <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errorMsg;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">maxLength</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value, length, errorMsg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (value != <span class="string">&#x27;&#x27;</span> &amp;&amp; value.length &gt; length) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errorMsg;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">minLength</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value, length, errorMsg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (value != <span class="string">&#x27;&#x27;</span> &amp;&amp; value.length &lt; length) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errorMsg;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    Validator.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">dom, showDom, strategyArr</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> self = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.warnDom.push(showDom);</span></span><br><span class="line"><span class="javascript">        strategyArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            self.cache.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// arr =&gt; [&#x27;isNonEmpty&#x27;] [&#x27;maxLength&#x27;, &#x27;4&#x27;]</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> arr = ele.strategy.split(<span class="string">&#x27;:&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// arr =&gt; [] [&#x27;4&#x27;]</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// type =&gt; isNonEmpty maxLength</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> type = arr.shift();</span></span><br><span class="line"><span class="javascript">                <span class="comment">// [dom.value] [dom.value, &#x27;4&#x27;]</span></span></span><br><span class="line"><span class="javascript">                arr.unshift(dom.value);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// [dom.value,errorMsg] [dom.value,&#x27;4&#x27;,&#x27;errorMsg&#x27;]</span></span></span><br><span class="line"><span class="javascript">                arr.push(ele.errorMsg);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> msg = self.strategies[type].apply(self, arr);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (msg != <span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    showDom.innerText = msg;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> msg;</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    Validator.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 标记最后是否能符合规则</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.warnDom.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            ele.innerText = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.cache.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (ele() != <span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">                flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 拓展验证方式</span></span></span><br><span class="line"><span class="javascript">    Validator.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            validator.extend(&#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                isEmail: function(value,errorMsg) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                    if(value != &quot;&quot; &amp;&amp; value.indexOf(&quot;@&quot;) == -1) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                        return errorMsg;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                    &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                    return true;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                &#125;,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                isPhone: function(value,errorMsg) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                    if(value != &quot;&quot; &amp;&amp; value.length == 11) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                        return errorMsg;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                    &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                    return true;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            &#125;)</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        */</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> config) &#123;</span></span><br><span class="line"><span class="javascript">            Validator.prototype.strategies[prop] = config[prop];</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">Validator</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">/*  </span></span></span><br><span class="line"><span class="comment"><span class="javascript">        拥有方法：</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        add 参数：1. 校验内容dom 2.错误信息显示dom 3.检验规则</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        add 添加校验规则（dom，showDom,[</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            &#123;strategy: &#x27;isNonEmpty&#x27;, errorMsg: &quot;用户名不能为空&quot;&#125;,&#123;strategy: &#x27;maxLength: 4&#x27;,errorMsg: &#x27;用户名长度不能超过4&#x27;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        ]） </span></span></span><br><span class="line"><span class="comment"><span class="javascript">        start 开始校验并返回真正的校验结果</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        extend 可以扩展 算法 &#123;isMail: function()&#123;&#125;&#125; </span></span></span><br><span class="line"><span class="comment"><span class="javascript">        */</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.cache = [];</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.warnDom = [];</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> validator = <span class="keyword">new</span> Validator();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ProxyRequest = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        validator.add(userDom, showUser, [</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">strategy</span>: <span class="string">&#x27;isNonEmpty&#x27;</span>, <span class="attr">errorMsg</span>: <span class="string">&#x27;用户名不能为空&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">strategy</span>: <span class="string">&#x27;maxLength: 4&#x27;</span>, <span class="attr">errorMsg</span>: <span class="string">&#x27;用户名长度不能超过4&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">        ]);</span></span><br><span class="line"><span class="javascript">        validator.add(pwdDom, showPwd, [</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">strategy</span>: <span class="string">&#x27;isNonEmpty&#x27;</span>, <span class="attr">errorMsg</span>: <span class="string">&#x27;密码不能为空&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">strategy</span>: <span class="string">&#x27;minLength: 6&#x27;</span>, <span class="attr">errorMsg</span>: <span class="string">&#x27;密码长度不能小于6&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">        ]);</span></span><br><span class="line"><span class="javascript">        validator.add(emDom,showEmail,[</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">strategy</span>: <span class="string">&#x27;isNonEmpty&#x27;</span>, <span class="attr">errorMsg</span>: <span class="string">&#x27;邮箱不能为空&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="attr">strategy</span>: <span class="string">&#x27;isEmail&#x27;</span>, <span class="attr">errorMsg</span>: <span class="string">&quot;邮箱格式不正确&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">        ])</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (validator.start()) &#123;</span></span><br><span class="line"><span class="javascript">                Request();</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;)();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    validator.extend(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">isEmail</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value, errorMsg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (value != <span class="string">&quot;&quot;</span> &amp;&amp; value.indexOf(<span class="string">&#x27;@&#x27;</span>) == -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errorMsg;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><ul><li>一个对象将不同空间的对象进行局部代理</li><li>常用功能：监控多个对象的状态，总机监控分店</li></ul><h2 id="智能代理"><a href="#智能代理" class="headerlink" title="智能代理"></a>智能代理</h2><ul><li>调用对象代理处理另外一些事情如垃圾回收机制增加额外的服务</li><li>常用功能：提供额外的其他服务，火车站代售处</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式-代理模式&quot;&gt;&lt;a href=&quot;#设计模式-代理模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-代理模式&quot;&gt;&lt;/a&gt;设计模式-代理模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定义：为一个对象提供一种代理以控制对这个对象的访问&lt;/li&gt;
&lt;li&gt;代理对象起到类似中介的作用，会增加一些功能（如，校验，合并等等），也会去掉一些原有对象的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代理示范&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 例子 给女神送花&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 有一个人，有一个送花的功能，要给女神target送花&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mrPerson = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;sendFlower&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;target&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 送的什么花呢？向日葵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Flower = &lt;span class=&quot;string&quot;&gt;&amp;#x27;sunFlower&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 然后女神开始考虑接不接受送的花&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target.receiveFlower(Flower);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 女神呢，要有一个接受花的功能，同时还有一个心情的好坏，心情好的话就接受了，心情不好的话就拒绝了，那就要有一个改变心情的功能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; goddess = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 女神的心情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;mood&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 女神考虑接不接受送的花&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;receiveFlower&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;flower&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// true 心情好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// false 心情不好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 如果是好的话就ok了，我接受了，否则就get out了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.mood ? &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&amp;#x27;ok&amp;#x27;&lt;/span&gt;) : &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&amp;quot;get out&amp;quot;&lt;/span&gt;);;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 改变女神心情，如果随机数大于0.5就是true，心情好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;changeMood&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.mood = &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random() &amp;gt; &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// console.log(this.mood);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//切换心情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;createMood&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; self = &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 女神一开始要有一个心情，否则就是null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.changeMood();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 然后每隔400毫秒改变一次心情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;setInterval&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.changeMood();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;span class=&quot;number&quot;&gt;400&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 女神一开始就要切换心情了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;goddess.createMood();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这样写完之后，有一个问题，我们的功能不能时好时坏呀，也不有看心情来触发啊，我们同时也要保证绝对的可行性，这个时候就要添加一个代理，来控制送花的人的访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加一个代理代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; addProxy = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;proxyFlower&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;target&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// mrPerson.sendFlower(target);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.listenMood(target,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mrPerson.sendFlower(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果直接调用proxyFlower的话那么和没有代理也没有区别了，这时，就需要来判断女神的心情来考虑把花给送到女神手中，来确保成功率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;listenMood&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;target,callback&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 代理每隔300毫秒去看看女神心情好不好，然后决定送不送花&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timer = &lt;span class=&quot;built_in&quot;&gt;setInterval&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果心情好的话就帮人给女神送花了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(target.mood) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                callback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;clearInterval&lt;/span&gt;(timer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, &lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 然后某一人开始给给女神送花&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// mrPerson.sendFlower(goddess);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 委托代理给女神送花&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addProxy.proxyFlower(goddess);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-28T11:55:47.000Z</published>
    <updated>2022-05-17T01:12:47.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-单例模式"><a href="#设计模式-单例模式" class="headerlink" title="设计模式-单例模式"></a>设计模式-单例模式</h1><ul><li>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点</li><li>创建型模式，它提供了一种创建对象的最佳方式。</li><li>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一个访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</li><li>在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例，既一个类只有一个对象实例</li></ul><p>范例：</p><p>声明一个函数，想要这个函数无论怎么声明，最后实现的实例还是第一个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var this = Object.create(Test.prototype);</span></span><br><span class="line">    <span class="comment">// 判断Test的instance是否等于object，如果等于object说明已经被实例化了一次，那么就直接返回实例化过的对象，不用再实例化一次</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> Test.instance === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Test.instance; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    Test.instance = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// return this;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Test(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 虽然可以实现单例模式，但是违反了开闭原则，外部可以直接更改Test之中的内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 让Test直接等于instance，永远都是第一回声明的实例</span></span><br><span class="line">    Test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Test();</span><br><span class="line">Test.prototype.lastName = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="comment">// 可以实现单例模式，也可以实现开闭原则，但是如果给Test的protottype中赋值，则访问不到，因为给Test原型赋值则是给里面的那个Test原型赋值，外面Test获取不到</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.2</span></span><br><span class="line"><span class="comment">// 圣杯/闭包</span></span><br><span class="line"><span class="keyword">var</span> Test = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="comment">// 直接再立即执行函数中返回一个函数，如果instance是object，说明声明了一次实例，就直接返回instance，也就是之前声明的实例，如果instance没有值，那么就让instance=this，隐式的返回了this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> instance === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        instance = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="comment">// return this;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Test();</span><br><span class="line">Test.prototype.lastName = <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(a === b,a.lastName,b.lastName);</span><br><span class="line"><span class="comment">//这样就会解决以上的两个问题了</span></span><br></pre></td></tr></table></figure><p>案例：</p><p>添加点击事件，无论点击多少次，都只拥有一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//这个函数并没有按照单例模式来进行</span></span><br><span class="line"><span class="comment">var CreateAlert = function (text) &#123;</span></span><br><span class="line"><span class="comment">    var oDiv = document.createElement(&quot;div&quot;);</span></span><br><span class="line"><span class="comment">    oDiv.style.display = &#x27;none&#x27;;</span></span><br><span class="line"><span class="comment">    oDiv.innerText = text;</span></span><br><span class="line"><span class="comment">    document.body.appendChild(oDiv);                </span></span><br><span class="line"><span class="comment">    return oDiv;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleAlert = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oDiv != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> oDiv;</span><br><span class="line">        &#125;</span><br><span class="line">        oDiv = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        oDiv.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">        oDiv.innerText = text;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(oDiv);</span><br><span class="line">        <span class="keyword">return</span> oDiv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = singleAlert(<span class="string">&quot;hello Long&quot;</span>);</span><br><span class="line">    oDiv.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例函数</span></span><br><span class="line"><span class="comment">// 函数功能：将一个希望成为单例函数的普通函数当作参数传入，并且将普通函数返回成单例函数</span></span><br><span class="line"><span class="comment">// 传入func，返回新的单例函数</span></span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result; <span class="comment">//就是返回的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// arguments，就是传入的参数</span></span><br><span class="line">        <span class="comment">// 如果result不存在，那么就执行func，如果存在，直接返回result</span></span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            result = func.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// if(result != null) &#123;</span></span><br><span class="line">        <span class="comment">//     return result;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// result = func.apply(this,arguments);</span></span><br><span class="line">        <span class="comment">// return result;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> singleAlert = getSingle(CreateAlert)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数并没有按照单例模式来进行</span></span><br><span class="line"><span class="keyword">var</span> CreateAlert = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    oDiv.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    oDiv.innerText = text;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(oDiv);                </span><br><span class="line">    <span class="keyword">return</span> oDiv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            result = func.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> singleAlert = getSingle(CreateAlert);</span><br><span class="line"></span><br><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oDiv = singleAlert(<span class="string">&quot;hello Long&quot;</span>);</span><br><span class="line">    oDiv.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-单例模式&quot;&gt;&lt;a href=&quot;#设计模式-单例模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-单例模式&quot;&gt;&lt;/a&gt;设计模式-单例模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简单概括</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E6%A6%82%E6%8B%AC/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E6%A6%82%E6%8B%AC/</id>
    <published>2021-12-25T06:04:10.000Z</published>
    <updated>2022-05-17T01:12:47.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简单概括"><a href="#设计模式简单概括" class="headerlink" title="设计模式简单概括"></a>设计模式简单概括</h1><ul><li>什么是设计模式，原则</li><li>设计模式详解</li><li><code>UML</code>，贪吃蛇</li></ul><h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><ul><li>设计模式（Design Pattern）是一套被反复使用、多数人只晓得、经过分类的、代码设计经验的总结</li><li><strong>模式是什么？</strong><ul><li>模式-模式是指从生产经验和生活经验中经过抽象和升华提炼出来的核心知识体系。模式（Pattern）其实就是解决某一类问题的方法论</li></ul></li><li><strong>设计模式的目的</strong><ul><li>使用设计模式的目的：为了代码的可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样</li></ul></li><li>没有套路做事情没效率，很笨拙，重用性太小，情况再复杂的时候难度就很大，有了套路更容易地解决一些复杂的问题，让开发变得更加的高效</li></ul><span id="more"></span><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="创建型-研究搞高效的创建对象"><a href="#创建型-研究搞高效的创建对象" class="headerlink" title="创建型-研究搞高效的创建对象"></a>创建型-研究搞高效的创建对象</h3><ul><li>单例模式</li><li>抽象工厂模式</li><li>建造者模式</li><li>工厂模式</li><li>原型模式</li></ul><h3 id="结构型模式-设计对象的结构和关系"><a href="#结构型模式-设计对象的结构和关系" class="headerlink" title="结构型模式-设计对象的结构和关系"></a>结构型模式-设计对象的结构和关系</h3><ul><li>适配器模式</li><li>桥接模式</li><li>装饰模式</li><li>组合模式</li><li>外观模式</li><li>亨元模式</li><li>代理模式</li></ul><h3 id="行为型模式-设计对象的行为"><a href="#行为型模式-设计对象的行为" class="headerlink" title="行为型模式-设计对象的行为"></a>行为型模式-设计对象的行为</h3><ul><li>模板方式模式</li><li>命令模式</li><li>迭代器模式</li><li>观察者模式</li><li>中介者模式</li><li>备忘录模式</li><li>解释器模式</li><li>状态模式</li><li>策略模式</li><li>职责链模式</li><li>访问者模式</li></ul><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ul><li><p>减少耦合，增强复用性，降低代码的开发维护拓展成本</p></li><li><p>耦合关系是指某两个事物之间如果存在一种相互作用、相互影响的关系，那么这种关系就称“耦合关系”。</p></li><li><p>耦合度和复杂度的危害：</p><ul><li>复杂度：高，代码质量不高，可维护性差，复用性差，不宜拓展。</li><li>耦合度：无 不可能，低 合理，过高不容易维护，单复用性和拓展性是好的</li></ul></li><li><p>开发时的流程</p><ul><li>优先降低复杂度</li><li>1、利用单一职责原则，开闭原则，里氏代换原则降低复杂度</li><li>2、通过迪米特法则减少耦合</li><li>3、通过依赖倒置原则消除可以没有的耦合</li></ul></li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul><li>单一职责原则（<strong>single Responsibility principle</strong>）<ul><li>一个方法只做一件事情，请求数据的函数你就不要渲染数据了，吃饭上厕所不要用同一个地方</li></ul></li></ul><p>没有使用单一原则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有使用设计模式单一原则时：多种功能混杂在一起，阅读起来非常困难，复杂度很高，代码重复度很高</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params">url, data, dom</span>) </span>&#123;</span><br><span class="line"><span class="comment">//如果缓存中有数据，那么渲染缓存中的数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;list&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> arr = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;list&#x27;</span>));</span><br><span class="line">        <span class="keyword">var</span> htmlStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">            htmlStr += <span class="string">&#x27;&lt;li&gt;&#x27;</span> + ele.name + <span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        dom.innerhTML = htmlStr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取数据功能</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: url,</span><br><span class="line">            <span class="attr">data</span>: data,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> arr = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">                <span class="comment">// 缓存数据功能</span></span><br><span class="line">                <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;list&quot;</span>,json);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 渲染数据功能</span></span><br><span class="line">                <span class="keyword">var</span> htmlStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">                    htmlStr += <span class="string">&#x27;&lt;li&gt;&#x27;</span> + ele.name + <span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                dom.innerhTML = htmlStr;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">View(<span class="string">&quot;xxx&quot;</span>,<span class="string">&#x27;page=1&#x27;</span>,ul)</span><br></pre></td></tr></table></figure><p>使用了单一职责原则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了设计模式单一原则时：复杂度降低了，耦合度稍微提高了，函数可重复使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetData</span>(<span class="params">callbackArr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getData = <span class="function"><span class="keyword">function</span> (<span class="params">url, param</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: url,</span><br><span class="line">            <span class="attr">data</span>: param,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">                callbackArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">                    ele.do(json);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oG = <span class="keyword">new</span> GetData([oR, oC]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据渲染</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Render</span>(<span class="params">dom</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.do = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> htmlStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">            htmlStr += <span class="string">&#x27;&lt;li&gt;&#x27;</span> + ele.name + <span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        dom.innerHTML = htmlStr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oR = <span class="keyword">new</span> Render(ul);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CacheData</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.do = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 缓存数据</span></span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(type, data);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取缓存中的数据</span></span><br><span class="line">    <span class="built_in">this</span>.returnCacheData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">localStorage</span>.getItem(type);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oC = <span class="keyword">new</span> CacheData(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离线缓存，如果是离线的情况下，直接取缓存数据，并且点击按钮也不通过网络获取数据</span></span><br><span class="line"><span class="comment">// 不离线，通过缓存获取数据，点击按钮通过网络获取</span></span><br><span class="line"><span class="keyword">if</span> (oC.returnCacheData()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!navigator.onLine) &#123;</span><br><span class="line">        oG.getData();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oR.do(oC.returnCacheData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oG.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    oG.getData(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;page=2&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 OCP"></a>开闭原则 OCP</h3><ul><li>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭</li><li>面向拓展开放，面向修改关闭 <code>jquery extend</code>，同时增强代码复用性</li></ul><h3 id="里氏代换原则-L-substitution-Principle"><a href="#里氏代换原则-L-substitution-Principle" class="headerlink" title="里氏代换原则 L substitution Principle"></a>里氏代换原则 L substitution Principle</h3><ul><li>任何基类可以出现的地方，子类一定可以出现。通俗的来讲就是：子类可以拓展父类的功能，但不能改变父类原有的功能。</li><li>一个宴会邀请父亲去，父亲去不了儿子去</li><li>一个父类可以访问的接口，父类忙着其他事情，子类可以去访问。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类Rectangle</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setWidth = <span class="function"><span class="keyword">function</span> (<span class="params">width</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setHeight = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.getWidth  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.getHeight  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类Square</span></span><br><span class="line">Square.prototype = <span class="keyword">new</span> Rectangle();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setWidth = <span class="function"><span class="keyword">function</span> (<span class="params">width</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setHeight = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setWidth(height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oR = <span class="keyword">new</span> Rectangle();</span><br><span class="line">oR.setWidth(<span class="number">200</span>);</span><br><span class="line">oR.setHeight(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oS = <span class="keyword">new</span> Square();</span><br><span class="line">oS.setWidth(<span class="number">200</span>);</span><br><span class="line">oS.setHeight(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Resize</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(o.getHeight() &lt;= o.getWidth())&#123;</span><br><span class="line">        o.setHeight(o.getWidth() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;over&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Resize(oR);</span><br><span class="line"><span class="comment">// Resize(oS); 死循环,当oS改变高或高时时，都会调用了this.SetWidth()或this.SetHeight()方法，然而就会将宽高值给设置成一样的，循环永远跳不出来，所以大部分情况下要遵循里氏代换原则，不可以私自更改父类的方法</span></span><br></pre></td></tr></table></figure><h3 id="迪米特法则（最小知道原则）-LD"><a href="#迪米特法则（最小知道原则）-LD" class="headerlink" title="迪米特法则（最小知道原则） LD"></a>迪米特法则（最小知道原则） LD</h3><ul><li>一个接口和一个方法，传入的参数越少越好。降低耦合度的同时也会让复杂程度降低</li><li>谍战片中间谍，两个同一伙间谍互相不知道，为什么要这样呢？</li><li>为了最大程度较少伤害，死只死一条线上的人</li><li>形成的关联越少越好，依赖最少</li></ul><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h3><ul><li>最常见的原则，依赖接口，不依赖方法，底层的东西不用了解，我们只需知道表现就可以，降低耦合度</li><li>前端应用中可以理解成多者之间依赖状态，而不依赖彼此</li><li><code>Js</code>中没有接口的概念</li></ul><h3 id="接口分离原则-ISP"><a href="#接口分离原则-ISP" class="headerlink" title="接口分离原则 ISP"></a>接口分离原则 ISP</h3><ul><li>把大接口拆分小接口，不能一个接口全部实现增删改查</li><li>比如写作业，要细分成，写数学、英语、语文等作业，同时降低耦合度</li></ul><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ul><li>代码是一团乱码，先靠单一、开闭、里氏给他分成很多块，最小知道让他们变得弱化，最后需要依赖倒置把没有必要的耦合给它消除了</li><li>代码质量的高低是素质，学会权衡才是高价值的开发经验</li><li>先原则，在模式<ul><li>原则是理论，模式是在理论上的具体方式，希望并建议考试100分，但都是理论具体还需要落实再实际方式方法上，但不可以追求，其中有时间成本，用更多的时间去玩还能保证不低的分数也是可以的</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式简单概括&quot;&gt;&lt;a href=&quot;#设计模式简单概括&quot; class=&quot;headerlink&quot; title=&quot;设计模式简单概括&quot;&gt;&lt;/a&gt;设计模式简单概括&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是设计模式，原则&lt;/li&gt;
&lt;li&gt;设计模式详解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UML&lt;/code&gt;，贪吃蛇&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是设计模式？&quot;&gt;&lt;a href=&quot;#什么是设计模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式？&quot;&gt;&lt;/a&gt;什么是设计模式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设计模式（Design Pattern）是一套被反复使用、多数人只晓得、经过分类的、代码设计经验的总结&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模式是什么？&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;模式-模式是指从生产经验和生活经验中经过抽象和升华提炼出来的核心知识体系。模式（Pattern）其实就是解决某一类问题的方法论&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设计模式的目的&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;使用设计模式的目的：为了代码的可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;没有套路做事情没效率，很笨拙，重用性太小，情况再复杂的时候难度就很大，有了套路更容易地解决一些复杂的问题，让开发变得更加的高效&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTML &amp; CSS</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/11/HTML%20&amp;%20CSS/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/11/HTML%20&amp;%20CSS/</id>
    <published>2021-11-11T10:35:05.000Z</published>
    <updated>2022-05-17T01:12:47.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一部分-HTML"><a href="#第一部分-HTML" class="headerlink" title="第一部分 HTML"></a>第一部分 HTML</h3><hr><h4 id="第一章-职业规划和前景"><a href="#第一章-职业规划和前景" class="headerlink" title="第一章 职业规划和前景"></a>第一章 职业规划和前景</h4><hr><ul><li><p><strong>职业方向规划定位：</strong></p></li><li><p><code>web</code>前端开发工程师</p><ul><li><code>web</code>网站架构师</li><li>自己创业</li><li>转岗管理或其他<span id="more"></span></li></ul></li><li><p><strong><code>web</code>前端开发的前景展望：</strong></p><ul><li>未来<code>IT</code>行业企业需求最多的人才</li><li>结合最新的<code>html5</code>抢占移动端的市场</li><li>自己创业做老板</li><li>随着互联网的普及<code>web</code>开发成为企业的宠儿和核心</li></ul></li><li><p> <strong><code>web</code>职业发展目标：</strong></p></li><li><p>第一、梳理知识架构</p><ul><li>负责内容的<code>HTML</code></li><li>负责外观的<code>css</code>（层叠样式表）</li><li>负责行为的<code>js</code></li><li><code>ps</code>切图</li></ul></li><li><p>第二、分解目标（起步阶段、提升阶段、成型阶段）</p><ul><li><p>起步阶段：</p><ul><li>基本知识的掌握</li><li>常用工具的掌握</li><li>沟通技巧的掌握（围绕客户的需求）</li><li>良好的开发习惯（加注释、对齐方式）</li></ul></li><li><p>提升阶段：</p><ul><li>熟悉掌握<code>HTML</code>基本标签和属性</li><li>熟练掌握<code>css</code>的基本语法和使用</li><li>浏览器兼容和w3c标准的掌握</li><li>结合<code>html</code>+<code>css</code>+<code>js</code>开始系统项目的开发</li></ul></li><li><p>成型阶段：</p><ul><li>精通<code>DIV</code>+<code>CCS</code>布局</li><li>精通<code>css</code>样式表控制<code>html</code>标签</li><li>熟悉运用<code>js</code>制作动态网站的效果</li><li>能独立开发完成网站</li></ul></li></ul></li></ul><hr><h4 id="第二章-html基本结构"><a href="#第二章-html基本结构" class="headerlink" title="第二章 html基本结构"></a>第二章 html基本结构</h4><hr><ul><li><p>认识HTML：</p><ul><li><code>html</code>不是一种编程语言，是一种标志语言</li><li>标记语言是由一套标识标签组成的</li><li><code>html</code>使用标签来描述网页</li></ul></li><li><p><code>html</code>结构：</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/main.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 逻辑代码 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 逻辑代码底部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery/jquery-2.1.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;head&gt;</code>中添加信息</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;smile@kang.cool&quot;</span>&gt;</span>------作者</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>------网页描述</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;a,b,c&quot;</span>&gt;</span>------关键字,“，”分隔</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Wed, 26 Feb 1997 08：21：57 GMT&quot;</span>&gt;</span>------设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span>------禁止浏览器从本地机的缓存中调阅页面内容</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Window-target&quot;</span> <span class="attr">content</span>=<span class="string">&quot;_top&quot;</span>&gt;</span>------用来防止别人在框架里调用你的页面</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5;URL=http://kahn1990.com/&quot;</span>&gt;</span>------跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;none&quot;</span>&gt;</span>------content的参数有all,none,index,noindex,follow,nofollow，默认是all</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;Shortcut Icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span>&gt;</span>------收藏图标</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache, must-revalidate&quot;</span>&gt;</span>------网页不会被缓存</span><br></pre></td></tr></table></figure><ul><li><p>不成对出现的标签<br><code>&lt;br&gt;</code> <code>&lt;hr&gt;</code>  <code>&lt;meta&gt;</code> <code>&lt;img&gt;</code>  <code>&lt;input..&gt;</code>  <code>&lt;option..&gt;</code>  <code>&lt;link&gt;</code></p></li><li><p>特殊符号：</p><ul><li><code>&amp;nbsp</code>; —-&gt;空格</li><li><code>&amp;gt</code>; —&gt;大于号</li><li><code>&amp;lt</code>；—&lt;小于号</li><li><code>&amp;quot</code>；—&gt;引号</li><li><code>&amp;copy</code>;–&gt;版权号</li></ul></li></ul><hr><h4 id="第三章-html基本标签"><a href="#第三章-html基本标签" class="headerlink" title="第三章 html基本标签"></a>第三章 html基本标签</h4><hr><ul><li><p><code>&lt;html&gt;</code> <code>&lt;head&gt;</code> <code>&lt;body&gt;</code>标签</p></li><li><p><code>&lt;h1&gt;&lt;/h1</code>—-<code>&lt;h6&gt;&lt;/h6&gt;</code>标题，<em>不要为了产生粗体文本使用它们</em></p></li><li><p><code>&lt;p&gt;</code>标签  段落标签</p></li><li><p><code>&lt;strong&gt;&lt;b&gt;</code>标签</p><ul><li>都会让文字产生加粗效果<ul><li><code>&lt;strong&gt;</code>用于强调文本，强度更深，表示重要文本—&gt;用于<code>SEO</code>优化</li></ul></li><li><code>&lt;b&gt;</code>只是视觉加粗效果—&gt;单纯为了产生加粗</li></ul></li><li><p><code>&lt;em&gt;</code> <code>&lt;i&gt;</code>标签</p><ul><li><code>em</code>用于强调文本</li><li><code>i</code>只是视觉斜体效果</li></ul></li><li><p><code>&lt;strong&gt;</code>比<code>&lt;em&gt;</code>强调更强</p></li><li><p><code>span</code>标签</p><ul><li>对被用来组合文档中的行内元素</li><li>注意：span没有固定的格式表现，当对它应用样式时，才会产生视觉上的变化</li></ul></li><li><p><code>&lt;pre&gt;</code>标签</p></li><li><p>文字的格式按源码的排版来显示，我们称之为预处理格式</p></li><li><p><code>&lt;a&gt;</code>标签—&gt;他有一个必不可少的属性 href</p><ul><li><code>target</code>属性：</li><li><code>_self</code>(在原来页面打开)</li><li><code> _blank</code>（新窗口打开）</li><li><code>_top</code>（打开时忽略所有的框架）</li><li> <code>_parent</code>（在父窗口中打开）</li></ul></li><li><p>创建锚点和锚链接</p><ul><li>锚点也是一种超链接，是页面内进行跳转的超链接<pre><code>- 第一步：创建锚点 `&lt;a name=&quot;锚点名称&quot;&gt;&lt;/a&gt;`- 第二步：使用创建好的锚点名称 `&lt;a href=&quot;#锚点名称&quot;&gt;内容&lt;/a&gt;`</code></pre></li></ul></li><li><p><code>marquee</code>标签</p><ul><li>可以创建一个内容滚动效果</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span>=<span class="string">&quot;down&quot;</span> <span class="attr">loop</span>=<span class="string">&quot;4&quot;</span> <span class="attr">onmouseover</span>=<span class="string">this.stop()</span> <span class="attr">onmouseout</span>=<span class="string">this.start()</span>&gt;</span><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>direction</code> 表示滚动方向，取值有（left,right,up,down,默认left）</li><li><code>loop </code>表示滚动循环的次数，默认为无限循环</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onmouseover=<span class="built_in">this</span>.stop()  onmouseover=<span class="built_in">this</span>.start()  scrollamout=<span class="string">&quot;1&quot;</span>(滚动速度)</span><br></pre></td></tr></table></figure><ul><li>表示当鼠标移上区域的时候停止滚动，鼠标移开继续滚动</li></ul><hr><h4 id="第四章-img图片标签与路径"><a href="#第四章-img图片标签与路径" class="headerlink" title="第四章 img图片标签与路径"></a>第四章 img图片标签与路径</h4><hr><ul><li><p>图片标签与路径：</p><ul><li>常见图片格式 <code>jpg</code> <code>png</code> <code>gif</code></li><li><code>Gif</code>     （只支持全透明）</li><li><code>Jpeg</code> /<code>jpg</code></li><li><code>Png</code> 半/全透明都支持</li></ul></li><li><p>图片标签写法 ：</p><ul><li><code>&lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt;</code></li></ul></li><li><p>图片四要素：</p><ul><li><code>src=&quot;&quot;</code>        图片路径</li><li><code>alt=&quot;&quot; </code>       图片含义</li><li><code>width=&quot;&quot;</code>     图片宽度 和图片大小保持一致</li><li><code> height=&quot;&quot;</code>     图片高度 和图片大小保持一致</li><li><code>title=&quot;&quot;</code></li></ul></li><li><p>路径知识：</p><ul><li><p>相对路径、绝对路径：</p><ul><li>相对路径：(Relative Path) 相对于该文件的路径；</li><li>绝对路径：(Absolute Path) 从磁盘出发的路径；</li></ul></li><li><p><code>&lt;img src=&quot;&quot; …… align=&quot;&quot; /&gt;</code> <code>align</code>属性–设置图片与后面文字的位置关系<br>值–<code>top</code>、<code>bottom</code>、<code>middle</code>、<code>absmiddle</code>、<code>left</code>、<code>right</code></p></li></ul></li><li><p>在静态页面中：</p><ul><li><p><code>/</code>开头表示根目录；</p></li><li><p><code>./</code>表示当前目录；（斜画线前面一个点）</p></li><li><p><code>../</code>上级目录；（斜画线前面两个点）</p></li><li><p>直接用文件名不带/也表示同一目录</p></li><li><p>这些都是相对于当前文件的位置来说的，如果用绝对路径的话就是写全了。</p></li></ul></li></ul><hr><h4 id="第五章-三种列表的讲解"><a href="#第五章-三种列表的讲解" class="headerlink" title="第五章 三种列表的讲解"></a>第五章 三种列表的讲解</h4><hr><ul><li>三种列表的知识讲解：<ul><li><code>&lt;ul&gt;</code>无序列表<ul><li>无序列表是一个没有顺序项目的列表，此列表项默认粗体圆点进行标识</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li&gt;&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ul><li><ol>有序列表  - 有序列表也是一列项目，只是列表项目使用的是数字进行标记。 有序列表始于 `<ol>` 标签。每个列表项始于 `<li> `标签。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">   &lt;li&gt;内容一&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;内容二&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;内容三&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><ul><li><p>列表符号</p><ul><li><p>无序列表-列表符号:</p><ul><li><code>type=&quot;circle&quot;</code>  空心圆 <code>type=“disc” </code> 实心圆  默认值 <code>type=&quot;square&quot; </code> 方块符</li></ul></li><li><p>有序列表-列表符号</p><ul><li><code>type=&quot;A&quot;</code>    A B C D</li><li><code>type=&quot;a&quot;</code>    a b c d</li><li><code>type=&quot;1&quot;</code>    1 2 3 4  默认值type=”I”    I II III type=”i”     i ii iii</li></ul></li><li><p>列表嵌套</p></li><li><p>无序列表-嵌套</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line"> &lt;li&gt;柚子</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">   &lt;li&gt;沙田柚&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;蜜柚&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"> &lt;/li&gt;</span><br><span class="line"> &lt;li&gt;荔枝&lt;/li&gt;</span><br><span class="line"> &lt;li&gt;苹果&lt;/li&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ul><li>有序列表-嵌套</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line"> &lt;li&gt;茶</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">   &lt;li&gt;红茶&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;绿茶&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"> &lt;/li&gt;</span><br><span class="line"> &lt;li&gt;果汁&lt;/li&gt;</span><br><span class="line"> &lt;li&gt;牛奶&lt;/li&gt;&lt;/ol&gt;</span><br></pre></td></tr></table></figure><ul><li>定义列表<ul><li>定义列表不仅仅是一列项目，而是项目及其注释的组合。定义列表以 <code>&lt;dl&gt;</code> 标签开始。每个定义列表项以 <code>&lt;dt&gt; </code>开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code> 开始。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">     &lt;dt&gt;pc网页制作&lt;/dt&gt;</span><br><span class="line">     &lt;dd&gt;学习DIV+CSS JS JQ 项目实战&lt;/dd&gt;</span><br><span class="line">     &lt;dt&gt;手机网页制作&lt;/dt&gt;</span><br><span class="line">     &lt;dd&gt;手机网页制作实战&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>dd</code>是对<code>dt</code>的解释</p><ul><li><code>&lt; dl&gt;&lt; /dl&gt;</code>用来创建一个普通的列表,</li><li><code>&lt; dt&gt;&lt; /dt&gt;</code>用来创建列表中的上层项目，</li><li><code>&lt; dd&gt;&lt; /dd&gt;</code>用来创建列表中最下层项目，</li><li><code>&lt; dt&gt;&lt; /dt&gt;</code>和<code>&lt; dd&gt;&lt; /dd&gt;</code>都必须放在<code>&lt; dl&gt;&lt; /dl&gt;</code>标志对之间。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;中国城市&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;北京 &lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;上海 &lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;广州 &lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;美国城市&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;华盛顿 &lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;芝加哥 &lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;纽约 &lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><ul><li><code>dl</code>是d<code>efinition list</code>的缩写</li><li><code>dt</code>是<code>definition title</code>的缩写</li><li><code>dd</code>是d<code>efinition description</code>的缩写</li></ul><ul><li><code>list-style</code>属性具有三个属性分量：</li><li><code>list-style-position</code> ：设置列表项图标的位置，位于文本内或者文本外</li><li><code>list-style-type</code>： 设置列表项图标的类型</li><li><code>list-style-image </code>：使用图像设置列表项图标</li></ul><hr><h4 id="第六章-表单元素-上"><a href="#第六章-表单元素-上" class="headerlink" title="第六章 表单元素(上)"></a>第六章 表单元素(上)</h4><hr><ul><li><p>表单标签:</p><ul><li><p><code>&lt;form&gt;</code>表单标签</p><ul><li><code>&lt;form&gt;</code>表单是一个包含表单元素的区域，包括起来的都是表单的内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>HTML标签 - <code>Action</code>和确认按钮：</p><ul><li>当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;html.do&quot; method=&quot;get&quot;&gt;</span><br><span class="line">        username:  &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提  交&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>HTML</code>标签 - 隐藏域隐藏标签：</p></li><li><p>隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">     &lt;input type=&quot;hidden&quot; name=&quot;hid&quot; value=&quot;value&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;input&gt;</code>标签的掌握</p><ul><li><p>常用<code>type</code>类型：</p><ul><li><code>&lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; /&gt;</code></li><li><code>type=&quot;text&quot; </code>       单行文本输入框</li><li><code>type=&quot;password&quot;</code>    密码（<code>maxlength=&quot;&quot;</code>）</li><li><code>type=&quot;radio&quot;  </code>     单项选择（<code>checked=&quot;checked&quot;</code>）</li><li><code>type=&quot;checkbox&quot; </code>   多项选择</li><li><code>type=&quot;button&quot;  </code>    按钮</li><li><code>type=&quot;submit&quot;</code>    提交 <code>type=&quot;image&quot;</code>图片提交</li><li><code>type=&quot;file&quot;</code>    上传文件</li><li><code>type=&quot;reset&quot;    </code>重置</li><li><code>type=&quot;hidden&quot;</code>    隐藏</li></ul></li></ul></li><li><p>关于表单中的设置默认值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;今天心情不错&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select name=&quot;&quot; &gt;</span><br><span class="line"> &lt;option  value=&quot;&quot;&gt;&lt;/option&gt;</span><br><span class="line"> &lt;option  value=&quot;&quot; selected=&quot;selected&quot;&gt;&lt;/option&gt;</span><br><span class="line">&lt;select&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>textarea</code>没有默认值</p></li><li><p><code>&lt;label&gt;</code>标签的使用</p><ul><li><p><code>&lt;label&gt;&lt;/label&gt;</code></p><ul><li><code>label</code> 元素不会向用户呈现任何特殊效果。</li><li>不过，它为鼠标用户改进了可用性。</li><li>如果您在 <code>label</code> 元素内点击文本，就会触发此控件。</li><li>就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</li></ul></li><li><p><code>&lt;label&gt;</code> 标签的<code> for</code> 属性应当与相关元素的 <code>id </code>属性相同。</p></li><li><p>例子：（重要—注册表单–用户体验–必做）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;单向选择&lt;/p&gt;</span><br><span class="line">&lt;label for=&quot;male&quot;&gt;男：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;/&gt;</span><br><span class="line">&lt;label for=&quot;nv&quot;&gt;女：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;checked=&quot;check&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="第七章-表单和表格-下"><a href="#第七章-表单和表格-下" class="headerlink" title="第七章 表单和表格(下)"></a>第七章 表单和表格(下)</h4><hr><ul><li><p>表单和表格标签：</p><ul><li><code>&lt;textarea&gt;</code>文本域标签</li><li><code>&lt;textarea&gt;</code>标签：</li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code>是文本域标签，可以在其中插入一段文字内容，它有两个常用属性<code>rows</code>和<code>cols</code></li></ul></li><li><p>注意：</p><ul><li><code>rows</code>表示这个文本域有多少行</li><li><code>cols</code>表示这个文本域有多少列</li></ul></li><li><p>除了这两个属性它还有<code>readonly</code>（只读，文本域的内容无法改变，相当于协议）和<code>title</code>（鼠标放上提示）</p></li><li><p><code>&lt;select&gt;</code>标签的掌握</p><ul><li>注：当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将 <code>&lt;select&gt;</code> 表单数据提交给服务器时包括 <code>name </code>属性<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;select name=&quot;&quot;  id=&quot;&quot;&gt;</span><br><span class="line">         &lt;option value=&quot;1&quot;&gt;1月&lt;/option&gt;</span><br><span class="line">          &lt;option value=&quot;2&quot;&gt;2月&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>常用到的属性：<code>disabled=“disabled”  name=&quot;sel&quot;  size=&quot;2&quot;</code></p></li></ul><ul><li><p><code>&lt;table&gt;</code>表格标签</p></li><li><p><code> &lt;table&gt;</code>表格标签：<code>&lt;table&gt;</code>是表格标签，可以用它定义一个表格。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li><li><p>注意：<code>&lt;table&gt;</code>的<code>border</code>属性不能少</p></li></ul><ul><li><p><code>&lt;tr&gt;</code> <code>&lt;td&gt;</code>标签的使用</p><ul><li><p><code>&lt;tr&gt;</code>行标签：</p><ul><li><code>&lt;tr&gt;</code>可以定义表格中的一行，一个&lt;<code>tr&gt;&lt;/tr&gt;</code>表示一行。</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line"> &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line"> &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr&gt;</span><br><span class="line"> &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line"> &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;td&gt;</code>单元格标签:</p><ul><li><code>&lt;td&gt;</code>可以定义表格中的一个单元格，<code>&lt;td&gt;&lt;/td&gt;</code>表示一个单元格。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td &gt;姓名&lt;/td&gt;</span><br><span class="line">&lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">&lt;td&gt;爱好&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li><li><code>border-collapse</code> 属性设置是否将表格边框折叠为单一边框：</li><li><code>border-collapse:collapse</code>;</li><li><code>colspan</code>左右合并</li><li><code>rowspan</code>上下合并</li></ul></li></ul><p><strong>第一部分总结</strong>：</p><ul><li><p>非可视化标签：<code>head</code>  <code>meta</code>  <code>style</code>  <code>scrpit.</code>..</p></li><li><p>可视化标签：<code>img</code>  <code>div</code> <code>span</code> <code>a</code> <code>ul</code> <code>li</code>…</p></li><li><p>只有可视化标签，才能用<code>css</code>改变它</p></li><li><p>单标签：<code>meta</code>  <code>link</code>  <code>base</code>  <code>img</code>  <code>input</code> <code>br</code> <code>hr</code></p></li><li><p>双标签：<code>html</code> <code>head</code> <code>body</code>  <code>div</code>  <code>a</code>  <code>p</code>  <code>span</code> ..<code>ul</code> <code>li</code> <code>ol</code> <code> dl</code> ….</p></li><li><p><strong>常用可视化标签</strong></p></li><li><p>** <code>div</code>**</p><pre><code>  - 一般用它来布局</code></pre><ul><li><strong>a</strong>  超链接标签<ul><li><code>href</code>*属性：设置跳转的网页地址</li><li><code>target</code>属性：设置跳转的目标</li><li>结论：凡事页面可以点击跳转或者表单提交的文字，都用<code>a</code>标签</li></ul></li><li><strong><code>img</code></strong><ul><li><code>src</code>*属性用来设置图片的url数据</li><li><code>alt</code>提供给搜索引擎搜索的</li><li><code>width</code></li><li><code>height</code></li><li>结论 ：显示图片</li></ul></li><li><strong>ul li</strong><ul><li>列表</li><li>结论：只要将来设计页面中有固定样式的列表，就用ul和li</li></ul></li><li><strong><code>table</code> <code>caption</code> <code>tr</code> <code>td (th)</code></strong><ul><li>慢慢已经被淘汰了 被ul li代替</li><li>如果是合并竖排的就是合并行（<code>rowspan</code>）</li><li>如果是合并横排的就是合并列（<code>colspan</code>）</li></ul></li></ul></li></ul><hr><p><strong>HTML部分导图总结</strong></p><hr><ul><li><a href="http://www.html5star.com/manual/html5label-meaning/">HTML5标签集合</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111641350.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111641731.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111641888.jpeg"></p><hr><h3 id="第二部分-CSS"><a href="#第二部分-CSS" class="headerlink" title="第二部分 CSS"></a>第二部分 CSS</h3><hr><h4 id="第八章-css基础知识"><a href="#第八章-css基础知识" class="headerlink" title="第八章 css基础知识"></a>第八章 css基础知识</h4><hr><ul><li><p><code>css</code>基础知识：</p><ul><li><code>css</code>样式表的定义</li><li><code>css</code>：（Cascading Style Sheets）层叠样式表；</li></ul></li><li><p>分类及位置：内部样式<code>-head</code>区域<code>style</code>标签里面</p><ul><li>外部样式-<code>link</code>调用</li><li>内联样式-标签元素里面</li></ul></li><li><p><code>css</code>内的注释：/<code>*</code>注释内容<code>*</code>/</p></li><li><p><code>css</code>样式表的语法</p><ul><li><p><code>CSS</code>规则由两个主要的部分构成：要添加样式的盒子名或者标签名、和要添加的样式。</p></li><li><p>盒子名或者标签名{属性:值;}</p></li><li><p><strong>CSS中几种颜色的表示方法</strong></p><ul><li><strong>用颜色名表示</strong><ul><li>有17个预先确定的颜色，它们是<ul><li><code>aqua</code>, <code>black</code>, <code>blue</code>, <code>fuchsia</code>, <code>gray</code>, <code>green</code>, <code>lime</code>, <code>maroon</code>, <code>navy</code>,<br>　　<code>olive</code>, <code>orange,</code> <code>purple</code>, <code>red</code>, <code>silver</code>, <code>teal</code>, <code>white</code>, and <code>yellow</code></li></ul></li></ul></li></ul></li><li><p><strong>用十六进制的颜色值表示(红、绿、蓝)</strong></p><ul><li><code>#FF0000</code>或者<code>#F00 </code></li></ul></li><li><p><strong>用rgb(r,g,b)函数表示</strong></p><ul><li>如：<code>rgb(255,255,0)</code></li></ul></li><li><p><strong>用hsl(Hue,Saturation,Lightness)函数表示（色调、饱和度、亮度)</strong></p><ul><li>如：<code>hsl(120,100%,100%)</code>,色调0代表红色，<code>120</code>代表绿色，<code>240</code>代表<br>蓝色</li></ul></li><li><p>**用<code>rgba(r,g,b,a)</code>函数表示 **</p><ul><li>其中<code>a</code>表示的是改颜色的透明度，取值范围是<code>0~1</code>，其中<code>0</code>代表完全透明</li></ul></li><li><p><strong>用hsla(Hue,Saturation,Lightness,alpha)函数表示</strong></p><ul><li>色调、饱和度、亮度、透明度</li></ul></li><li><p>例子</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute;top:0px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:gray;&quot;</span>&gt;</span>background-color:gray<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#F00;&quot;</span>&gt;</span>background-color:#F00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#ffff00;&quot;</span>&gt;</span>background-color:#ffff00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:rgb(255,0,255);&quot;</span>&gt;</span>background-color:rgb(255,0,255)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:hsl(120,80%,50%);&quot;</span>&gt;</span>background-color:hsl(120,80%,50%)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:rgba(255,0,255,0.5);&quot;</span>&gt;</span>background-color:rgba(255,0,255,0.5)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:hsla(120,80%,50%,0.5);&quot;</span>&gt;</span>background-color:hsla(120,80%,50%,0.5)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111642323.png"></p><ul><li>内部样式表<ul><li>当单个页面需要设置样式时，就应该使用内部样式表。</li><li>使用 <code>&lt;style&gt;&lt;/style&gt;</code>标签在文档<code>&lt;head&gt;&lt;/head&gt;</code>里面定义内部样式表</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;style type=&quot;text/css&quot; &gt;</span><br><span class="line">  p&#123;color:red;&#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><ul><li><p>从外部引入到样式分为两种：（注意写在<code>head</code>标签里面）</p></li><li><p>当样式需要应用于很多页面时，就需要用到外部样式表，首先需要创建一个<code>css</code>文件，然后引用到我们的页面中。</p></li><li><p><code>Link</code>样式表式：  <code>&lt;link rel=”stylesheet” type=”text/css” href=”my.css”(href表示路径)&gt;  </code></p></li><li><p><code>Html</code>式：  <code>&lt;style type=&quot;text/css&quot;&gt;@import url(&quot;css.css&quot;);&gt;&lt;/style&gt; </code></p></li></ul><ul><li><p>内联样式表（优先级高）</p><ul><li><p>写在标签里面的样式</p></li><li><p>如：<code>&lt;p style=&quot;color:red;&quot;&gt;&lt;/p&gt;</code></p></li></ul></li><li><p>表示给<code>p</code>标签里面的文字颜色设置为红色</p></li><li><p>区别：外链样式与导入样式</p><ul><li><p><code>link</code>标签是属于<code>xhtml</code>范畴，而<code>@import</code>则是<code>css2.1</code>中特有的。<code>link</code>标签除了可以加载<code>CSS</code>外，还可以做很多其它的事情，比如定义<code>RSS</code>，定义<code>rel</code>连接属性等，<code>@import</code>就只能加载<code>CSS</code>了。</p></li><li><p>加载的顺序的区别，<code>link</code>加载的<code>css</code>时，是一种并行(没有尝试是否是这样)加载<code>CSS</code>方式，而<code>@impor</code>则在整个页面加载完成后才加载。</p></li><li><p>兼容性的区别，因<code>@import``CSS2.1</code>才特有的，所以对于不兼容<code>CSS2.1</code>的浏览器来说，无效。</p></li><li><p>在样式控制上(比如动态改变网页的布局时,使用<code>javascript</code>操作<code>DOM</code>)的区别，此时<code>@import</code>就无能为力了。</p></li></ul></li></ul><hr><ul><li><p><strong>样式的优先级补充</strong></p><ul><li>相同权值情况下，<code>CSS</code>样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）：<ul><li><code>内联样式表（标签内部）</code> &gt; <code>嵌入样式表（当前文件中）</code>&gt; <code>外部样式表（外部文件中）</code></li></ul></li></ul></li><li><p>权值不同时，浏览器是根据权值来判断使用哪种<code>css</code>样式的，哪种样式权值高就使用哪种样式</p></li><li><p>层叠优先级是:</p></li><li><p> <code>浏览器缺省</code>&lt; <code>外部样式表</code> &lt; <code>内部样式表</code> &lt; <code>内联样式</code></p></li><li><p>其中样式表又有:<code>类选择器</code> &lt; <code>类派生选择器 </code>&lt;<code> ID选择器</code> &lt; <code>ID派生选择器</code></p></li><li><p>派生选择器以前叫上下文选择器，所以完整的层叠优先级是:</p></li><li><p><code>浏览器缺省</code> &lt;<code> 外部样式表</code> &lt; <code>外部样式表类选择器</code> &lt; <code>外部样式表类派生选择器 </code>&lt; <code>外部样式表ID选择器</code> &lt; <code>外部样式表ID派生选择器 </code>&lt; <code>内部样式表</code> &lt; <code>内部样式表类选择器</code> &lt; <code>内部样式表类派生选择器</code> &lt; <code>内部样式表ID选择器</code> &lt; <code>内部样式表ID派生选择器</code> &lt; <code>内联样式</code>…共<code>12</code>个优先级</p></li><li><p>另外，如果同一个元素在没有其他样式的作用影响下，其<code>Class</code>定义了多个并以空格分开，其优先级顺序为：</p></li><li><p>一个元素同时应用多个<code>class</code>，后定义的优先（即近者优先），加上<code>!important</code>者最优先！</p></li><li><p>选择器权重</p><table><thead><tr><th>选择器</th><th>权重值</th></tr></thead><tbody><tr><td>!important</td><td>infinity（正无穷）</td></tr><tr><td>行间样式</td><td>1000</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>class、属性、伪类选择器</td><td>10</td></tr><tr><td>标签选择器、伪元素选择器</td><td>1</td></tr><tr><td>通配符选择器</td><td>0</td></tr></tbody></table></li></ul><hr><h4 id="第九章-css选择器-上"><a href="#第九章-css选择器-上" class="headerlink" title="第九章 css选择器(上)"></a>第九章 css选择器(上)</h4><p><strong>什么是选择器：css选择器就是要改变样式的对象</strong></p><ul><li><p><code>class</code>选择器：</p><ul><li><code>class</code>类选择器可以重复利用</li><li>选择<code>class</code>命名的元素 以 <code>.</code> 开头   <code>.p1&#123;color:#0f0;&#125;</code> <code>id</code>选择器唯一</li></ul></li><li><p>属性选择器</p><ul><li><code>&#123;属性:值;属性:值;&#125;</code></li><li>例：<code>[name=&#39;value&#39;]&#123;color:red&#125;</code></li></ul></li><li><p>标签选择器</p><ul><li>页面中所有的标签都是一个选择器  如：<code>p&#123;color:red;&#125;</code></li></ul></li><li><p>通配符选择器 <code>*</code></p><ul><li>选择全部的元素 以 <code>*</code> 开头，如: <code>*&#123;color:#0f0;&#125;</code></li></ul></li><li><p><code>ID</code>选择器</p><ul><li>选择<code>id</code>命名的元素 以 <code>#</code> 开头   <code>#p1&#123;color:#0f0;&#125;</code></li></ul></li><li><p>类选择器</p><ul><li><code>class</code>选择器，选择<code>clas</code>命名的元素 以<code>.</code>开头  <code>.first&#123;color:#00f;&#125;</code></li></ul></li><li><p>群组选择器</p><ul><li>选择多个元素,以逗号隔开 <code>#main,.first,span,a,h1&#123;color:red;&#125;</code></li></ul></li><li><p>包含选择器</p><ul><li>选择某元素的后代元素，也称后代选择器，父类与子类间以空格隔开<code>p</code><ul><li><code>span&#123;color:red;&#125;</code></li></ul></li></ul></li><li><p>属性选择器</p><ul><li>选择包含某一属性的元素</li><li><code>a[title]&#123;color:red;&#125;</code>  选择包含<code>title</code>的<code>a</code>标签</li><li><code>a[title][href]&#123;color:red;&#125;</code> 选择包含<code>title</code>和<code>href</code>的<code>a</code>标签</li></ul></li><li><p><code>&gt; </code> <code>+</code> 选择器子类选择器：只选择子元素（只选择儿子）（相当于包含元素）</p><ul><li><code>p &gt; span&#123;color:red;&#125;</code></li></ul></li><li><p>相邻兄弟选择器：只选择后面的相邻兄弟元素</p><ul><li><code>p + span&#123;color:red;&#125;</code></li></ul></li><li><p><code>css</code>代码写完后上线前要经过压缩处理</p></li><li><p>本地和服务器分两个<code>css</code>版本（备份）</p></li><li><p>压缩后注释都清除，空间体积减少</p></li></ul><hr><h4 id="第十章-css选择器-下"><a href="#第十章-css选择器-下" class="headerlink" title="第十章 css选择器(下)"></a>第十章 css选择器(下)</h4><hr><ul><li><p><code>&lt;a&gt;</code>伪类选择器</p><ul><li><p><code>a:link &#123;color:#FF0000;&#125;</code>    /* 超链接未访问时的状态 */ （只用于a标签）</p></li><li><p><code>a:visited &#123;color:#00FF00;&#125;</code>    /* 超链接访问过后的状态 */ （只用于a标签）</p></li><li><p><code>a:hover &#123;color:#FF00FF;&#125;    </code>/* 鼠标悬停状态</p></li><li><p><code>*/</code>（可和其他标签结合一起用）</p></li><li><p><code>a:active &#123;color:#0000FF;&#125;</code>    /* 激活状态，鼠标按下状态 */</p></li><li><p><strong>注意</strong></p><ul><li>伪类选择器的排序很重要，<code>a:link</code> <code>a:visited</code> <code>a:hover</code> <code>a:active</code>，记作<code>lvha</code></li></ul></li></ul></li><li><p>输入伪类选择器（针对表单）</p><ul><li><code>input:focus&#123;color:red;&#125; </code>      /* 键盘输入焦点 */</li></ul></li><li><p>位置伪类选择器（针对表单）</p><ul><li><code>p:first-child&#123;color:red;&#125;</code>     /<code>* 第一个p *</code>/</li><li><code>p:last-child&#123;color:red;&#125;</code>     /<code>* 最后一个p *</code>/</li></ul></li><li><p>伪元素选择器</p><ul><li><code>:before</code> 在元素之前添加内容。</li><li><code>:after</code> 在元素之后添加内容。</li></ul></li><li><p><code>css</code>优先规则</p><ul><li>内联样式表-&gt; <code>ID</code> 选择器—&gt; <code>Class</code> 类选择器-&gt;标签选择器</li></ul></li></ul><hr><h4 id="第十一章-背景属性"><a href="#第十一章-背景属性" class="headerlink" title="第十一章 背景属性"></a>第十一章 背景属性</h4><hr><ul><li><p>背景属性：</p><ul><li><p>背景的添加 ：</p></li><li><p>背景颜色的添加:</p><ul><li><code>background:red;</code></li><li><code>backgronnd-color:red;</code></li></ul></li><li><p>背景图片的添加：</p><ul><li><code>background:url(“images/1.jpg”);</code></li><li><code>backgronnd-image:url(“images/1.jpg”);</code></li></ul></li><li><p>背景的平铺</p></li><li><p>什么是平铺？平铺就是图片是否重复出现</p><ul><li>不平铺：<code>background-repeat:no-repeat;</code></li><li>水平方向平铺：<code>background-repeat:repeat-x;</code></li><li>垂直方向平铺：<code>background-repeat:repeat-y;</code></li><li>完全平铺：默认为完全平铺</li></ul></li><li><p>背景图片的定位</p><ul><li>背景图片的定位就是可以设置显示背景图片的位置，通过属性<code>background-position</code>来实现</li><li><code>background-position</code>的取值可为英文单词或者数值和百分值。</li><li><code>background-positon</code>的英文单词取值</li><li><code>top left </code></li><li><code>top  center  </code></li><li><code>top  right</code></li><li><code>center left  </code></li><li><code>center  center </code></li><li><code>center right</code></li><li><code>bottom left  </code></li><li><code>bottom  center </code></li><li><code>bottom right</code></li><li><code>background-position</code>的数值取值<ul><li><code>background-position:x  y;</code></li></ul></li><li><code>positon</code>的百分值取值<ul><li><code>background-position:x%  y%; </code></li></ul></li></ul></li><li><p>背景图片的大小</p><ul><li><p>背景图片的大小可以通过属性<code>background-size</code>来设置<code>background-size</code>的取值可为数值和百分值。</p></li><li><p><code>background-size</code>的数值取值</p><ul><li><code>background-size:x  y;</code></li></ul></li><li><p><code>background-size</code>的数值取值</p><ul><li><code>background-size:x%  y%;</code></li></ul></li></ul></li><li><p>背景图片的滚动</p><ul><li><p>背景图片是否随着内容的滚动而滚动由<code>background-attachment</code>设置</p></li><li><p><code>background-attachment:fixed; </code>  固定，不随内容的滚动而滚动</p></li><li><p><code>background-attachment:scroll; </code> 滚动，随内容的滚动而滚动</p></li></ul></li></ul></li></ul><hr><h4 id="第十二章-文字文本属性"><a href="#第十二章-文字文本属性" class="headerlink" title="第十二章 文字文本属性"></a>第十二章 文字文本属性</h4><hr><ul><li><code>css</code>文字文本属性：</li><li><strong>文字属性</strong></li><li><code>color:red;</code>    文字颜色<ul><li><code>font-size:12px</code>;    文字大小</li><li><code>font-weight:“bold”</code>    文字粗细(<code>bold/normal</code>)</li><li><code>font-family:“宋体”</code>    文字类别</li><li><code>font-variant:small-caps </code>小写字母以大写字母显示</li></ul></li></ul><ul><li><p><strong>文本属性</strong></p><ul><li><code>text-align:center;</code>   文本对齐(<code>right</code>/<code>left</code>/<code>center</code>)</li><li><code>line-height:10px; </code> 行间距(可通过它实现文本的垂直居中)</li><li><code>text-indent:20px;</code>  首行缩进</li><li><code>text-decoration:none; </code><ul><li>文本线(<code>none</code>/<code>underline</code>/<code>overline</code>/<code>line-through</code>)</li></ul></li><li><code>letter-spacing</code>:   字间距</li></ul></li></ul><hr><h4 id="第十三章-盒子模型"><a href="#第十三章-盒子模型" class="headerlink" title="第十三章 盒子模型"></a>第十三章 盒子模型</h4><hr><ul><li><p><strong>盒子模型</strong></p><ul><li>盒子模型就是一个有高度和宽度的矩形区域</li><li>所有<code>html</code>标签都是盒子模型</li><li><code>div</code>标签自定义盒子模型</li></ul></li><li><p>所有的标签都是盒子模型</p><ul><li><code>class</code>和<code>id</code>的主要差别是：<code>class</code>用于元素组（类似的元素，或者可以理解为某一类元素），而<code>id</code>用于标识单独的唯一的元素。</li></ul></li><li><p><strong>盒子模型的组成</strong></p><ul><li>盒子模型组成部分：<ul><li>自身内容：<code> width</code>、h<code>eight</code> 宽高</li><li>内边距：   <code>padding</code></li><li>盒子边框： <code>border</code> 边框线</li><li>与其他盒子距离：  <code>margin </code>外边距</li><li>内容+内边距+边框+外边距=面积</li></ul></li></ul></li><li><p><code>border</code> 边框</p><ul><li>常见写法  <code>border:1px solid #f00;</code></li></ul></li><li><p>单独属性：</p></li><li><p><code>border-width</code>:</p></li><li><p><code>border-style:</code></p><ul><li><code>dotted </code> 点状虚线</li><li><code>dashed</code>（虚线）</li><li><code>solid</code>（实线）</li><li><code>double</code>（双实线）</li></ul></li><li><p><code>border-color</code> (颜色)</p></li><li><p><code>padding</code> 内边距</p><ul><li><p>值：<code>像素</code>/<code>厘米</code>等长度单位、百分比</p><ul><li><code>padding:10px; </code>                      上下左右</li><li><code>padding:10px 10px; </code>                 上下  左右</li><li><code>padding:10px 10px 10px; </code>         上 左右 下</li><li><code>padding:10px 10px 10px 10px; </code> 上 右 下 左（设置4个点–&gt;顺时针方向）</li></ul></li></ul></li><li><p>单独属性：</p><ul><li><code>padding-top:</code></li><li><code>padding-right:</code></li><li><code>padding-bottom:</code></li><li><code> padding-left:</code></li></ul></li><li><p>当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据<code>width</code>和<code>height</code>减小</p></li><li><p>margin 外边距</p><ul><li><p>值：与<code>padding</code>相同</p></li><li><p>单独属性：与<code>padding</code>相同</p></li></ul></li><li><p>外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并</p></li></ul><hr><p><strong>补充盒子模型内容</strong></p><hr><ul><li><p><strong>标准盒子模型</strong></p></li><li><p>盒子模型是<code>css</code>中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 <code>ie </code>盒子模型和标准 <code>w3c</code> 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111642126.jpeg"></p><ul><li><p>从上图可以看到标准 <code>w3c</code> 盒子模型的范围包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>，并且 <code>content </code>部分不包含其他部分</p></li><li><p>** IE盒子模型**</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111642885.jpeg"></p><ul><li><p>从上图可以看到 <code>ie </code>盒子模型的范围也包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code></p></li><li><p>和标准 <code>w3c</code> 盒子模型不同的是：<code>ie</code> 盒子模型的 <code>content</code> 部分包含了 <code>border </code>和 <code>padding</code></p></li><li><p><code>IE</code>盒子模型<code>width</code> = <code>padding</code>+<code>border</code>+<code>内容</code></p></li><li><p>标准盒子模型 = 内容的宽度（不包含<code>border</code>+<code>padding</code>）</p></li><li><p>例：</p></li><li><p>一个盒子的   <code>margin</code>为 20px，<code>border</code> 为 1px，<code>padding </code>为 10px，<code>content</code> 的宽为 200px、高为 50px，假如用标准 <code>w3c</code> 盒子模型解释，那么这个盒子需要占据的位置为：宽 <code>20*2+1*2+10*2+200=262px</code>、高 <code>20*2+1*2*10*2+50=112px</code>，盒子的实际大小为：宽 <code>1*2+10*2+200=222px</code>、高 <code>1*2+10*2+50=72px</code>；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 <code>20*2+200=240px</code>、高 <code>20*2+50=70px</code>，盒子的实际大小为：宽 <code>200px</code>、高 <code>50px</code></p></li><li><p>那应该选择哪中盒子模型呢？当然是“标准 <code>w3c</code> 盒子模型”了。怎么样才算是选择了“标准 <code>w3c </code>盒子模型”呢？很简单，就是在网页的顶部加上 <code>doctype</code> 声明。</p></li><li><p>假如不加<code> doctype</code> 声明，那么各个浏览器会根据自己的行为去理解网页，即 <code>ie </code>浏览器会采用 <code>ie</code> 盒子模型去解释你的盒子，而 <code>ff </code>会采用标准<code> w3c</code> 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。</p></li><li><p>反之，假如加上了 <code>doctype</code> 声明，那么所有浏览器都会采用标准 <code>w3c </code>盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。</p></li></ul><hr><ul><li>用 <code>jquery</code> 做的例子来证实一下</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;你用的盒子模型是？&lt;/title&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;</span><br><span class="line">document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>　上面的代码没有加上 <code>doctype</code> 声明，在 <code>ie</code> 浏览器中显示  <code>ie</code>盒子模型，在 ff 浏览器中显示“标准<code>w3c</code> 盒子模型”。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;你用的盒子模型是标准w3c盒子模型&lt;/title&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;</span><br><span class="line">document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>　代码2 与代码1 唯一的不同的就是顶部加了 <code>doctype </code>声明。在所有浏览器中都显示“标准 <code>w3c </code>盒子模型”</li></ul><ul><li><p> 所以为了让网页能兼容各个浏览器，让我们用标准 <code>w3c</code> 盒子模型</p></li><li><p>扩展</p><ul><li><a href="http://www.jianshu.com/p/e2eb0d8c9de6">学会使用box-sizing布局</a></li></ul></li></ul><hr><h4 id="第十四章-块元素、行元素与溢出"><a href="#第十四章-块元素、行元素与溢出" class="headerlink" title="第十四章 块元素、行元素与溢出"></a>第十四章 块元素、行元素与溢出</h4><hr><ul><li><p>基本概念</p><ul><li>块级元素：默认情况下独占一行的元素，可控制宽高、上下边距；</li><li>行内元素：默认情况下一行可以摆放多个的元素，不可控制宽高和上下边距</li></ul></li><li><p>行块转换</p><ul><li><code>display:none</code>;  不显示</li><li><code>display:block</code>; 变成块级元素</li><li><code>display:inline</code>; 变成行级元素</li><li><code>display:inline-block</code>; 以块级元素样式展示，以行级元素样式排列，称行级块元素</li></ul></li><li><p>溢出</p><ul><li><code>overflow:hidden</code>;   溢出隐藏</li><li><code>overflow:scroll</code>;   内容会被修剪，浏览器会显示滚动条</li><li><code>overflow:auto</code>;   如果内容被修剪，则产生滚动条</li></ul></li><li><p>文本不换行：<code>white-space:nowrap</code>;</p></li><li><p>长单词换行：<code>word-wrap:break-word</code>;</p></li></ul><ul><li>行内元素和快级元素小结</li></ul><ul><li><p>一、<strong>块级元素</strong>：block element</p><ul><li>每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（<code>float</code>浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；</li><li>块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。</li></ul></li><li><p><code>DIV</code> 是最常用的块级元素，元素样式的<code>display:block</code>都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。</p></li><li><p>二、<strong>行内元素</strong>：inline element</p><ul><li>也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 <code>SPAN </code>元素，<code>IFRAME</code>元素和元素样式的<code>display : inline</code>的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。</li></ul></li><li><p>三、<strong>行级块元素</strong>：inline-block</p><ul><li>也叫行级块元素，常见的元素有img，它是随着内容的宽高改变</li></ul></li><li><p>四、<strong>block（块）元素的特点:</strong></p><ul><li>①、总是在新行上开始；</li><li>②、高度，行高以及外边距和内边距都可控制；</li><li>③、宽度缺省是它的容器的100%，除非设定一个宽度。</li><li>④、它可以容纳内联元素和其他块元素</li></ul></li><li><p>五、<strong>inline元素的特点</strong></p><ul><li>①、和其他元素都在一行上；</li><li>②、高，行高及外边距和内边距不可改变；</li><li>③、宽度就是它的文字或图片的宽度，不可改变</li><li>④、内联元素只能容纳文本或者其他内联元素（行元素）</li></ul></li><li><p>六、inline-block元素的特点</p><ul><li>①、和其它元素都在一行</li><li>宽高行高等等可以改变</li><li>宽高是内容的宽高，但是可以改变</li><li>可以容纳行级元素和块级元素</li></ul></li><li><p><strong>对行内元素，需要注意如下</strong>:</p><ul><li>设置宽度<code>width</code> 无效。 设置高度<code>height </code>无效，可以通过<code>line-height</code>来设置。 设置<code>margin</code></li><li>只有左右<code>margin</code>有效，上下无效。</li><li>设置<code>padding</code>只有左右<code>padding</code>有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。</li></ul></li><li><p>七、<strong>常见的块状元素</strong></p><ul><li><code>address</code> – 地址</li><li><code>blockquote</code> – 块引用</li><li><code>center</code> – 举中对齐块</li><li><code>dir</code> – 目录列表</li><li><code>div</code> – 常用块级容易，也是<code>CSS layout</code>的主要标签</li><li><code>dl</code> – 定义列表</li><li><code>fieldset</code> – <code>form</code>控制组</li><li><code>form</code> – 交互表单</li><li><code>h1</code> – 大标题</li><li><code>h2</code> – 副标题</li><li><code>h3</code> – 3级标题</li><li><code>h4</code> – 4级标题</li><li><code>h5</code> – 5级标题</li><li><code>h6</code> – 6级标题</li><li><code>hr</code> – 水平分隔线</li><li><code>isindex</code> – <code>input prompt</code></li><li><code>menu</code> – 菜单列表</li><li><code>noframes</code> – <code>frames</code>可选内容，（对于不支持frame的浏览器显示此区块内容</li><li><code>noscript</code> – 可选脚本内容（对于不支持<code>script</code>的浏览器显示此内容）</li><li><code>ol</code> – 有序表单</li><li><code>p</code> – 段落</li><li><code>pre</code> – 格式化文本</li><li><code>table</code> – 表格</li><li><code>ul</code> – 无序列表</li></ul></li><li><p>八、<strong>常见的内联元素</strong></p><ul><li><code>a</code> – 锚点</li><li><code>abbr</code> – 缩写</li><li><code>acronym</code> – 首字</li><li><code>b</code> – 粗体(不推荐)</li><li><code>bdo</code> – <code>bidi override</code></li><li><code>big</code> – 大字体</li><li><code>br</code> – 换行</li><li><code>cite</code> – 引用</li><li><code>code</code> – 计算机代码(在引用源码的时候需要)</li><li><code>dfn</code> – 定义字段</li><li><code>em</code> – 强调</li><li><code>font</code> – 字体设定(不推荐)</li><li><code>i</code> – 斜体</li><li><code>img</code> – 图片</li><li><code>input</code> – 输入框</li><li><code>kbd</code> – 定义键盘文本</li><li><code>label</code> – 表格标签</li><li><code>q</code> – 短引用</li><li><code>s</code> – 中划线(不推荐)</li><li><code>samp</code> – 定义范例计算机代码</li><li><code>select</code> – 项目选择</li><li><code>small</code> – 小字体文本</li><li><code>span</code> – 常用内联容器，定义文本内区块</li><li><code>strike</code> – 中划线</li><li><code>strong</code> – 粗体强调</li><li><code>sub</code> – 下标</li><li><code>sup</code> – 上标</li><li><code>textarea</code> – 多行文本输入框</li><li><code>tt</code> – 电传文本</li><li><code>u</code> – 下划线</li></ul></li><li><p>九，<strong>可变元素</strong></p><ul><li>可变元素为根据上下文语境决定该元素为块元素或者内联元素。</li><li><code>applet</code> - <code>java applet</code></li><li><code>button</code> - 按钮</li><li><code>del </code>- 删除文本</li><li><code>iframe</code> - <code>inline frame</code></li><li><code>ins</code> - 插入的文本</li><li><code>map</code> - 图片区块(<code>map</code>)</li><li><code>object</code> - <code>object</code>对象</li><li><code>script</code> - 客户端脚本</li></ul></li><li><p>十、<strong>行内元素与块级元素有什么不同</strong></p><ul><li><p>区别一：</p><ul><li>块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度</li><li>行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。</li></ul></li><li><p>区别二：</p><ul><li>块级：块级元素可以设置宽高</li><li>行内：行内元素不可以设置宽高</li></ul></li><li><p>区别三：</p><ul><li>块级：块级元素可以设置<code>margin</code>，<code>padding</code></li><li>行内：行内元素水平方向的<code>margin-left;</code> <code>margin-right;</code></li></ul></li><li><p><code>padding-left;</code> <code>padding-right</code>;可以生效。但是竖直方向的<code>margin-bottom</code>; <code>margin-top</code>; <code>padding-top</code>; <code>padding-bottom</code>;却不能生效。</p></li><li><p>区别四：</p></li><li><p>块级：<code>display:block</code>;</p></li><li><p>行内：<code>display:inline</code>;</p></li><li><p>替换元素有如下：（和<code>img</code>一样的设置方法）</p></li><li><p><code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code></p></li><li><p><code>&lt;object&gt;</code>都是替换元素，这些元素都没有实际的内容</p></li></ul></li><li><p>可以通过修改<code>display</code>属性来切换块级元素和行内元素</p></li></ul><hr><h4 id="第十五章-定位"><a href="#第十五章-定位" class="headerlink" title="第十五章 定位"></a>第十五章 定位</h4><hr><ul><li><strong>position 属性</strong><ul><li>值：</li><li>**static **静态定位（不对它的位置进行改变，在哪里就在那里）<ul><li> 默认值。没有定位，元素出现在正常的流中（忽略 <code>top</code>,<code> bottom,</code>  <code>left, right</code> 或者 <code>z-index</code> 声明）。</li></ul></li><li><strong>fixed</strong> 固定定位（参照物–浏览器窗口）—做 弹窗广告用到<ul><li>生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 <code>&quot;left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot; </code>以及 <code>&quot;bottom&quot; </code>属性进行规定。</li></ul></li><li><strong>relative</strong>（相对定位 ）（参照物以他本身）<ul><li>生成相对定位的元素，相对于其正常位置进行定位。</li></ul></li><li><strong>absolute</strong>（绝对定位）(除了<code>static</code>都可以，找到参照物–&gt;与它最近的已经有定位的父元素进行定位)</li><li>生成绝对定位的元素，相对于 <code>static</code> 定位以外的第一个父元素进行定位。</li><li>元素的位置通过 “<code>left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot;</code> 以及 <code>&quot;bottom&quot;</code> 属性进行规定</li><li><strong>z-index</strong><ul><li><code>z-index</code> 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</li><li>定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</li></ul></li><li>一切皆为框<ul><li>块级元素: <code>div</code>、<code>h1</code>或<code>p</code>元素 即：显示为一块内容称之为 “块框“ ;</li><li>行内元素: <code>span</code>,<code>strong</code>,<code>a</code>等元素 即：内容显示在行中称 “行内框”;</li><li>使用display属性改变成框的类型 即：<code>display:block</code>; 让行内元素设置为块级元素，<code>display:none;</code> 没有框</li></ul></li><li>相对定位：<ul><li>如果对一个元素进行相对定位，它将出现在它所在的位置上。</li><li>通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动</li><li><code>.adv_relative &#123;  position: relative;  left: 30px;  top: 20px; &#125;</code></li></ul></li><li>绝对定位：<ul><li>元素的位置相对于最近的已定位祖先元素，如果元素没有已定位 的祖先元素，它的位置相对于最初的包含块。 <code>.adv_absolute &#123;  position: absolute;  left: 30px;  top: 20px; &#125;</code></li></ul></li></ul></li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111643217.png"><br><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111642515.png"></p><hr><h4 id="第十六章-框架"><a href="#第十六章-框架" class="headerlink" title="第十六章 框架"></a>第十六章 框架</h4><hr><ul><li><p><code>frameset</code>框架：</p><ul><li><code>&lt;frameset&gt; </code> —-  用来定义一个框架；双标签<br>不能和  <code>&lt;body&gt;</code>  一起使用</li></ul></li><li><p><code>rows</code>、<code>cols</code>属性</p><ul><li><code>rows </code> 定义行表示框架有多少行（取值 <code>px </code>/<code>%</code>/ <code>*</code> ）</li><li><code>cols</code>   定义列表示框架有多少列（取值<code>px</code>/ <code>% </code>/ <code>*</code> ）</li></ul></li><li><p>frame子框架</p><ul><li>&lt;<code>frame</code>&gt;  —-  表示框架中的某一个部分；单标签，要跟结束标志<ul><li><code>src</code> 显示的网页的路径</li><li><code>name</code> 框架名</li><li><code>frameborder</code>  边框线（取值 0 / 1）</li></ul></li></ul></li><li><p>&lt;<code>noframes</code>&gt;属性</p></li><li><p>&lt;<code>noframes</code>&gt; 提供不支持框架的浏览器显示<code>body</code>的内容；双标签</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;frameset&gt;</span><br><span class="line">     &lt;frame  src=“”  /&gt;</span><br><span class="line">     &lt;frame  src=“” /&gt;</span><br><span class="line">     &lt;frame  src=“” /&gt;</span><br><span class="line">     &lt;noframes&gt;</span><br><span class="line">      &lt;body&gt;内容&lt;/body&gt;</span><br><span class="line">     &lt;/noframes&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;iframe&gt;</code>内联框架<ul><li><code>iframe </code>元素会创建包含另外一个文档的内联框架（即行内框架）</li><li>允许和 <code>body</code> 一起使用</li><li><code>width</code> 宽（取值 px / %）</li><li><code>height</code> 高（取值 px / %）</li><li><code>name</code> 框架名</li><li><code>frameborder </code> 边框线（取值 0 / 1）</li><li><code>src</code> 显示的网页的路径</li></ul></li></ul><hr><h4 id="第十七章-css高级属性"><a href="#第十七章-css高级属性" class="headerlink" title="第十七章 css高级属性"></a>第十七章 css高级属性</h4><hr><ul><li><code>opacity</code>透明属性</li><li><code>opacity</code><ul><li>对于<code>IE6/7/</code>，使用<code>filter:alpha(opacity:值;</code>)  值为<code>0-100</code></li><li>对于<code>Webkit</code>，<code>Opera</code>，<code>Firefox</code>，<code>IE9+</code>，使用<code>opacity</code>:值; 值为<code>0-1</code></li><li>对于早期火狐，使用<code>-moz-opacity</code>:值; 值为<code>0-1</code></li><li>所以写透明属性时，一般写法是</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    opacity:0.5;</span><br><span class="line">   filter:alpha(opacity：50);/*0-100*/</span><br><span class="line">   -moz-opacity:0.5;/*取值0-1*/--&gt;针对早起版本的火狐兼容问题的解决</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>border-radius</code>圆角边框属性</p><ul><li>向 <code>div</code> 元素添加圆角边框<ul><li><code>border-radius:10px</code>;</li></ul></li></ul></li><li><p><code>box-shadow</code>阴影属性</p><ul><li><p><code>box-shadow </code>属性向框添加阴影效果,后面跟4个参数。</p></li><li><p><code>box-shadow:0px   0px   10px   #000;</code></p></li></ul></li><li><p><code>&lt;embed&gt;</code>属性</p><ul><li><p>是<code>HTML5</code>中新增的标签,媒体嵌入插件标签，可以通过<code>&lt;embed&gt;</code>插入音频或视频</p></li><li><p><code>&lt;embed src=“media/music.mp3” /&gt;</code></p></li><li><p>格式<code>.mid </code> <code>.wav</code> <code>.mp3</code>等</p></li></ul></li></ul><hr><hr><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111643657.png"></p><hr><ul><li><a href="https://yunpan.cn/cM9va2bHD4wwu">原文件下载地址</a>   访问密码 342a</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111644068.png"></p><hr><ul><li><code>css</code>常见简写</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111644519.png" alt="css简写速查"></p><hr><h3 id="第三部分-附录"><a href="#第三部分-附录" class="headerlink" title="第三部分 附录"></a>第三部分 附录</h3><hr><h4 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h4><blockquote><p>为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合W3C的代码写到一个文件中,而一些IE中必须而又不能通过W3C验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 放置所有浏览器样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE]</span></span><br><span class="line"><span class="comment">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p>CSS样式新建或修改尽量遵循以下原则</p><p>根据新建样式的适用范围分为三级：全站级、产品级、页面级。 尽量通过继承和层叠重用已有样式。 不要轻易改动全站级CSS。改动后，要经过全面测试。</p><hr><ul><li><p>属性显示顺序（规范写法）</p><ul><li>显示属性</li><li>元素位置</li><li>元素属性</li><li>元素内容属性</li></ul></li><li><p>CSS书写顺序</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="selector-class">.header</span> &#123;</span><br><span class="line"><span class="comment">/* 显示属性 */</span></span><br><span class="line">    <span class="attribute">display</span> || <span class="attribute">visibility</span></span><br><span class="line">    <span class="attribute">list-style</span></span><br><span class="line">    <span class="attribute">position</span> <span class="attribute">top</span> || <span class="attribute">right</span> || <span class="attribute">bottom</span> || <span class="attribute">left</span></span><br><span class="line">    <span class="attribute">z-index</span></span><br><span class="line">    <span class="attribute">clear</span></span><br><span class="line">    <span class="attribute">float</span></span><br><span class="line"><span class="comment">/* 自身属性 */</span></span><br><span class="line">    <span class="attribute">width</span> <span class="attribute">max-width</span> || <span class="attribute">min-width</span></span><br><span class="line">    <span class="attribute">height</span> <span class="attribute">max-height</span> || <span class="attribute">min-height</span></span><br><span class="line">    <span class="attribute">overflow</span> || <span class="attribute">clip</span></span><br><span class="line">    <span class="attribute">margin</span></span><br><span class="line">    <span class="attribute">padding</span></span><br><span class="line">    <span class="attribute">outline</span></span><br><span class="line">    <span class="attribute">border</span></span><br><span class="line">    <span class="attribute">background</span></span><br><span class="line"><span class="comment">/* 文本属性 */</span></span><br><span class="line">    <span class="attribute">color</span></span><br><span class="line">    <span class="attribute">font</span></span><br><span class="line">    <span class="attribute">text-overflow</span></span><br><span class="line">    <span class="attribute">text-align</span></span><br><span class="line">    <span class="attribute">text-indent</span></span><br><span class="line">    <span class="attribute">line-height</span></span><br><span class="line">    <span class="attribute">white-space</span></span><br><span class="line">    <span class="attribute">vertical-align</span></span><br><span class="line">    <span class="attribute">cursor</span></span><br><span class="line">    <span class="attribute">content</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li><li><p>兼容多个浏览器时，将标准属性写在底部</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-moz-border-radius: 15px; /* Firefox */</span><br><span class="line">-webkit-border-radius: 15px; /* Safari和Chrome */</span><br><span class="line">border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性</span><br></pre></td></tr></table></figure><ul><li>使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式</li></ul><p><code>.hd,.bd,.td&#123;&#125;;//如这些命名</code></p><ul><li>可用上级节点进行限定</li></ul><p><code>.recommend-mod .hd</code></p><ul><li>多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-class">.btn</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-class">.btn</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span> &#123;…&#125;;</span><br></pre></td></tr></table></figure><ul><li>优化CSS选择器</li></ul><p><code>#header a &#123; color: #444; &#125;;/*CSS选择器是从右边到左边进行匹配*/</code></p><p>浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器</span><br><span class="line">不要限定id选择符，如<span class="selector-tag">div</span><span class="selector-id">#header</span>（提权的除外）</span><br><span class="line">不要限定类选择器，如<span class="selector-tag">ul</span><span class="selector-class">.recommend</span>（提权的除外）</span><br><span class="line">不要使用 <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> 这样长的选择符</span><br><span class="line">避免使用标签子选择符，如<span class="selector-id">#header</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。 尽量避免使用CSS Hack</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">property:value; <span class="comment">/* 所有浏览器 */</span></span><br><span class="line">+property:value; <span class="comment">/* IE7 */</span></span><br><span class="line">_property:value; <span class="comment">/* IE6 */</span></span><br><span class="line">*property:value; <span class="comment">/* IE6/7 */</span></span><br><span class="line">property:value\<span class="number">9</span>; <span class="comment">/* IE6/7/8/9，即所有IE浏览器 */</span></span><br><span class="line"></span><br><span class="line">\* <span class="selector-tag">html</span> selector &#123; … &#125;; <span class="comment">/* IE6 */</span></span><br><span class="line">\*<span class="selector-pseudo">:first</span>-child+<span class="selector-tag">html</span> selector &#123; … &#125;; <span class="comment">/* IE7 */</span></span><br><span class="line"><span class="selector-tag">html</span>&gt;<span class="selector-tag">body</span> selector &#123; … &#125;; <span class="comment">/* 非IE6 */</span></span><br><span class="line"><span class="keyword">@-moz-document</span> url-prefix() &#123; … &#125;; <span class="comment">/* firefox */</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; … &#125;; <span class="comment">/* saf3+/chrome1+ */</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">10000</span>),<span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; … &#125;; <span class="comment">/* opera */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-device-width</span>: <span class="number">480px</span>) &#123; … &#125;; <span class="comment">/* iPhone/mobile webkit */</span></span><br></pre></td></tr></table></figure><p>避免使用低效的选择器</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; * &#123;…&#125;;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">a</span> &#123;…&#125;;</span><br><span class="line"><span class="selector-id">#footer</span> &gt; <span class="selector-tag">h3</span> &#123;…&#125;;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-id">#top_blue_nav</span> &#123;…&#125;;</span><br><span class="line"><span class="selector-id">#searbar</span> <span class="selector-tag">span</span><span class="selector-class">.submit</span> <span class="selector-tag">a</span> &#123; … &#125;; <span class="comment">/* 反面示例 */</span></span><br></pre></td></tr></table></figure><p>六个不要三个避免一个使用</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">不要在标签上直接写样式</span><br><span class="line">不要在CSS中使用expression</span><br><span class="line">不要在CSS中使用<span class="keyword">@import</span></span><br><span class="line">不要在CSS中使用!important</span><br><span class="line">不要在CSS中使用“*”选择符</span><br><span class="line">不要将CSS样式写为单行</span><br><span class="line">避免使用filter</span><br><span class="line">避免使用行内（inline）样式</span><br><span class="line">避免使用“*”设置&#123;<span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line">使用after或<span class="attribute">overflow</span>的方式清浮动</span><br></pre></td></tr></table></figure><p>减少使用影响性能的属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position:absolute;</span><br><span class="line">float:left;//如这些定位或浮动属性</span><br></pre></td></tr></table></figure><p>减少在CSS中使用滤镜表达式和图片repeat,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px</p><hr><h4 id="DIV命名规范"><a href="#DIV命名规范" class="headerlink" title="DIV命名规范"></a>DIV命名规范</h4><hr><ul><li><p>企业<code>DIV</code>使用频率高的命名方法</p></li><li><p><strong>网页内容类</strong></p><ul><li><p>标题: <code>title</code></p><ul><li>摘要: <code>summary</code></li><li>箭头： <code>arrow</code></li><li>商标： <code>label</code></li><li>网站标志： <code>logo</code></li><li>转角/圆角：<code> corner</code></li><li>横幅广告： <code>banner</code></li><li>子菜单： <code>subMenu</code></li><li>搜索： <code>search</code></li><li>搜索框： <code>searchBox</code></li><li>登录： <code>login</code></li><li>登录条：<code>loginbar</code></li><li>工具条： <code>toolbar</code></li><li>下拉： <code>drop</code></li><li>标签页： <code>tab</code></li><li>当前的： <code>current</code></li><li>列表： <code>list</code></li><li>滚动： <code>scroll</code></li><li>服务： <code>service</code></li><li>提示信息： <code>msg</code></li><li>热点：<code>hot</code></li><li>新闻： <code>news</code></li><li>小技巧： <code>tips</code></li><li>下载： <code>download</code></li><li>栏目标题： <code>title</code></li><li>热点： <code>hot</code></li><li>加入：<code> joinus</code></li><li>注册： <code>regsiter</code></li><li>指南： <code>guide</code></li><li>友情链接： <code>friendlink</code></li><li>状态： <code>status</code></li><li>版权： <code>copyright</code></li><li>按钮： <code>btn</code></li><li>合作伙伴： <code>partner</code></li><li>投票： <code>vote</code></li><li>左右中：<code>left</code>  <code>right</code>  <code>center</code></li></ul><hr></li><li><p>注释的写法: <code>/* Footer */ </code> 内容区<code>/* End Footer */</code></p></li></ul></li><li><p><strong>id的命名:</strong></p><ul><li><p>页面结构</p><ul><li>容器: <code>container</code></li><li>页头：<code>header</code></li><li>内容：<code>content</code>/<code>container</code></li><li>页面主体：<code>main</code></li><li>页尾：<code>footer</code></li><li>导航：<code>nav</code></li><li>侧栏：<code>sidebar</code></li><li>栏目：<code>column</code></li><li>页面外围控制整体布局宽度：<code>wrapper</code></li><li>左右中：<code>left</code> <code>right</code> <code>center</code></li></ul></li></ul><hr><ul><li><p>导航</p><ul><li>导航：<code>nav</code></li><li>主导航：<code>mainbav</code></li><li>子导航：<code>subnav</code></li><li>顶导航：<code>topnav</code></li><li>边导航：<code>sidebar</code></li><li>左导航：<code>leftsidebar</code></li><li>右导航：<code>rightsidebar</code></li><li>菜单：<code>menu</code></li><li>子菜单：<code>submenu</code></li><li>标题: <code>title</code></li><li>摘要: <code>summary</code></li></ul></li></ul><hr><ul><li><p>功能</p><ul><li>标志：<code>logo</code></li><li>广告：<code>banner</code></li><li>登陆：<code>login</code></li><li>登录条：<code>loginbar</code></li><li>注册：<code>regsiter</code></li><li>搜索：<code>search</code></li><li>功能区：<code>shop</code></li><li>标题：<code>title</code></li><li>加入：<code>joinus</code></li><li>状态：<code>status</code></li><li>按钮：<code>btn</code></li><li>滚动：<code>scroll</code></li><li>标签页：<code>tab</code></li><li>文章列表：<code>list</code></li><li>提示信息：<code>msg</code></li><li>当前的:<code> current</code></li><li>小技巧：<code>tips</code></li><li>图标: <code>icon</code></li><li>注释：<code>note</code></li><li>指南：<code>guild</code></li><li>服务：<code>service</code></li><li>热点：<code>hot</code></li><li>新闻：<code>news</code></li><li>下载：<code>download</code></li><li>投票：<code>vote</code></li><li>合作伙伴：<code>partner</code></li><li>友情链接：<code>link</code></li><li>版权：<code>copyright</code></li></ul></li></ul><hr><ul><li><p><strong><code>class</code>的命名:</strong></p></li><li><p>颜色:使用颜色的名称或者16进制代码,如</p><ul><li><code>.red &#123; color: red; &#125;</code></li><li><code>.f60 &#123; color: #f60; &#125;</code></li><li><code>.ff8600 &#123; color: #ff8600; &#125;</code></li></ul></li><li><p>字体大小,直接使用”font+字体大小”作为名称,如</p><ul><li><code>.font12px &#123; font-size: 12px; &#125;</code></li><li><code>.font9px &#123;font-size: 9pt; &#125;</code></li></ul></li><li><p>对齐样式,使用对齐目标的英文名称,如</p><ul><li><code>.left &#123; float:left; &#125;</code></li><li><code>.bottom &#123; float:bottom; &#125;</code></li></ul></li><li><p>标题栏样式,使用”类别+功能”的方式命名,如</p><ul><li><code> .barnews &#123; &#125;</code></li><li><code>.barproduct &#123; &#125;</code></li></ul></li></ul><hr><ul><li><p><strong>注意事项::</strong></p><ul><li>一律小写;</li><li>尽量用英文;</li><li>不加中杠和下划线;</li><li>尽量不缩写，除非一看就明白的单词.</li></ul></li><li><p>–</p></li></ul></li><li><p><strong>推荐的 <code>CSS</code> 书写顺序：</strong></p><ul><li><p>显示属性</p><ul><li><code>display</code></li><li><code>list-style</code></li><li><code>position</code></li><li><code>float</code></li><li><code>clear</code></li></ul></li><li><p>自身属性</p><ul><li><code> width</code></li><li><code>height</code></li><li><code>margin</code></li><li><code>padding</code></li><li><code>border</code></li><li><code>background</code></li></ul></li><li><p>文本属性</p><ul><li><code>color</code></li><li><code> font</code></li><li><code>text-decoration</code></li><li><code>text-align</code></li><li><code>vertical-align</code></li><li><code>white-space</code></li><li><code>other text</code></li><li><code>content </code></li></ul></li></ul></li></ul><hr><h4 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h4><ul><li><p>独立渲染区域</p></li><li><p>创建BFC都有哪些方式</p><ul><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或者<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>，<code>table-cell</code>，<code>flex</code></li><li><code>overflow</code>为<code>hidden</code>，<code>auto</code>，<code>scroll</code></li></ul></li><li><p>BFC能解决什么问题</p><ul><li>边距重叠问题</li><li>盒子塌陷问题</li><li>清除浮动</li><li>浮动环绕文字</li></ul></li></ul><h4 id="附录三-CSS精灵"><a href="#附录三-CSS精灵" class="headerlink" title="附录三 CSS精灵"></a>附录三 CSS精灵</h4><hr><ul><li><strong>CSS精灵原理以及应用</strong><ul><li><code>CSS</code>雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。<ul><li>该图片使用<code>CSS</code>   <code>background和background-position</code>属性渲染，这也就意味着你的标签变得更加复杂了，图片是在<code>CSS</code>中定义，而非<code>&lt;img&gt;</code>标签。</li></ul></li></ul></li><li><strong>一个简单的例子</strong>：<ul><li>一张图片作出一个按钮的三个状态</li><li>一个链接用<code>CSS</code>做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，<code>a:link</code>，<code>a:hover</code>，<code>a:active</code> <code>&lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt;</code></li><li>加入右侧的图片为：<code>200px 65px</code>的三个按钮图拼合而成的图片<code>button.png</code>，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用<code>CSS</code>进行定义。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">    display:block;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:65px;</span><br><span class="line">    line-height:65px; /*定义状态*/</span><br><span class="line">    text-indent:-2015px; /*隐藏文字*/</span><br><span class="line">    background-image:url(button.png); /*定义背景图片*/</span><br><span class="line">    background-position:0 0;</span><br><span class="line">    /*定义链接的普通状态，此时图像显示的是顶上的部分*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">    background-position:0 -66px;</span><br><span class="line">    /*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/</span><br><span class="line">&#125;</span><br><span class="line">a:active &#123;</span><br><span class="line">    background-position:0 -132px;</span><br><span class="line">    /*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更多的<code>CSS</code>雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值<ul><li>如：<code>background:url(nav.png) -180px 24pxno-repeat</code>; 来达到更精确的定位</li></ul></li><li><strong>优点：</strong><ul><li>减少加载网页图片时对服务器的请求次数</li><li>可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。</li><li>提高页面的加载速度</li><li><code>sprite </code>技术的其中一个好处是图片的加载时间(在有许多 <code>sprite</code> 时，单张图片的加载时间)。由所需图片拼成的一张 <code>GIF</code>图片的尺寸会明显小于所有图片拼合前的大小。单张的 <code>GIF</code>只有相关的一个色表，而单独分割的每一张 <code>GIF</code> 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 <code>JPEG</code> 或者 <code>PNG</code> <code>sprite</code> 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。</li><li>减少鼠标滑过的一些<code>bug</code></li><li><code>IE6</code>不会主动预加载鼠标滑过即<code>a:hover</code>中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用<code>CSS</code>雪碧，由于一张图片即可，所以不会出现这种现象。</li></ul></li><li><strong>不足：</strong><ul><li><code>CSS</code>雪碧的最大问题是内存使用</li><li>影响浏览器的缩放功能</li><li>拼图维护比较麻烦</li><li>使<code>CSS</code>的编写变得困难</li><li><code>CSS</code> 雪碧调用的图片不能被打印</li><li>错误得使用 <code>Sprites</code> 影响可访问性</li></ul></li></ul><h4 id="一些tips解决方案"><a href="#一些tips解决方案" class="headerlink" title="一些tips解决方案"></a>一些tips解决方案</h4><hr><h5 id="页面优化实践"><a href="#页面优化实践" class="headerlink" title="页面优化实践"></a>页面优化实践</h5><hr><ul><li><p>从下面的几个方面可以进行页面的优化：</p><ul><li>减少请求数</li><li>图片合并</li><li><code>CSS </code>文件合并</li><li>减少内联样式</li><li>避免在 <code>CSS </code>中使用 <code>import</code></li><li>减少文件大小</li><li>选择适合的图片格式</li><li>图片压缩</li><li><code>CSS</code> 值缩写（<code>Shorthand Property</code>)</li><li>文件压缩</li><li>页面性能</li><li>调整文件加载顺序</li><li>减少标签数量</li><li>调整选择器长度</li><li>尽量使用<code> CSS</code> 制作显示表现</li><li>增强代码可读性与可维护性</li><li>规范化</li><li>语义化</li><li>模块化</li></ul></li></ul><h5 id="写DIV-CSS-的一些常识"><a href="#写DIV-CSS-的一些常识" class="headerlink" title="写DIV+CSS 的一些常识"></a>写DIV+CSS 的一些常识</h5><hr><ul><li><p>不要使用过小的图片做背景平铺</p><ul><li>这就是为何很多人都不用 <code>1px</code> 的原因，这才知晓。宽高 <code>1px</code> 的图片平铺出一个宽高 <code>200px</code> 的区域，需要 <code>200200=40, 000</code> 次，占用资源</li></ul></li><li><p>无边框</p><ul><li>推荐的写法是 <code>border:none</code>;，哈哈，我一直在用这个。 <code>border:0;</code> 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源</li></ul></li><li><p>慎用 通配符</p><ul><li>所谓通配符，就是将<code> CSS</code> 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。</li></ul></li><li><p><code>CSS </code>的十六进制颜色代码缩写</p><ul><li>习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。</li></ul></li><li><p> 样式放头上，脚本放脚下。不内嵌，只外链</p></li><li><p> 坚决不用 <code>CSS </code>表达式</p></li><li><p>使用 引用样式表，而不是通过<code> @import</code> 导入。</p></li><li><p> 一般来说，<code>PNG </code>比 <code>GIF</code> 要小，小得多。再者，<code>GIF</code> 中有多少颜色是被浪费的，很值得优化。</p></li><li><p>千万不要在 <code>HTML </code>中缩放图片，一者不好看，二者占资源。</p></li><li><p>正文字体最好用偶数</p><ul><li><code>12px</code>、<code>14px</code>、<code>16px</code>，效果非常好。特例，<code>15px</code>。</li></ul></li><li><p><code>block</code>、<code>ul</code>、<code>ol </code>等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。</p></li><li><p>段落之间，至少要有一倍行距</p></li><li><p>强行指定某些元素的 <code>line-height</code>，正文 <code>1.6 </code>倍于文字大小，标题<code>1.3 </code>倍。</p></li><li><p>中文标点用全角</p><ul><li>英文夹杂在中文中，左右空格，半角。</li></ul></li><li><p>中文字体的粗体和斜体，远离较好</p></li></ul><h5 id="常用代码片段"><a href="#常用代码片段" class="headerlink" title="常用代码片段"></a>常用代码片段</h5><hr><ul><li>雅虎工程师提供的<code>CSS</code>初始化示例代码【仅供参考】<ul><li>可以在<code>html</code>头文件中直接引用，从而避免浏览器的不兼容带来的错误。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-tag">dl</span>,</span><br><span class="line"><span class="selector-tag">dt</span>,</span><br><span class="line"><span class="selector-tag">dd</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">li</span>,</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span>,</span><br><span class="line">pre,</span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">form</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span>,</span><br><span class="line"><span class="selector-tag">legend</span>,</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">textarea</span>,</span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Verdana, Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">td</span>,</span><br><span class="line"><span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-tag">caption</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:normal;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">address</span>,</span><br><span class="line"><span class="selector-tag">caption</span>,</span><br><span class="line"><span class="selector-tag">cite</span>,</span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">dfn</span>,</span><br><span class="line"><span class="selector-tag">em</span>,</span><br><span class="line"><span class="selector-tag">strong</span>,</span><br><span class="line"><span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-tag">var</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>:normal;</span><br><span class="line">    <span class="attribute">font-weight</span>:normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>:underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ol</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span>,</span><br><span class="line">select,</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>:<span class="number">14px</span> Verdana,Helvetica,Arial,sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    content: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mobile meta </code>标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”viewport”</span> <span class="attr">content</span>=<span class="string">”width</span>=<span class="string">320,target-densitydpi</span>=<span class="string">dpi_value,initial-scale</span>=<span class="string">1,</span> <span class="attr">user-scalable</span>=<span class="string">no”/</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>表格不被撑开</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">table-layout</span>: fixed;</span><br><span class="line"><span class="attribute">word-break</span>: break-all;</span><br><span class="line"><span class="attribute">border-collapse</span>: collapse;</span><br></pre></td></tr></table></figure><ul><li>不设宽高居中</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">”abc”</span> <span class="attr">style</span>=<span class="string">”display:table;text-align:center;width:100%;height:100%;”</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">”background:#f00;</span> <span class="attr">display:table-cell</span>; <span class="attr">vertical-align:middle</span>;”&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”button”</span> <span class="attr">value</span>=<span class="string">”item1″</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>透明度的兼容代码</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=<span class="number">50</span>); <span class="comment">/*1-100*/</span></span><br><span class="line">-moz-<span class="attribute">opacity</span>:<span class="number">0.5</span>; <span class="comment">/*0-1.0*/</span></span><br><span class="line">-khtml-<span class="attribute">opacity</span>:<span class="number">0.5</span>; <span class="comment">/*0-1.0*/</span></span><br><span class="line"><span class="attribute">opacity</span>:<span class="number">0.5</span>; <span class="comment">/*0-1.0*/</span></span><br></pre></td></tr></table></figure><ul><li>文字溢出点点省略</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br></pre></td></tr></table></figure><ul><li><p>清除浮动的几种方法</p><ul><li>方法一：<code>投机取巧法</code> – 不推荐</li><li>直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强</li></ul></li><li><p>方法二：<code>overflow + zoom</code>方法  –不推荐<br>  <code>.fix&#123;overflow:hidden; zoom:1;&#125;</code></p><ul><li>此方法优点在于代码简洁，涵盖所有浏览器</li></ul></li><li><p>方法三：<code>after + zoom</code>方法 -推荐–此方法可以说是综合起来最好的方法了</p><ul><li><code>clearfix</code>只应用在包含浮动子元素的父级元素上</li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fix</span>&#123;zoom:<span class="number">1</span>;&#125;</span><br><span class="line"><span class="selector-class">.fix</span>:after&#123;</span><br><span class="line">     display:block;</span><br><span class="line">     <span class="attribute">content</span>:<span class="string">&#x27;clear&#x27;</span>;</span><br><span class="line">     <span class="attribute">clear</span>:both;</span><br><span class="line">     <span class="attribute">line-height</span>:<span class="number">0</span>;</span><br><span class="line">     <span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更多代码片段详情<ul><li><a href="http://www.jianshu.com/p/e878122a92a3">实用的60个CSS代码片段</a></li></ul></li></ul><h5 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h5><hr><ul><li><p>自动继承属性：</p><ul><li><code>color</code></li><li><code>font</code></li><li><code>text-align</code></li><li><code>list-style</code><br>…</li></ul></li><li><p>非继承属性：</p><ul><li><code>background</code></li><li><code>border</code></li><li><code>position</code><br>…</li></ul></li><li><p>具有破坏性的元素：</p><ul><li><code>float</code></li><li><code>display:none;</code></li><li><code>position:absoblute/fixed/sticky;</code></li></ul></li><li><p>具有包裹性的元素：</p><ul><li><p><code>display:inline-block/table-cell</code></p></li><li><p><code>position:absolute/fixed/sticky</code></p></li><li><p><code>overflow:hidden/scroll</code></p></li></ul></li><li><p>消除图片底部间隙的方法</p><ul><li><p>图片块状化-无基线对齐<br><code>img&#123;display:block;&#125;</code></p></li><li><p>图片底线对齐<br><code>img&#123;vertical-align:bottom;&#125;</code></p></li><li><p>行高足够小 - 基线位置上移<br><code>.box&#123;line-height:0;&#125;</code></p></li></ul></li></ul><h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><hr><ul><li><p>BFC</p><ul><li><p>BFC全称<code>”Block Formatting Context”</code> 中文为“块级格式化上下文”</p></li><li><p>记住这么一句话：<code>BFC</code>元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素</p></li><li><p><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</p></li></ul></li><li><p>扩展阅读</p><ul><li><a href="https://github.com/dwqs/blog/issues/22">CSS中的BFC</a></li></ul></li><li><p>优雅降级(<code>graceful degradation</code>)</p><ul><li>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li></ul></li><li><p>渐进增强 <code>progressive enhancement</code>：</p><ul><li>是在浏览器开启<code>JavaScript</code>功能后，如果浏览器版本不支持某些  <code>JavaScript</code>  能力，我们解决这种问题的方式</li></ul></li><li><p>平稳退化</p><ul><li>是在浏览器没有<code>JavaScript</code>功能，或没有开启<code>JavaScript</code>功能情况下，我们解决这种问题的方式；</li></ul></li></ul><h5 id="方案荟萃扩展阅读"><a href="#方案荟萃扩展阅读" class="headerlink" title="方案荟萃扩展阅读"></a>方案荟萃扩展阅读</h5><hr><ul><li><p><strong>关于布局</strong></p></li><li><p><a href="http://www.qianduan.net/css-to-achieve-the-vertical-center-of-the-five-kinds-of-methods/">垂直居中</a></p></li><li><p><a href="http://codepen.io/shshaw/full/gEiDt">css完全居中</a></p></li><li><p><a href="http://www.w3cplus.com/collective-5.html">居中之美</a></p></li><li><p><a href="http://www.zhihu.com/question/35290742#answer-20340542">网页中的底部foot定位</a></p></li><li><p><a href="http://www.webhek.com/css-100-percent-height">页面高度100%</a></p></li><li><p><a href="https://github.com/phoetry/textareaAutoHeight">textarea高度自适应</a></p></li><li><p><a href="http://dotdotdot.frebsite.nl/">多行溢出省略</a></p></li><li><p><a href="http://jinlong.github.io/2015/05/24/css-retina-hairlines/">Retina屏1px线</a></p></li><li><p><a href="https://github.com/philipwalton/flexbugs">Flexbugs</a></p></li><li><p><strong>其他</strong></p></li><li><p><a href="http://www.stepday.com/topic/?690">IF IE ENDIF条件判断之IE10</a></p></li><li><p><a href="http://www.zhihu.com/question/20158063">Chrome 翻译插件</a></p></li><li><p><a href="http://blog.netsh.org/posts/website-retina_1779.netsh.html">网页retina优化</a></p></li><li><p><a href="http://segmentfault.com/a/1190000002407912">常用meta</a></p></li><li><p><a href="http://www.cnblogs.com/mq0036/p/3531848.html">树状菜单</a></p></li><li><p><a href="http://www.w3ctrain.com/2015/07/24/comprehensive-guide-when-to-use-em-vs-rem/">em vs rem</a></p></li><li><p><a href="https://github.com/classicemi/blog/issues/3#issuecomment-113861251">css vs js</a></p></li><li><p><a href="http://www.w3cplus.com/solution/index/index.html">css解决方案（w3cplus）</a></p></li><li><p><a href="http://riccardoscalco.github.io/textures/">Textures生成纹理</a></p></li><li><p><a href="http://una.im/CSSgram/">CSSgram</a></p></li><li><p><a href="http://zmoazeni.github.io/csscss/">Csscss（检查重复声明等）</a></p></li></ul><h4 id="部分工具资源"><a href="#部分工具资源" class="headerlink" title="部分工具资源"></a>部分工具资源</h4><hr><ul><li><a href="http://blog.poetries.top/2016/03/14/Emmet%EF%BC%9AHTML-CSS%E4%BB%A3%E7%A0%81%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99%E7%A5%9E%E5%99%A8/">学会使用Emmet插件快速编码</a></li><li><a href="http://blog.poetries.top/2016/09/09/Emmet%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/#more">Emmet常用快捷键</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/sublime-text.md">Sublime专题</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Sublime%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93.md">Sublime常用插件总结</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Front-End%20-Develop%20-Tools.md">Front-End -Develop -Tools</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Tools.md">ToolsBox-自己整理的一份工具列表</a></li></ul><h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><hr><ul><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md">编码规范</a></li><li><a href="http://front-end-standards.com/">前端规范</a></li><li><a href="https://github.com/poetries/mywiki/wiki/web-develop-standard">web develop standard</a></li><li><a href="http://codecloud.net/5622.html">Web 前端开发规范文档</a></li><li><a href="http://zhibimo.com/read/Ashu/front-end-style-guide/index.html">前端开发规范手册</a></li></ul><h4 id="进阶学习"><a href="#进阶学习" class="headerlink" title="进阶学习"></a>进阶学习</h4><hr><ul><li><a href="http://www.jianshu.com/p/1e638b7da640">DOM编程之API学习</a></li><li><a href="http://www.jianshu.com/p/1f2314552e23">JavaScript基础学习</a></li></ul><h4 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h4><hr><ul><li><a href="https://github.com/poetries/mywiki">Github上前端学习资源汇总</a></li><li><a href="https://github.com/poetries/mywiki/tree/master/front-end">WEB 前端开发学习笔记</a></li><li><a href="https://github.com/poetries/mywiki/wiki/%E6%94%B6%E9%9B%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7">前端开发工具箱</a></li><li><a href="https://segmentfault.com/a/1190000006689923">148个资源让你成为CSS专家</a></li><li><a href="http://zh.learnlayout.com/">学习CSS布局-经典必看</a></li></ul><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><hr><ul><li><p>前端指路</p></li><li><p><a href="http://www.w3cplus.com/css/write-to-front-end-developer-interview.html">写给前端面试者（w3cplus）</a></p></li><li><p><a href="http://jiongks.name/blog/how-to-become-a-great-front-end-engineer/">如何成为一名卓越的前端工程师（勾三股四博客）</a></p></li><li><p><a href="http://www.epubit.com.cn/article/144">什么是全栈工程师</a></p></li><li><p><a href="https://uptodate.frontendrescue.org/zh/">如何跟上前端开发的最新前沿</a></p></li><li><p><a href="http://blog.jobbole.com/12749/">浏览器的工作原理</a></p></li><li><p><a href="http://www.zhihu.com/question/20269059#answer-19718763">移动前端开发和 Web 前端开发的区别</a></p></li><li><p><a href="http://segmentfault.com/q/1010000003723038?utm_source=weekly&utm_medium=email&utm_campaign=email_weekly">大型网站CSS编写与维护</a></p></li><li><p><a href="http://segmentfault.com/q/1010000003059724">CSS核心技术关键字</a></p></li><li><p>性能/规范/实践</p></li><li><p><a href="http://www.chinaw3c.org/how-to-read-spec-wxx.html">如何阅读W3c规范(王晓轩)</a></p></li><li><p><a href="http://www.chinaw3c.org/how-to-read-spec-gb.html">如何阅读W3c规范(高博)</a></p></li><li><p><a href="https://developer.yahoo.com/performance/rules.html">雅虎web性能优化军规</a></p></li><li><p><a href="http://browserdiet.com/zh/">权威前端性能指南</a></p></li><li><p><a href="http://www.html-js.com/article/Front-end-home-best-practice-in-front-of-the-web-high-performance-CSS">高性能css</a></p></li><li><p>一些问答社区</p></li><li><p><a href="https://www.quora.com/">quora</a></p></li><li><p><a href="http://stackoverflow.com/">stackoverflow</a></p></li><li><p><a href="http://www.zhihu.com/">知乎</a></p></li><li><p><a href="http://www.html-js.com/qa">前端乱炖问答区</a></p></li><li><p><a href="http://segmentfault.com/questions/newest">segmentfault问答区</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;第一部分-HTML&quot;&gt;&lt;a href=&quot;#第一部分-HTML&quot; class=&quot;headerlink&quot; title=&quot;第一部分 HTML&quot;&gt;&lt;/a&gt;第一部分 HTML&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;第一章-职业规划和前景&quot;&gt;&lt;a href=&quot;#第一章-职业规划和前景&quot; class=&quot;headerlink&quot; title=&quot;第一章 职业规划和前景&quot;&gt;&lt;/a&gt;第一章 职业规划和前景&lt;/h4&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;职业方向规划定位：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;web&lt;/code&gt;前端开发工程师&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;web&lt;/code&gt;网站架构师&lt;/li&gt;
&lt;li&gt;自己创业&lt;/li&gt;
&lt;li&gt;转岗管理或其他</summary>
    
    
    
    <category term="HTML and CSS" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/HTML-and-CSS/"/>
    
    
    <category term="HTML and CSS" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/HTML-and-CSS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序简单了解</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-11-11T10:35:05.000Z</published>
    <updated>2022-05-17T01:12:47.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>历程</p><ul><li>2016年1月，首次被提出 <ul><li>越来越多的产品通过公众号来做，因为这里的开发、获取用户和传播成本更低，拆分出来的服务号并没有提供更好的服务，所以微信内部正在研究新的形态，叫做【微信小程序</li></ul></li><li>2016年9月21号，开启内测<ul><li>微信小程序正式开启内测，在微信生态下，微信小程序引起了广泛关注</li></ul></li><li>2017年1月9日，正式上线<ul><li>万众瞩目的第一批微信小程序低调上线，用户可以体验到各种各样小程序提供的服务</li></ul></li></ul></li><li><p><strong>App</strong></p><ul><li><strong>Native App（原生App）</strong><ul><li>基于不同操作系统来选择不同的开发语言</li><li>缺点：占用容量很大</li><li>优点：流畅，交互性好</li></ul></li><li><strong>HybridApp</strong><ul><li>混合App，原生App和Web app结合的产物</li><li>为了可以让用户可以感受到更新之后的页面，不需要自己手动更新App</li><li>虽然解决了原生App的问题，但是依然很大，像天猫、淘宝</li><li>因此，诞生了微信小程序</li></ul></li><li><strong>web App</strong><ul><li>手机里面的一个<code>web</code>页面</li><li>优点：占用容量很小，可以随时更新App</li><li>缺点：缓慢，每次重新点击都要加载一遍</li></ul></li><li><strong>微信小程序 applicaton</strong><ul><li>什么是微信小程序，小程序是一种不需要安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题，应用将无处不在 </li><li>优点：占用很小，2M以内</li><li> 使用频次较低，使用时间不长的适合微信小程序</li></ul></li></ul></li></ul><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul><li>在微信公众平台上注册账号</li><li>下载微信开发者工具</li><li>在微信开发者工具中创建小程序，具体参照<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信开放文档 (qq.com)</a></li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><p>一个小程序包含一个整体程序和给自页面的page</p></li><li><p>一个整体小程序由三个文件组成，必须放在项目根目录</p><table><thead><tr><th>文件</th><th>必需</th><th>作用</th></tr></thead><tbody><tr><td><code>app.js</code></td><td>是</td><td>小程序逻辑</td></tr><tr><td><code>app.json</code></td><td>是</td><td>小程序公共配置</td></tr><tr><td><code>app.wxss</code></td><td>否</td><td>小程序公共样式</td></tr></tbody></table></li><li><p>一个小程序页面由四个文件组成，分别是：</p><table><thead><tr><th align="left">文件类型</th><th align="left">必需</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>page.js</code></td><td align="left">是</td><td align="left">页面逻辑</td></tr><tr><td align="left"><code>page.wxml</code></td><td align="left">是</td><td align="left">页面结构</td></tr><tr><td align="left"><code>page.json</code></td><td align="left">否</td><td align="left">页面配置</td></tr><tr><td align="left"><code>page.wxss</code></td><td align="left">否</td><td align="left">页面样式表</td></tr></tbody></table></li><li><p>小程序的具体文件配置见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信开放文档 (qq.com)</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;历程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016年1月，首次被提出 &lt;ul&gt;
&lt;li&gt;越来越多的产品通过公众号来做，因为这里的开发</summary>
      
    
    
    
    <category term="微信小程序" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/ES6/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/ES6/</id>
    <published>2021-11-08T07:35:53.000Z</published>
    <updated>2022-05-17T01:12:47.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Es6"><a href="#Es6" class="headerlink" title="Es6"></a>Es6</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>介绍：<ul><li><code>ES2015</code>年退出<code>JavaScript</code>新版本也叫<code>ES2015</code></li><li>现在已经<code>ES7（2016）</code>，<code>ES8（2017）</code>，<code>ES9（2018）</code>很多新增内容仍是填</li><li>普遍使用的依然是<code>ES6</code>，<code>ES7</code>部分内容</li><li><code>ES7</code>及后面版本浏览器或node环境未完全支持，但已有<code>babel</code>工具可对其进行编译支持（转成<code>ES5</code>）</li><li>所以：新版本语言只是在原有基础上新增了一些语法糖，执行时还会转换为<code>ES5</code></li></ul></li><li><strong>ECMAScript</strong>、<strong>JavaScript</strong>、<strong>NodeJs</strong>，它们的区别是什么？<ul><li><code>ECMAScript</code>：简称<code>ES</code>，是一个语言标准（循环、判断、变量、数组等数据类型）</li><li><code>JavaScript</code>：运行在浏览器端的语言，该语言使用<code>ES</code>标准，<code>ES + web api = JavaScript</code></li><li><code>NodeJs</code>：运行在服务器端的语言，该语言使用<code>ES</code>标准，<code>ES + node api = JavaScript</code></li></ul></li><li><strong>ECMAScript</strong>有哪些关键的版本？<ul><li><code>ES3.0</code>：<code>1999</code></li><li><code>ES5.0</code>：<code>2009</code></li><li><code>ES6.0</code>：<code>2015</code>，从该版本不再使用数字作为编号，而使用年份，也叫<code>ES2015</code></li><li><code>ES7.0</code>：<code>2016</code></li></ul></li><li>为什么<strong>ES6</strong>如此重要？<ul><li><code>ES6</code>解决<code>JS</code>无法开发大型应用的语言层面的问题。</li></ul></li><li>为什么要学习<code>ES6</code>？<ul><li><code>ES6</code>引入的语言新特性，更具规范性，易读性，方便操作，简化了大型项目开发的复杂程度、降低了出错概率，提升了开发效率</li><li>大部分公司（不代表所有，代表着一个趋势）都在用<code>ES6</code>开发，已成为开发，求职必会内容</li></ul></li></ul><span id="more"></span><h2 id="块级绑定"><a href="#块级绑定" class="headerlink" title="块级绑定"></a>块级绑定</h2><h3 id="babel本地使用"><a href="#babel本地使用" class="headerlink" title="babel本地使用"></a>babel本地使用</h3><ul><li><p>用<code>Babel</code>工具做对比<code>ES6</code>-&gt;低级语法</p></li><li><p>在线<code>Babel</code>工具(<a href="https://babeljs.io/repl)%EF%BC%88https://babeljs.cn%EF%BC%89">https://babeljs.io/repl)（https://babeljs.cn）</a></p></li><li><p><code>npm</code>本地下载工具（用于生产环境）</p><ul><li><p><code>npm init -y</code> ：初始化</p></li><li><p><code>npm install @babel/core @babel/cli @babel/preset-env</code>：安装<strong>Babel</strong></p></li><li><p><code>npx babel xxx.js(需要被转换的文件名称) -o xxx.js(转换完成的文件名称) --watch</code>：编译<code>ES6</code>格式的<code>js</code>文件，<code>--watch</code>是时刻监控(更新)</p></li><li><p><strong>babel</strong>配置文件：</p><ul><li><strong>.babelrc</strong>文件，严格<code>json</code></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;@babel/preset-env&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明变量的问题"><a href="#声明变量的问题" class="headerlink" title="声明变量的问题"></a>声明变量的问题</h3><ul><li>使用<code>var</code>声明变量</li><li>允许重复的变量声明：导致数据被覆盖</li><li>变量提升：怪异的数据访问、闭包问题</li><li>全局变量挂载到<code>window</code>全局对象：全局对象成员污染问题</li></ul><h3 id="使用let声明变量"><a href="#使用let声明变量" class="headerlink" title="使用let声明变量"></a>使用let声明变量</h3><ul><li>加强了对作用域的控制</li></ul><p><code>ES6</code>不仅引入<code>let</code>关键字用于解决变量声明的问题，同时引入了块级作用域的概念</p><p>块级作用域：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域</p><ul><li>特点<ul><li><code>let</code>声明的变量不会挂载到全局对象</li><li><code>let</code>声明的变量，不允许当前作用域范围内重复声明</li><li>在块级作用域中用<code>let</code>定义的变量，在作用域外不能访问</li><li>使用<code>let</code>不会有变量提升，因此，不能在定义<code>let</code>变量之前使用它</li></ul></li></ul><p>底层实现上，<code>let</code>声明的变量实际上也会有提升，但是，提升后会将其放入到“暂时性死区”，如果访问的变量位于暂时性死区，则会报错：<code>“Cannot access &#39;a&#39; before initialization”</code>。当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。</p><p>在循环中，用<code>let</code>声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域（每次循环，使用的是一个全新的循环变量）</p><p>在循环中使用<code>let</code>声明的循环变量，在循环结束后会销毁</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//临时死区</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="comment">//Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="comment">//let声明会销毁块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">4</span>]();</span><br><span class="line">arr[<span class="number">7</span>]();</span><br></pre></td></tr></table></figure><h3 id="使用const声明常量"><a href="#使用const声明常量" class="headerlink" title="使用const声明常量"></a>使用const声明常量</h3><blockquote><p> <code>const</code>和<code>let</code>完全相同，仅在于用<code>const</code>声明的变量，必须在声明时赋值，而且不可以重新赋值。</p></blockquote><ul><li>实际上，在开发中，应该尽量使用<code>const</code>来声明变量，以保证变量的值不会随意篡改，原因如下：</li></ul><ol><li><p>根据经验，开发中的很多变量，都是不会更改，也不应该更改的。</p></li><li><p>后续的很多框架或者是第三方<code>JS</code>库，都要求数据不可变，使用常量可以一定程度上保证这一点。</p></li><li><p>注意的细节：</p><ol><li>常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = &#123;&#125;;</span><br><span class="line">PI.name = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//PI = 20;</span></span><br></pre></td></tr></table></figure><ol><li>常量的命名<ol><li>特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率、月地距地或其他一些绝不可能变化的配置。通常，<strong>该常量的名称全部使用大写，多个单词之间用下划线分割</strong></li><li>普通的常量：使用和之前一样的命名即可</li></ol></li><li>在<code>for</code>循环中，循环变量不可以使用常量</li></ol><h2 id="字符串和正则表达式"><a href="#字符串和正则表达式" class="headerlink" title="字符串和正则表达式"></a>字符串和正则表达式</h2><h3 id="更好的Unicode支持"><a href="#更好的Unicode支持" class="headerlink" title="更好的Unicode支持"></a>更好的Unicode支持</h3><ul><li><p>早期，由于存储空间宝贵，<code>Unicode</code>使用<code>16</code>位二进制来存储文字。我们将一个<code>16</code>位的二进制编码叫做一个码元（<code>Code Unit</code>）。</p></li><li><p>后来，由于技术的发展，<code>Unicode</code>对文字编码进行了扩展，将某些文字扩展到了<code>32</code>位（占用两个码元），并且，将某个文字对应的二进制数字叫做码点（<code>Code Point</code>）。</p></li><li><p><code>ES6</code>为了解决这个困扰，为字符串提供了方法：<code>codePointAt</code>，根据字符串码元的位置得到其码点。</p></li><li><p>同时，<code>ES6</code>为正则表达式添加了一个<code>flag: u</code>，如果添加了该配置，则匹配时，使用码点匹配</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;字符串长度：&quot;</span>, text.length);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;使用正则测试：&quot;</span>, <span class="regexp">/^.$/u</span>.test(text));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;得到第一个码元：&quot;</span>, text.charCodeAt(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;得到第二个码元：&quot;</span>, text.charCodeAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//𠮷：\ud842\udfb7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;得到第一个码点：&quot;</span>, text.codePointAt(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;得到第二个码点：&quot;</span>, text.codePointAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串char，是32位，还是16位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>char </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32bit</span>(<span class="params">char, i</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果码点大于了16位二进制的最大值，则其是32位的</span></span><br><span class="line">    <span class="keyword">return</span> char.codePointAt(i) &gt; <span class="number">0xffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到一个字符串码点的真实长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>str </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLengthOfCodePoint</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="comment">//i在索引码元</span></span><br><span class="line">        <span class="keyword">if</span> (is32bit(str, i)) &#123;</span><br><span class="line">            <span class="comment">//当前字符串，在i这个位置，占用了两个码元</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;𠮷是否是32位的：&quot;</span>, is32bit(<span class="string">&quot;𠮷&quot;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;ab𠮷ab的码点长度：&quot;</span>, getLengthOfCodePoint(<span class="string">&quot;ab𠮷ab&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="更多的字符串API"><a href="#更多的字符串API" class="headerlink" title="更多的字符串API"></a>更多的字符串API</h3><ul><li><p>以下均为字符串的实例（原型）方法</p></li><li><p><strong>includes</strong>：判断字符串中是否包含指定的子字符串</p></li><li><p><strong>startsWith</strong>：判断字符串中是否以指定的字符串开始</p></li><li><p><strong>endsWith</strong>：判断字符串中是否以指定的字符串结尾</p></li><li><p><strong>repeat</strong>：将字符串重复指定的次数，然后返回一个新字符串。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;成哥是狠人&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;是否包含“狠”：&quot;</span>, text.includes(<span class="string">&quot;狠&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;是否以“成哥”开头：&quot;</span>, text.startsWith(<span class="string">&quot;成哥&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;是否以“狠人”结尾：&quot;</span>, text.endsWith(<span class="string">&quot;狠人&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;重复4次：&quot;</span>, text.repeat(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ul><li><p><code>ES6</code>之前处理字符串繁琐的两个方面：</p><ul><li>多行字符串</li><li>字符串拼接</li></ul></li><li><p>在<code>ES6</code>中，提供了模板字符串的书写，可以非常方便的换行和拼接，要做的，仅仅是将字符串的开始或结尾改为 <strong>`</strong> 符号</p></li><li><p>如果要在字符串中拼接<code>js</code>表达式，只需要在模板字符串中使用<code>$&#123;JS表达式&#125;</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> val = <span class="string">&quot;我是&quot;</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">`<span class="subst">$&#123;val&#125;</span>人`</span> </span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;我是&quot;</span> + <span class="string">&quot;人&quot;</span>;</span><br><span class="line"><span class="comment">//$&#123;表达式&#125;，表达式可以是任何表达式</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><ul><li><p>使用</p><ul><li><p>在书写形参时，直接给形参赋值，附的值即为默认值</p></li><li><p>这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是<code>undefined</code>），则会自动使用默认值。</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b = <span class="number">1</span>, c = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><ul><li><p>[扩展]对<strong>arguments</strong>的影响</p><ul><li>只要给函数加上参数默认值，该函数会自动变量严格模式下的规则：arguments和形参脱离</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContainer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>name 元素的名称 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>container 元素的父元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>content 元素的内容 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">name = <span class="string">&quot;div&quot;</span>, container = getContainer(), content = <span class="string">&quot;&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ele = <span class="built_in">document</span>.createElement(name)</span><br><span class="line">    <span class="keyword">if</span> (content) &#123;</span><br><span class="line">        ele.innerHTML = content;</span><br><span class="line">    &#125;</span><br><span class="line">    container.appendChild(ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createElement(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="string">&quot;手动阀手动阀十分&quot;</span>)</span><br><span class="line">createElement(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="string">&quot;234242342424&quot;</span>)</span><br><span class="line">createElement(<span class="literal">undefined</span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>), <span class="string">&quot;234242342424&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>[扩展]留意暂时性死区</p><ul><li>形参和<code>ES6</code>中的<code>let</code>或<code>const</code>声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;arugments&quot;</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span>, a, <span class="string">&quot;b:&quot;</span>, b);</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;arugments&quot;</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span>, a, <span class="string">&quot;b:&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><ul><li><p><strong>arguments</strong>的缺陷：</p><ul><li>如果和形参配合使用，容易导致混乱</li><li>从语义上，使用<code>arguments</code>获取参数，由于形参缺失，无法从函数定义上理解函数的真实意图</li></ul></li><li><p><strong>ES6</strong>的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。</p><ul><li>语法:</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">...形参名</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">32</span>, <span class="number">46</span>, <span class="number">7</span>, <span class="number">34</span>); </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//args收集了所有的参数，形成的一个数组</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        sum += args[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum())</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...args1, ...args2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args1)</span><br><span class="line">    <span class="built_in">console</span>.log(args2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">32</span>, <span class="number">46</span>, <span class="number">7</span>, <span class="number">34</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>细节：</strong><ul><li>一个函数，仅能出现一个剩余参数</li><li>一个函数，如果有剩余参数，剩余参数必须是最后一个参数</li></ul></li></ul><h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p>使用方式：<code> ...要展开的东西 </code></p><ul><li>对数组展开 <strong>ES6</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">3</span>, <span class="number">67</span>, <span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//克隆arr1数组到arr2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">0</span>, ...arr1, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2, arr1 === arr2)</span><br></pre></td></tr></table></figure><ul><li>对对象展开 <strong>ES7</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;成哥&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="string">&quot;邓嫂&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">country</span>: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;哈尔滨&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅克隆到obj2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    ...obj1,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;邓哥&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.address === obj2.address)</span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;成哥&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">loves</span>: [<span class="string">&quot;邓嫂&quot;</span>, <span class="string">&quot;成嫂1&quot;</span>, <span class="string">&quot;成嫂2&quot;</span>],</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">country</span>: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;哈尔滨&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅克隆到obj2</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    ...obj1,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;邓哥&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        ...obj1.address</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">loves</span>: [...obj1.loves, <span class="string">&quot;成嫂3&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.loves === obj2.loves)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对所有数字求和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;...any&#125;</span> </span>args </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        sum += args[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个指定长度的随机数组成的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>length </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomNumbers</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        arr.push(<span class="built_in">Math</span>.random());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = getRandomNumbers(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将数组的每一项展开，依次作为参数传递，而不是把整个数组作为一个参数传递</span></span><br><span class="line"><span class="comment">// sum(numbers)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(...numbers))<span class="comment">//相当于传递了10个参数</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">3</span>, ...numbers, <span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><h3 id="确函数的双重用途"><a href="#确函数的双重用途" class="headerlink" title="确函数的双重用途"></a>确函数的双重用途</h3><blockquote><p><code>ES6</code>提供了一个特殊的<code>API</code>，可以使用该<code>API</code>在函数内部，判断该函数是否使用了<code>new</code>来调用</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>.target </span><br><span class="line"><span class="comment">//该表达式，得到的是：如果没有使用new来调用函数，则返回undefined</span></span><br><span class="line"><span class="comment">//如果使用new调用函数，则得到的是new关键字后面的函数本身</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是使用new的方式来调用的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// //过去的判断方式</span></span><br><span class="line">    <span class="comment">// if (!(this instanceof Person)) &#123;</span></span><br><span class="line">    <span class="comment">//     throw new Error(&quot;该函数没有使用new来调用&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;该函数没有使用new来调用&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    <span class="built_in">this</span>.fullName = <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;袁&quot;</span>, <span class="string">&quot;进&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = Person(<span class="string">&quot;袁&quot;</span>, <span class="string">&quot;进&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = Person.call(p1, <span class="string">&quot;袁&quot;</span>, <span class="string">&quot;进&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p3);</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li><p>回顾：<code>this</code>指向</p><ul><li>通过对象调用函数，<code>this</code>指向对象</li><li>直接调用函数，<code>this</code>指向全局对象</li><li>如果通过<code>new</code>调用函数，<code>this</code>指向新创建的对象</li><li>如果通过<code>apply</code>、<code>call</code>、<code>bind</code>调用函数，<code>this</code>指向指定的数据</li><li>如果是<code>DOM</code>事件函数，<code>this</code>指向事件源</li></ul></li><li><p>特点</p><ul><li>不用写<code>function</code>关键字</li><li>只能作为函数使用不能<code>new</code>为构造函数，没有原型</li><li>参数不能重复命名</li><li>返回值可以不写<code>return</code>，但是有时需要配合<code>&#123;&#125;</code></li><li>内部<code>arguments</code>、<code>this</code> 由定义时外围最接近一层的非箭头函数的<code>arguments</code>和<code>this</code>决定其值</li></ul></li><li><p>使用语法</p><ul><li><p>箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数</p></li><li><p>完整语法：</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)=&gt;&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isOdd = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果参数只有一个，可以省略小括号</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; <span class="keyword">const</span> print = <span class="function"><span class="params">num</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;给我的数字是：&quot;</span>, num)&#125;</span><br></pre></td></tr></table></figure><ul><li>如果箭头函数只有一条返回语句，可以省略大括号，和<code>return</code>关键字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; 返回值</span><br></pre></td></tr></table></figure><ul><li><p>注意细节</p><ul><li>箭头函数中，不存在<code>this</code>、<code>arguments</code>、<code>new.target</code>，如果使用了，则使用的是函数外层的对应的<code>this</code>、<code>arguments</code>、<code>new.target</code></li><li>箭头函数没有原型</li><li>箭头函数不能作用构造函数使用</li></ul></li><li><p>应用场景</p><ul><li>临时性使用的函数，并不会可以调用它，比如：</li><li>事件处理函数</li><li>异步处理函数</li><li>其他临时性的函数</li><li>为了绑定外层this的函数</li></ul><ol start="3"><li>在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li></ol></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="comment">//求和,可以不写return，但是函数体需要在箭头后面</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象,如果想返回对象，则需要将对象变为函数表达式，大括号外面加一层括号,(&#123;&#125;)</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> (&#123;<span class="attr">a</span>:a,<span class="attr">b</span>:b&#125;);</span><br></pre></td></tr></table></figure><ul><li>例：高阶函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高阶函数：如果一个函数接受一个参数以后，如果返回一个函数的话就是高阶函数，或者这个函数能够接受一个参数，这个参数是一个函数的话也是高阶函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通形式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y + z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum1 = sum(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> sum2 = sum1(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数形式</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">z</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y + z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当去掉return时就变为下面的形式了</span></span><br><span class="line"><span class="comment">//当箭头函数的形参只有一个时，是可以去掉参数的括号，但是当形参有一个以上的情况下，需要括上括号</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="function">(<span class="params">y</span>) =&gt;</span> <span class="function">(<span class="params">z</span>) =&gt;</span> x + y + z;</span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>不能<code>new</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> sum();<span class="comment">//会报错</span></span><br><span class="line"><span class="comment">//arrow.js:33 Uncaught TypeError: sum is not a constructor at arrow.js:33</span></span><br><span class="line"><span class="comment">//sum.prototype =&gt; undefined</span></span><br></pre></td></tr></table></figure><ul><li>形式区分：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数形式</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组形式</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="function">() =&gt;</span> &#123;&#125;]</span><br><span class="line">arr[<span class="number">0</span>()];</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时也可以返回值也可以是箭头函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>arguments</strong>特点</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部arguments、this 由定义时外围最接近一层的非箭头函数的arguments和this决定其值，也就是说箭头函数的外围不是箭头函数才会有arguments</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//arguments</span></span><br><span class="line">    <span class="comment">//9 10 11</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>,a,b);</span><br><span class="line">        <span class="comment">//这个输出的argument就是outer的arguments，箭头函数本身没有arguments</span></span><br><span class="line">    &#125;;</span><br><span class="line">    sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">outer(<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当函数需要返回外围函数的arguments时，可以使用箭头函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Curry</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    var arg = arguments;</span></span><br><span class="line"><span class="comment">    return function() &#123;</span></span><br><span class="line"><span class="comment">       console.log(arg,arguments)</span></span><br><span class="line"><span class="comment">    //如果不使用箭头函数，这个arguments就是这个函数本身的arguments，就需要外围声明一个变量储存arguments</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Curry(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>this</strong>特点</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当箭头函数外围没有非箭头函数时，则this等于window</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;outerObj&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="string">&quot;innserObj&quot;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// this =&gt; window</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);<span class="comment">//outerObj</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;outerObj&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;innerObj&#x27;</span>,</span><br><span class="line">    <span class="comment">//fn() &#123;&#125;就相当于fn: function()&#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//this =&gt; window，这时外围就有了非箭头函数了，this指向也就变味了obj</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a); <span class="comment">//innserObj</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> outerSum = obj.fn();</span><br><span class="line">outerSum();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">ms</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// var self = this;</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.ms);</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="新增的对象字面量语法"><a href="#新增的对象字面量语法" class="headerlink" title="新增的对象字面量语法"></a>新增的对象字面量语法</h3><ul><li><p>成员速写</p><ul><li>如果对象字面量初始化时，成员的名称来自于一个变量，并且和变量的名称相同，则可以进行简写</li></ul></li><li><p>方法速写</p><ul><li>对象字面初始化时，方法可以省略冒号和<code>function</code>关键字</li></ul></li><li><p>计算属性名</p><ul><li>有的时候，初始化对象时，某些属性名可能来自于某个表达式的值，在<code>ES6</code>，可以使用中括号来表示该属性名是通过计算得到的。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prop1 = <span class="string">&quot;name2&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> prop2 = <span class="string">&quot;age2&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> prop3 = <span class="string">&quot;sayHello2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    [prop1]: <span class="string">&quot;姬成&quot;</span>,</span><br><span class="line">    [prop2]: <span class="number">100</span>,</span><br><span class="line">    <span class="comment">// 方法可以省略冒号和关键字</span></span><br><span class="line">    [prop3]()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>[prop1], <span class="built_in">this</span>[prop2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user[prop3]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user)</span><br></pre></td></tr></table></figure><h3 id="Object的新增API"><a href="#Object的新增API" class="headerlink" title="Object的新增API"></a>Object的新增API</h3><ul><li><p><strong>Object.is</strong></p><ul><li>用于判断两个数据是否相等，基本上跟严格相等（===）是一致的，除了以下两点：</li><li><code>NaN</code>和<code>NaN</code>相等</li><li><code>+0</code>和<code>-0</code>不相等</li></ul></li><li><p><strong>Object.assign</strong></p><ul><li>用于混合对象</li></ul></li><li><p><strong>Object.getOwnPropertyNames</strong> 的枚举顺序</p><ul><li><code>Object.getOwnPropertyNames</code>方法之前就存在，只不过，官方没有明确要求，对属性的顺序如何排序，如何排序，完全由浏览器厂商决定。</li><li><code>ES6</code>规定了该方法返回的数组的排序方式如下：<ul><li>先排数字，并按照升序排序</li><li>再排其他，按照书写顺序排序</li></ul></li></ul></li><li><p><strong>Object.setPrototypeOf</strong></p><ul><li>该函数用于设置某个对象的隐式原型</li><li>比如： <code>Object.setPrototypeOf(obj1, obj2)</code>，相当于：  <code>obj1.__proto__ = obj2</code></li></ul></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj1.__proto__ = obj2</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2)</span><br><span class="line"><span class="built_in">console</span>.log(obj1)</span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><ul><li><p>简介</p><ul><li><code>ES5</code>规范开始后续版本迭代，也在致力于做一件事，就是把<code>js</code>底层已有的功能，提供给开发者使用。<code>Object.defineProperty</code>就是其中一个，此方法会可直接在一个对象上定义一个新的具有详细描述的属性，或者修改一个对象的现有属性，并返回这个对象。</li><li>在一个对象上定义一个新的具有详细描述的属性，或者修改一个对象的现有属性。</li></ul></li><li><p>使用：</p><ul><li><p><strong>Object.defineProperty</strong>(对象,属性,描述符);</p></li><li><p>描述符对象的属性的进行详细描述：</p><ul><li><p>数据描述符：</p><ul><li><p><strong>value</strong>：<code>&#39;xxx&#39;</code> 属性值。默认~(空)</p></li><li><p><strong>writable</strong>：<code>true</code> 是否可写。默认<code>false</code></p></li><li><p><strong>configurable</strong>：<code>true</code> 是否可配置。默认<code>false</code></p></li><li><p><strong>enumerable</strong>：<code>true</code> 是否可枚举。默认<code>false</code></p></li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;cst&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//value,对象中的值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line"><span class="comment">//writable true(可写)</span></span><br><span class="line">obj.name = <span class="string">&#x27;yz&#x27;</span></span><br><span class="line"><span class="comment">//configurable true,delete对象(可配置)</span></span><br><span class="line"><span class="keyword">delete</span> obj.name</span><br><span class="line"><span class="comment">//enumerable true,枚举(可枚举)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//writable false(不可写)</span></span><br><span class="line"><span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="comment">//configurable false(不可配置)</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="built_in">window</span>.a;<span class="comment">//window全局变量不可被删</span></span><br><span class="line"><span class="comment">//enumerable false(不可枚举)</span></span><br><span class="line"><span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><ul><li><p>存取描述符</p><ul><li><strong>set</strong>：<code>function()&#123;&#125;</code> 属性访问器 进行写操作时调用该方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">tempValue</span>: <span class="string">&#x27;duyi&#x27;</span>,</span><br><span class="line">    <span class="comment">//set更改时需要传入value，进行更改</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">       <span class="built_in">this</span>.tempValue = value;</span><br><span class="line">        <span class="comment">//将原属性更改为value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.name = <span class="number">10</span>;<span class="comment">//传入value</span></span><br></pre></td></tr></table></figure><ul><li><strong>get</strong>：<code>function()&#123;&#125;</code> 属性访问器 进行读操作时调用该方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">tempValue</span>: <span class="string">&#x27;duyi&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tempValue;</span><br><span class="line">        <span class="comment">//get取出的是方法返回的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li>如果描述中同时出现<code>value</code>、<code>writable</code>和<code>set</code>、<code>get</code>两组的话，会出现异常，切记不要同时使用</li></ul></li><li><p>作用：</p><ul><li>双向数据绑定的核心方法，主要做数据劫持操作（监控属性变化），同时是后期<code>ES6</code>中很多语法糖底层实现的核心方法</li></ul></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tempValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;name&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">//value: &#x27;cst&#x27;, //value</span></span><br><span class="line">    <span class="comment">//writable: false, //不可写</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">//可配置</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//可枚举</span></span><br><span class="line">    <span class="comment">//有get和set就不能有value和writable，二者取其一</span></span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tempValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        tempValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.name = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><ul><li><p><code>VUE</code>双向数据绑定核心功能由 <code>Observer</code>、<code>Compile</code>、<code>Watcher</code>三部分实现，其中<code>Observer</code>部分功能实现有<code>Object.defineProperty</code>实现</p><ul><li><code>Observer</code>:检测数据变化进行相应回调（数据劫持）</li><li>实现一个简单的数据劫持，作为<code>Object.defineProperty</code>的练习。从而引出<code>Proxy</code>&amp;<code>Reflect</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>),</span><br><span class="line">    oInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oData = &#123;</span><br><span class="line">    <span class="attr">valueObj</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;cc&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;duyi&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">oInput.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    oData.value = <span class="built_in">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    oDiv.innerText = oData.value;</span><br><span class="line">    <span class="comment">// oDiv.innerText = oData.valueObj.value; //监控对象中的对象</span></span><br><span class="line">&#125;</span><br><span class="line">upDate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//监控对象的某个属性是否发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是对象</span></span><br><span class="line">    <span class="keyword">if</span>(!data || <span class="keyword">typeof</span> data != <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//循环判断</span></span><br><span class="line">    <span class="comment">// for(var prop in data) &#123;&#125;</span></span><br><span class="line">    <span class="comment">//Object.keys(data)，可以将对象中的每个属性都放到数组中</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineRective(data,key,data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监控函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineRective</span>(<span class="params">data,key,val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//AO</span></span><br><span class="line">    Observer(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data,key,&#123;</span><br><span class="line">        get () &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set (newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue == val) <span class="keyword">return</span>;</span><br><span class="line">            val = newValue;</span><br><span class="line">            upDate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer(oData);</span><br></pre></td></tr></table></figure><h3 id="proxy-amp-reflect"><a href="#proxy-amp-reflect" class="headerlink" title="proxy &amp; reflect"></a>proxy &amp; reflect</h3><ul><li>简介<ul><li>植入代理模式的思想，以简洁易懂的方式控制对外部对象的访问</li><li><strong>new Proxy</strong>(对象,描述符);</li><li><strong>Proxy</strong>是一个构造函数，需要用变量接受</li></ul></li><li>描述符对象的属性的进行详细描述：<ul><li>数据描述符：<ul><li><strong>value</strong>：<code>&#39;xxx&#39;</code> 属性值。默认~(空)</li><li><strong>writable</strong>：<code>true</code> 是否可写。默认<code>false</code></li><li><strong>configurable</strong>：<code>true</code> 是否可配置。默认<code>false</code></li><li><strong>enumerable</strong>：<code>true</code> 是否可枚举。默认<code>false</code></li></ul></li><li>存取描述符<ul><li><strong>set</strong>：<code>function(target,key,value,receiver)&#123;&#125;</code> 属性访问器 进行写操作时调用该方法<ul><li><code>target</code>：对象</li><li><code>key</code>：属性</li><li><code>value</code>：传入的值</li><li><code>receiver</code>：代理函数</li></ul></li><li><strong>get</strong>：<code>function(target,key,receiver)&#123;&#125;</code> 属性访问器 进行读操作时调用该方法<ul><li><code>target</code>：对象</li><li><code>key</code>：属性</li><li><code>receiver</code>：代理函数</li></ul></li><li><strong>has</strong>:<code>function(target,key)&#123;&#125;</code><ul><li><code>target</code>：对象</li><li><code>key</code>：属性</li><li><code>has</code>对应<code>in</code>操作符，返回<code>true</code>/<code>false</code>，通常用来隐藏自己的私密属性</li></ul></li></ul></li></ul></li><li>总结<ul><li>利用内置的<code>set</code>、<code>get</code>方法控制属性的读写功能用处比较大，其余<code>has</code>、<code>deleProperty</code>…等方法不太在工作开发中使用，但是兼容性不太好</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始对象</span></span><br><span class="line"><span class="keyword">let</span> oData = &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="string">&#x27;duyi&#x27;</span>,</span><br><span class="line">    <span class="attr">_val</span>: <span class="string">&#x27;zzz&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理函数,oProxyData</span></span><br><span class="line"><span class="keyword">let</span> oProxyData = <span class="keyword">new</span> <span class="built_in">Proxy</span>(oData,&#123;</span><br><span class="line">    <span class="comment">//进行参数读写控制</span></span><br><span class="line">    set (target,key,value,receiver) &#123;</span><br><span class="line">        <span class="comment">//传入参数</span></span><br><span class="line">        <span class="built_in">Reflect</span>.set(target.key,value);</span><br><span class="line">        upData();</span><br><span class="line">    &#125;,</span><br><span class="line">    get (target,key,value,receiver) &#123;</span><br><span class="line">        <span class="comment">//获取对象并获取其中的属性值</span></span><br><span class="line">        <span class="built_in">Reflect</span>.get(target,key);</span><br><span class="line">    &#125;,</span><br><span class="line">    has (target,key) &#123;</span><br><span class="line">        <span class="comment">//判断属性是否有_，如果有则为false，否则key in oData</span></span><br><span class="line">        <span class="keyword">return</span> key.indexOf(<span class="string">&#x27;_&#x27;</span>) != -<span class="number">1</span> ? <span class="literal">false</span> : key <span class="keyword">in</span> oData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写 控制</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;_val&#x27;</span> <span class="keyword">in</span> oProxy);</span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="built_in">console</span>.log(oProxy.val);</span><br><span class="line"><span class="comment">//写</span></span><br><span class="line">oProxy.val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;更新了&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象简介"><a href="#面向对象简介" class="headerlink" title="面向对象简介"></a>面向对象简介</h3><ul><li><p>面向对象：一种编程思想，跟具体的语言</p></li><li><p>对比面向过程：</p><ul><li><p>面向过程：思考的切入点是功能的步骤</p></li><li><p>面向对象：思考的切入点是对象的划分</p></li><li><p>面向过程目的在于把功能拆分成步骤，一环扣一环的完成，但是需求复杂到一定程度后，对开发者能力的挑战也是越来越强</p></li><li><p>面向对象目的在于前期把功能拆分并抽象成不同的对象，聚焦于每个对象的能力和他们之间的配合，项目复杂后相对于面向过程来讲较为轻松一些</p></li><li><p>举个例子：【大象装冰箱】</p></li><li><p>面向对象的编程语言需要具备封装、继承、多态，<code>js</code>不是面向对象的语言，而是基于对象的语言，<code>js</code>中基本上一切皆是对象</p></li><li><p>前端变成需要面向对象的思想</p><ul><li>相对于复杂业务为了做到功能复用，降低项目开发的复杂度，需要这种思想，比如，前端校验和写一个校验器，而不是面向过程每次需要验证都一条线的下来编写</li><li>目前前端主流框架<code>vue</code>、<code>react</code>都是采用面向对象的方式来做，以及进入公司进行高级开发，组件研发，制作功能模块，也需要采取这样的思想做事</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elephant</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冰箱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Frige</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Frige.prototype.openDoor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Frige.prototype.closeDoor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Frige.prototype.join = <span class="function"><span class="keyword">function</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.openDoor();</span><br><span class="line">    <span class="comment">//装东西</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.closeDoor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 冰箱门打开</span></span><br><span class="line"><span class="comment">// var frig = new Frige();</span></span><br><span class="line"><span class="comment">// frig.openDoor();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //2. 大象装进去</span></span><br><span class="line"><span class="comment">// var ele = new Elephant();</span></span><br><span class="line"><span class="comment">// frig.join(ele);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //3. 冰箱门关上</span></span><br><span class="line"><span class="comment">// frig.closeDoor();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> frig = <span class="keyword">new</span> Frige();</span><br><span class="line"></span><br><span class="line">frig.join(<span class="keyword">new</span> Elephant());</span><br></pre></td></tr></table></figure><h3 id="类-Class"><a href="#类-Class" class="headerlink" title="类-Class"></a>类-Class</h3><h4 id="类：构造函数的语法糖"><a href="#类：构造函数的语法糖" class="headerlink" title="类：构造函数的语法糖"></a>类：构造函数的语法糖</h4><ul><li><p>传统的构造函数的问题</p><ul><li>属性和原型方法定义分离，降低了可读性</li><li>原型成员可以被枚举</li><li>默认情况下，构造函数仍然可以被当作普通函数使用</li></ul></li><li><p>类的特点</p><ul><li>类声明不会被提升，与 <code>let</code> 和 <code>const</code> 一样，存在暂时性死区</li><li>类中的所有代码均在严格模式下执行</li><li>类的所有方法都是不可枚举的</li><li>类的所有方法都无法被当作构造函数使用</li><li>类的构造器必须使用 <code>new</code> 来调用</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类 class</span></span><br><span class="line"><span class="comment">// 不可以 var、let，它是一个语法糖，本质还是function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性 cunstructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, name, age, sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有属性（相当于给原型添加属性）</span></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【种类】：<span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【名字】：<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【年龄】：<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【性别】：<span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Animal(<span class="string">&quot;狗&quot;</span>, <span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">a.print();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的其他书写方式"><a href="#类的其他书写方式" class="headerlink" title="类的其他书写方式"></a>类的其他书写方式</h4><ul><li><p>可计算的成员名</p></li><li><p><strong>getter</strong>和<strong>setter</strong></p><ul><li><strong>Object.defineProperty</strong> 可定义某个对象成员属性的读取和设置</li><li>使用<code>getter</code>和<code>setter</code>控制的属性，不在原型上</li></ul></li><li><p>静态成员</p><ul><li>构造函数本身的成员</li><li>使用<code>static</code>关键字定义的成员即静态成员</li></ul></li><li><p>字段初始化器（<strong>ES7</strong>）</p><ul><li>注意：</li><li>使用<code>static</code>的字段初始化器，添加的是静态成员</li><li>没有使用<code>static</code>的字段初始化器，添加的成员位于对象上</li><li>箭头函数在字段初始化器位置上，指向当前对象</li></ul></li><li><p>类表达式</p></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getter setter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> printName = <span class="string">&quot;print&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, name, age, sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个age属性，并给它加上getter，读取该属性时，会运行该函数</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age + <span class="string">&quot;岁&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个age属性，并给它加上setter，给该属性赋值时，会运行该函数</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title">age</span>(<span class="params">age</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> age !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;age property must be a number&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            age = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (age &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            age = <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [printName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【种类】：<span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【名字】：<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【年龄】：<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【性别】：<span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal(<span class="string">&quot;狗&quot;</span>, <span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static 静态属性</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// static 静态属性</span></span><br><span class="line">    <span class="keyword">static</span> width = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">static</span> height = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Chess.width)</span><br><span class="line"><span class="built_in">console</span>.log(Chess.height)</span><br><span class="line"></span><br><span class="line">Chess.method();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">//匿名类，类表达式</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><ul><li><p>如果两个类<code>A</code>和<code>B</code>，如果可以描述为：<code>B</code> 是 <code>A</code>，则，<code>A</code>和<code>B</code>形成继承关系</p></li><li><p>如果<code>B</code>是<code>A</code>，则：</p><ul><li><code>B</code>继承自A</li><li><code>A</code>派生<code>B</code></li><li><code>B</code>是<code>A</code>的子类</li><li><code>A</code>是<code>B</code>的父类</li></ul></li><li><p>如果<code>A</code>是<code>B</code>的父类，则<code>B</code>会自动拥有<code>A</code>中的所有实例成员。</p></li><li><p>新的关键字：</p><ul><li><strong>extends</strong>：继承，用于类的定义</li><li><strong>super</strong><ul><li>直接当作函数调用，表示父类构造函数</li><li>如果当作对象使用，则表示父类的原型</li></ul></li></ul></li><li><p>注意：<code>ES6</code>要求，如果定义了<code>constructor</code>，并且该类是子类，则必须在<code>constructor</code>的第一行手动调用父类的构造函数</p></li><li><p>如果子类不写<code>constructor</code>，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器</p></li><li><p>【冷知识】</p><ul><li>用<code>JS</code>制作抽象类<ul><li>抽象类：一般是父类，不能通过该类创建对象</li></ul></li><li>正常情况下，<code>this</code>的指向，<code>this</code>始终指向具体的类的对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type, name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`【种类】：<span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`【名字】：<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`【年龄】：<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`【性别】：<span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//借用父类的构造函数</span></span><br><span class="line">    Animal.call(<span class="built_in">this</span>, <span class="string">&quot;犬类&quot;</span>, name, age, sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Dog.prototype, Animal.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;公&quot;</span>);</span><br><span class="line">d.print();</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, name, age, sex</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Animal) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;你不能直接创建Animal的对象，应该通过子类创建&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【种类】：<span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【名字】：<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【年龄】：<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【性别】：<span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">jiao</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;动物怎么叫的？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类Dog的prototype继承类Animal的prototype </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, sex</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的私有属性</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;犬类&quot;</span>, name, age, sex);</span><br><span class="line">        <span class="comment">// 子类特有的属性</span></span><br><span class="line">        <span class="built_in">this</span>.loves = <span class="string">&quot;吃骨头&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的print</span></span><br><span class="line">        <span class="built_in">super</span>.print();</span><br><span class="line">        <span class="comment">// 自己特有的代码</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`【爱好】：<span class="subst">$&#123;<span class="built_in">this</span>.loves&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//同名方法，会覆盖父类</span></span><br><span class="line">    <span class="function"><span class="title">jiao</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;旺旺！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的代码逻辑有误</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;公&quot;</span>)</span><br><span class="line">a.print();</span><br></pre></td></tr></table></figure><h4 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator(装饰器)"></a>Decorator(装饰器)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Obsolete</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;print方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obsolete</span>(<span class="params">target, methodName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// function Test</span></span><br><span class="line">    <span class="comment">// print</span></span><br><span class="line">    <span class="comment">// &#123; value: function print()&#123;&#125;, ... &#125;</span></span><br><span class="line">    <span class="comment">// console.log(target, methodName, descriptor);</span></span><br><span class="line">    <span class="keyword">const</span> oldFunc = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`<span class="subst">$&#123;methodName&#125;</span>方法已过时`</span>);</span><br><span class="line">        oldFunc.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面向对象</span></span><br><span class="line"><span class="comment">//张三</span></span><br><span class="line"><span class="keyword">let</span> oInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inp&#x27;</span>),</span><br><span class="line">    oBtn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">@Skin <span class="comment">//修饰类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">        <span class="comment">//ES6规范 static num() &#123;return 10;&#125;</span></span><br><span class="line">        <span class="comment">//ES7规范 static num = 10;</span></span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.keyValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//装饰器</span></span><br><span class="line">    <span class="comment">// @名称</span></span><br><span class="line">    @myReadOnly <span class="comment">//修饰url属性，给url加了装饰器</span></span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    url = <span class="string">&#x27;urlA-&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    @dealData(<span class="string">&#x27;张三&#x27;</span>) <span class="comment">//修饰原型属性，给getContent加了装饰器</span></span><br><span class="line">    <span class="comment">//原型属性</span></span><br><span class="line">    getContent (a, b) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;向&#x27;</span> + <span class="built_in">this</span>.url + <span class="string">&#x27;发送网络请求，数据：&#x27;</span> + <span class="built_in">this</span>.keyValue,a,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//target：类本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Skin</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.aa = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oS = <span class="keyword">new</span> Search();</span><br><span class="line"></span><br><span class="line">oInput.oninput = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    oS.keyValue = <span class="built_in">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    oS.getContent();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//李四</span></span><br><span class="line"><span class="comment">//装饰器</span></span><br><span class="line"><span class="comment">//修饰私有属性的描述符属性</span></span><br><span class="line">    <span class="comment">//configurable</span></span><br><span class="line">     <span class="comment">//enumerable</span></span><br><span class="line">     <span class="comment">//initializer</span></span><br><span class="line">     <span class="comment">//writable</span></span><br><span class="line"><span class="comment">//装饰原型上的属性的描述符属性</span></span><br><span class="line">    <span class="comment">//configurable</span></span><br><span class="line">    <span class="comment">//enumerable</span></span><br><span class="line">    <span class="comment">//initializer</span></span><br><span class="line">    <span class="comment">//writable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰私有属性</span></span><br><span class="line"><span class="comment">//参数：原型 修饰属性名称 描述符属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReadOnly</span>(<span class="params">proto,key,descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// console.log(proto,key,descriptor);</span></span><br><span class="line">    <span class="comment">//可不可写</span></span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//initializer()的返回值决定了属性url的值</span></span><br><span class="line">    descriptor.initializer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;urlA-&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="comment">//描述符属性：</span></span><br><span class="line">     <span class="comment">//configurable</span></span><br><span class="line">     <span class="comment">//enumerable</span></span><br><span class="line">     <span class="comment">//initializer</span></span><br><span class="line">     <span class="comment">//writable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修饰原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dealData</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">proto,key,descriptor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(proto,key,descriptor);</span></span><br><span class="line">        <span class="keyword">let</span> oldValue = descriptor.value;</span><br><span class="line">        <span class="comment">//代理思想</span></span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">var</span> urlB = <span class="string">&#x27;urlB-&#x27;</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;向&quot;</span> + urlB + <span class="string">&quot;发送网络请求，数据：&quot;</span> + <span class="built_in">this</span>.keyValue + <span class="string">&quot; 发送人 &quot;</span> + ms);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//先把本来的getContent函数执行一遍，将arguments传给this（oS对象）</span></span><br><span class="line">            <span class="keyword">return</span> oldValue.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原型描述符属性：</span></span><br><span class="line">         <span class="comment">//configurable</span></span><br><span class="line">         <span class="comment">//enumerable</span></span><br><span class="line">         <span class="comment">//value</span></span><br><span class="line">         <span class="comment">//writable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// //面向过程</span></span><br><span class="line"><span class="comment">// // 张三</span></span><br><span class="line"><span class="comment">// var keyValue = &#x27;&#x27;;</span></span><br><span class="line"><span class="comment">// oInput.oninput = function () &#123;</span></span><br><span class="line"><span class="comment">//     keyValue = this.value</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// oBtn.onclick = function () &#123;</span></span><br><span class="line"><span class="comment">//     newGetContent(keyValue)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function getContent (data) &#123;</span></span><br><span class="line"><span class="comment">//     //模拟发送网络请求</span></span><br><span class="line"><span class="comment">//     var url = &#x27;urlA-&#x27;;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;向&#x27; + url + &#x27;发送网络请求，数据：&#x27; + data);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //代理</span></span><br><span class="line"><span class="comment">// var newGetContent = dealFunc(getContent);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //李四</span></span><br><span class="line"><span class="comment">// function dealFunc(func) &#123;</span></span><br><span class="line"><span class="comment">//     return function(data) &#123;</span></span><br><span class="line"><span class="comment">//         //</span></span><br><span class="line"><span class="comment">//         var urlB = &#x27;urlB-&#x27;;</span></span><br><span class="line"><span class="comment">//         console.log(&#x27;向&#x27; + urlB + &#x27;发送网络请求，数据：&#x27; + data)</span></span><br><span class="line"><span class="comment">//         return func.apply(this,arguments);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h4 id="ES7之Class提案属性"><a href="#ES7之Class提案属性" class="headerlink" title="ES7之Class提案属性"></a>ES7之Class提案属性</h4><ul><li><p>新特性</p><ul><li><strong>static property = xxx</strong>：静态属性</li><li><strong>property = xxx</strong>：私有属性</li><li><strong>@decorator</strong>：装饰器</li></ul></li><li><p>提案特性需要下载</p><ul><li><code>npm install @babel/plugin-proposal-decorators</code></li></ul></li><li><p>需要配置</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;plugin&quot;</span>: [</span><br><span class="line">        [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>,&#123;<span class="string">&quot;legacy&quot;</span>:<span class="literal">true</span>&#125;]</span><br><span class="line">        [<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>,&#123;<span class="string">&quot;loose&quot;</span>:<span class="literal">true</span>&#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">    <span class="comment">//ES6规范</span></span><br><span class="line">        <span class="comment">// static num() &#123;</span></span><br><span class="line">        <span class="comment">//     return 10;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//ES7规范</span></span><br><span class="line">    <span class="keyword">static</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//私有属性</span></span><br><span class="line">        <span class="built_in">this</span>.keyValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//装饰器</span></span><br><span class="line">    <span class="comment">// @readOnly</span></span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    url = <span class="string">&#x27;urlA-&#x27;</span>;</span><br><span class="line">    <span class="comment">//原型属性</span></span><br><span class="line">    getCount () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;发送请求&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oS = <span class="keyword">new</span> Search();</span><br></pre></td></tr></table></figure><h4 id="手写Class"><a href="#手写Class" class="headerlink" title="手写Class"></a>手写Class</h4><h5 id="ES6之模拟class"><a href="#ES6之模拟class" class="headerlink" title="ES6之模拟class"></a>ES6之模拟class</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class 关键字，不可以var、let，它是一个语法糖，本质还是function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用class类，相当于Es5的构造函数，不用写function</span></span><br><span class="line"><span class="comment">//私有属性constructor</span></span><br><span class="line"><span class="comment">//公有属性(原型属性) </span></span><br><span class="line"><span class="comment">//静态属性(函数本身属性)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态属性,ES6不支持非方法的静态属性，ES7支持</span></span><br><span class="line">    <span class="comment">//静态属性在Plane中定义时，它就成为了Plane本身的方法</span></span><br><span class="line">    <span class="keyword">static</span> alive () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name || <span class="string">&#x27;普通飞机&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果想给原型添加方法，则在constructor的同级下添加函数</span></span><br><span class="line">    fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fly&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ES7 私有属性</span></span><br><span class="line">    <span class="comment">// name = 10;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//target extend origin：target的prototype继承Plane的prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttackPlane</span> <span class="keyword">extends</span> <span class="title">Plane</span></span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="comment">// Plane.call(this,name);</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="comment">//super就相当于把Plane的私有属性call了一下，将私有属性全部call到了constructor中</span></span><br><span class="line">        <span class="built_in">this</span>.logo = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有属性</span></span><br><span class="line">    dan () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;biubiubiu&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oAp = <span class="keyword">new</span> AttackPlane(<span class="string">&#x27;战斗机&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.must be new</span></span><br><span class="line"><span class="comment">// 2.class Plane.prototype 不能枚举</span></span><br><span class="line"><span class="comment">// 3.静态属性要放到Plane函数上，非原型</span></span><br></pre></td></tr></table></figure><h5 id="ES5模拟之Class"><a href="#ES5模拟之Class" class="headerlink" title="ES5模拟之Class"></a>ES5模拟之Class</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否以new的方式构造出来的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">_this,_constructor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断_this沿着原型链寻找，是否可以找到_this,如果不能则抛出错误，instanceof 运算符用来检测 constructor.prototype 是否存在于参数 _this 的原型链上。</span></span><br><span class="line">    <span class="keyword">if</span> (!(_this <span class="keyword">instanceof</span> _constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;TypeError: Class constructor Plane cannot be invoked without &#x27;new&#x27;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置公有属性和静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target,props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Object.defineProperty</span></span><br><span class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//ele.key ele.value</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target,ele.key,&#123; </span><br><span class="line">            <span class="attr">value</span>: ele.value,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">//可写</span></span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span><span class="comment">//可配置</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理公有属性和静态属性</span></span><br><span class="line"><span class="comment">//参数：原型、原型属性，静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span> (<span class="params">_constructor,_prototypeProperties,_staticProperties</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//如果传_prototypeProperties数组的话，给原型上赋值</span></span><br><span class="line">    <span class="keyword">if</span> (_prototypeProperties) &#123;</span><br><span class="line">        _defineProperties(_constructor.prototype, _prototypeProperties)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果传_staticProperties数组的话，给函数本身上赋值</span></span><br><span class="line">    <span class="keyword">if</span> (_staticProperties) &#123;</span><br><span class="line">        _defineProperties(_constructor,_staticProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Plane = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Plane</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否以new的方式来执行</span></span><br><span class="line">        _classCallCheck(<span class="built_in">this</span>,Plane);</span><br><span class="line">        <span class="comment">//把私有属性 公有属性 静态属性赋给Plane</span></span><br><span class="line">        <span class="built_in">this</span>.name = name || <span class="string">&quot;普通飞机&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建自身属性和静态属性</span></span><br><span class="line">    _createClass(Plane,[</span><br><span class="line">        <span class="comment">//自身方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;fly&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;fly&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ],[</span><br><span class="line">        <span class="comment">//静态属性</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;alive&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Plane;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oP = <span class="keyword">new</span> Plane(<span class="string">&quot;yzl&amp;战斗机&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型继承方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherit</span>(<span class="params">sub,sup</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(sub.prototype,sup.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AttackPlane = (<span class="function"><span class="keyword">function</span>(<span class="params">Plane</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    _inherit(AttackPlane,Plane);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">AttackPlane</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="built_in">this</span>,Plane);</span><br><span class="line">        <span class="built_in">this</span>.logo = <span class="string">&#x27;lll&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> that = Plane.call(<span class="built_in">this</span>,name);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> that == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            _this.that;</span><br><span class="line">        &#125;</span><br><span class="line">        _this.logo = <span class="string">&#x27;duyi&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//创建自身属性和静态属性</span></span><br><span class="line">    _createClass(AttackPlane,[</span><br><span class="line">        <span class="comment">//自身方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;dan&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;biubiubiu&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ],[</span><br><span class="line">        <span class="comment">//静态属性</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;alive&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> AttackPlane;</span><br><span class="line">&#125;(Plane))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oAp = <span class="keyword">new</span> AttackPlane();</span><br></pre></td></tr></table></figure><h2 id="解构-destructuring"><a href="#解构-destructuring" class="headerlink" title="解构(destructuring)"></a>解构(destructuring)</h2><ul><li><p>什么是解构</p><ul><li><p>使用<code>ES6</code>的一种语法规则，将一个对象或数组的某个属性提取到某个变量中</p></li><li><p><strong>解构不会对被解构的目标造成任何影响</strong></p></li><li><p>解构过程中，具备赋值和变量声明两个功能</p></li><li><p>目的在于把等号左右长得相似的两个东西内部的值取出来</p></li><li><p>对象数组都可以参与解构</p></li></ul></li></ul><ul><li>在解构中使用默认值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;同名变量 = 默认值&#125;</span><br></pre></td></tr></table></figure><ul><li>非同名属性解构</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;属性名:变量名&#125;</span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kevin&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;成都&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let name, age, sex, address;</span></span><br><span class="line"><span class="comment">// name = user.name;</span></span><br><span class="line"><span class="comment">// age = user.age;</span></span><br><span class="line"><span class="comment">// sex = user.sex;</span></span><br><span class="line"><span class="comment">// address = user.address;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let name, age, sex, address, abc;</span></span><br><span class="line"><span class="comment">// (&#123; name, age, sex, address &#125; = user);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定义5个变量，然后从对象中读取同名属性，放到变量中</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, sex, address, abc = <span class="number">123</span> &#125; = user</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, age, sex, address, abc)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kevin&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;成都&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先定义4个变量：name、age、gender、address</span></span><br><span class="line"><span class="comment">// 再从对象user中读取同名属性赋值（其中gender读取的是sex属性）</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, <span class="attr">sex</span>: gender = <span class="number">123</span>, address &#125; = user</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, age, gender, address)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kevin&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;成都&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解构出user中的name、province</span></span><br><span class="line"><span class="comment">//定义两个变量name、province</span></span><br><span class="line"><span class="comment">//再解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, <span class="attr">address</span>: &#123; province &#125; &#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, address, province)</span><br></pre></td></tr></table></figure><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// const &#123;</span></span><br><span class="line"><span class="comment">//     0: n1,</span></span><br><span class="line"><span class="comment">//     1: n2</span></span><br><span class="line"><span class="comment">// &#125; = numbers;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let n1, n2;</span></span><br><span class="line"><span class="comment">// ([n1, n2] = numbers);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只获得数组前两位</span></span><br><span class="line"><span class="keyword">const</span> [n1, n2] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n1, n2) <span class="comment">// a b</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [n1, , , n4, n5 = <span class="number">123</span>] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n1, n4, n5) <span class="comment">// a d 123</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const numbers = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, [1, 2, 3, 4]];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 得到numbers下标为4的数组中的下标为2的数据，放到变量n中</span></span><br><span class="line"><span class="comment">// const [, , , , [, , n]] = numbers;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到numbers下标为4的数组的属性a，赋值给变量A</span></span><br><span class="line"><span class="comment">// const [, , , , &#123; a: A &#125;] = numbers;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">a</span>: A &#125; = numbers[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kevin&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;成都&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解构出name，然后，剩余的所有属性，放到一个新的对象中，变量名为obj</span></span><br><span class="line"><span class="comment">// name: kevin</span></span><br><span class="line"><span class="comment">// obj : &#123;age:11, sex:&quot;男&quot;, address:&#123;...&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, ...obj &#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, obj)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">324</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3243</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到数组前两项，分别放到变量a和b中，然后剩余的所有数据放到数组nums</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const [a, b, ...nums] = numbers;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = numbers[<span class="number">0</span>], b = numbers[<span class="number">1</span>], nums = numbers.slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, nums);</span><br></pre></td></tr></table></figure><h3 id="参数结构"><a href="#参数结构" class="headerlink" title="参数结构"></a>参数结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function ajax(options) &#123;</span></span><br><span class="line"><span class="comment">//     const defaultOptions = &#123;</span></span><br><span class="line"><span class="comment">//         method: &quot;get&quot;,</span></span><br><span class="line"><span class="comment">//         url: &quot;/&quot;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     const opt = &#123;</span></span><br><span class="line"><span class="comment">//         ...defaultOptions,</span></span><br><span class="line"><span class="comment">//         ...options</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     console.log(opt)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    method = <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    url = <span class="string">&quot;/&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function print(user) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(`姓名：$&#123;user.name&#125;`)</span></span><br><span class="line"><span class="comment">//     console.log(`年龄：$&#123;user.age&#125;`)</span></span><br><span class="line"><span class="comment">//     console.log(`性别：$&#123;user.sex&#125;`)</span></span><br><span class="line"><span class="comment">//     console.log(`身份：$&#123;user.address.province&#125;`)</span></span><br><span class="line"><span class="comment">//     console.log(`城市：$&#123;user.address.city&#125;`)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">&#123; name, age, sex, address: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    province,</span></span></span><br><span class="line"><span class="params"><span class="function">    city</span></span></span><br><span class="line"><span class="params"><span class="function">&#125; &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`年龄：<span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`性别：<span class="subst">$&#123;sex&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`身份：<span class="subst">$&#123;province&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`城市：<span class="subst">$&#123;city&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kevin&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;成都&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(user)</span><br></pre></td></tr></table></figure><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h3><ul><li><p>符号是<code>ES6</code>新增的一个数据类型，它通过使用函数 <code>Symbol(符号描述)</code> 来创建</p></li><li><p>符号设计的初衷，是为了给对象设置私有属性</p></li><li><p>私有属性：只能在对象内部使用，外面无法使用</p></li><li><p>符号具有以下特点：</p></li><li><p>没有字面量</p><ul><li>使用 <code>typeof</code> 得到的类型是 symbol</li><li><strong>每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同</strong></li><li>符号可以作为对象的属性名存在，这种属性称之为符号属性<ul><li>开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问</li><li>符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性</li><li><code>Object.getOwnPropertyNames</code> 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性</li><li><code>ES6</code> 新增 <code>Object.getOwnPropertySymbols</code> 方法，可以读取符号</li></ul></li><li>符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 <code>String</code> 构造函数进行转换即可，<code>console.log</code> 之所以可以输出符号，是它在内部进行了显式转换</li></ul></li><li><p>创建一个符号</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个符号</span></span><br><span class="line"><span class="keyword">const</span> syb1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> syb2 = <span class="built_in">Symbol</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(syb1, syb2);</span><br><span class="line"><span class="comment">// typeof类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> syb1 === <span class="string">&quot;symbol&quot;</span>, <span class="keyword">typeof</span> syb2 === <span class="string">&quot;symbol&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个符号</span></span><br><span class="line"><span class="keyword">const</span> syb1 = <span class="built_in">Symbol</span>(<span class="string">&quot;这是随便写的一个符号&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> syb2 = <span class="built_in">Symbol</span>(<span class="string">&quot;这是随便写的一个符号&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(syb1, syb2);</span><br><span class="line"><span class="built_in">console</span>.log(syb1 === syb2)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个符号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> syb1 = <span class="built_in">Symbol</span>(<span class="string">&quot;这是用于对象的一个属性&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    [syb1]: <span class="number">3</span>  <span class="comment">//符号属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const hero = (function () &#123;</span></span><br><span class="line"><span class="comment">//     const getRandom = Symbol();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return &#123;</span></span><br><span class="line"><span class="comment">//         attack: 30,</span></span><br><span class="line"><span class="comment">//         hp: 300,</span></span><br><span class="line"><span class="comment">//         defence: 10,</span></span><br><span class="line"><span class="comment">//         gongji() &#123; //攻击</span></span><br><span class="line"><span class="comment">//             //伤害：攻击力*随机数（0.8~1.1)</span></span><br><span class="line"><span class="comment">//             const dmg = this.attack * this[getRandom](0.8, 1.1);</span></span><br><span class="line"><span class="comment">//             console.log(dmg);</span></span><br><span class="line"><span class="comment">//         &#125;,</span></span><br><span class="line"><span class="comment">//         [getRandom](min, max) &#123; //根据最小值和最大值产生一个随机数</span></span><br><span class="line"><span class="comment">//             return Math.random() * (max - min) + min;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;)()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(hero);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hero = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getRandom = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">attack, hp, defence</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.attack = attack;</span><br><span class="line">            <span class="built_in">this</span>.hp = hp;</span><br><span class="line">            <span class="built_in">this</span>.defence = defence;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">gongji</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">//伤害：攻击力*随机数（0.8~1.1)</span></span><br><span class="line">            <span class="keyword">const</span> dmg = <span class="built_in">this</span>.attack * <span class="built_in">this</span>[getRandom](<span class="number">0.8</span>, <span class="number">1.1</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(dmg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [getRandom](min, max) &#123; <span class="comment">//根据最小值和最大值产生一个随机数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h = <span class="keyword">new</span> Hero(<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(h);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> syb = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [syb]: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj))</span><br><span class="line"><span class="comment">//得到的是一个符号属性的数组</span></span><br><span class="line"><span class="keyword">const</span> sybs = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(sybs, sybs[<span class="number">0</span>] === syb)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Hero = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getRandom = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">attack, hp, defence</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.attack = attack;</span><br><span class="line">            <span class="built_in">this</span>.hp = hp;</span><br><span class="line">            <span class="built_in">this</span>.defence = defence;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">gongji</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">//伤害：攻击力*随机数（0.8~1.1)</span></span><br><span class="line">            <span class="keyword">const</span> dmg = <span class="built_in">this</span>.attack * <span class="built_in">this</span>[getRandom](<span class="number">0.8</span>, <span class="number">1.1</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(dmg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [getRandom](min, max) &#123; <span class="comment">//根据最小值和最大值产生一个随机数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h = <span class="keyword">new</span> Hero(<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> sybs = <span class="built_in">Object</span>.getOwnPropertySymbols(Hero.prototype);</span><br><span class="line"><span class="keyword">const</span> prop = sybs[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(h[prop](<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><h3 id="共享符号"><a href="#共享符号" class="headerlink" title="共享符号"></a>共享符号</h3><ul><li>根据某个符号名称（符号描述）能够得到同一个符号</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;符号名/符号描述&quot;</span>)  <span class="comment">//获取共享符号</span></span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">&quot;c&quot;</span>)]: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.for(<span class="string">&quot;c&quot;</span>)]);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> syb1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> syb2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(syb1 === syb2)</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    [syb1]: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    [syb2]: <span class="string">&quot;c&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SymbolFor = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">global</span> = &#123;&#125;;<span class="comment">//用于记录有哪些共享符号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">global</span>)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">global</span>[name]) &#123;</span><br><span class="line">            <span class="built_in">global</span>[name] = <span class="built_in">Symbol</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">global</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">global</span>[name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> syb1 = SymbolFor(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> syb2 = SymbolFor(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(syb1 === syb2);</span><br></pre></td></tr></table></figure><h3 id="知名（公共、具名）符号"><a href="#知名（公共、具名）符号" class="headerlink" title="知名（公共、具名）符号"></a>知名（公共、具名）符号</h3><blockquote><p>知名符号是一些具有特殊含义的共享符号，通过 <code>Symbol</code> 的静态属性得到</p><p><code>ES6</code> 延续了 <code>ES5</code> 的思想：减少魔法，暴露内部实现！</p><p>因此，<code>ES6</code> 用知名符号暴露了某些场景的内部实现</p></blockquote><h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><ul><li>该符号用于定义构造函数的静态成员，它将影响 <code>instanceof</code> 的判定    </li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> A</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">A[<span class="built_in">Symbol</span>.hasInstance](obj) <span class="comment">// Function.prototype[Symbol.hasInstance]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(A, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> A);</span><br><span class="line"><span class="comment">// console.log(A[Symbol.hasInstance](obj));</span></span><br></pre></td></tr></table></figure><h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><ul><li>该知名符号会影响数组的 <code>concat</code> 方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.concat(<span class="number">56</span>, arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  [3, 56, [5,6,7,8]]</span></span><br><span class="line"><span class="comment">//  [3, 56, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.concat(<span class="number">2</span>, obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><ul><li>该知名符号会影响类型转换的结果</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">degree</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.degree + <span class="string">&quot;摄氏度&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.degree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.degree + <span class="string">&quot;℃&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Temperature(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(t + <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(t / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(t));</span><br></pre></td></tr></table></figure><h4 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h4><ul><li>该知名符号会影响 <code>Object.prototype.toString</code> 的返回值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&quot;Person&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">32424</span>, <span class="number">45654</span>, <span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.apply(p));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.apply(arr))</span><br></pre></td></tr></table></figure><h4 id="其他知名符号"><a href="#其他知名符号" class="headerlink" title="其他知名符号"></a>其他知名符号</h4><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><h3 id="回顾-事件循环"><a href="#回顾-事件循环" class="headerlink" title="[回顾]事件循环"></a>[回顾]事件循环</h3><ul><li><p><code>JS</code>运行的环境称之为宿主环境。</p></li><li><p>执行栈：<code>call stack</code>，一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境。</p></li><li><p><code>JS</code>引擎永远执行的是执行栈的最顶部。</p></li><li><p>异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。</p></li><li><p>浏览器宿主环境中包含<strong>5</strong>个线程：</p><ul><li><code>JS</code>引擎：负责执行执行栈的最顶部代码</li><li><code>GUI</code>线程：负责渲染页面 </li><li>事件监听线程：负责监听各种事件</li><li>计时线程：负责计时</li><li>网络线程：负责网络通信</li></ul></li><li><p>当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当<code>JS</code>引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。</p></li><li><p><code>JS</code>引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。</p></li><li><p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</p><ul><li>宏任务（队列）：<code>macroTask</code>，计时器结束的回调、事件回调、<code>http</code>回调等等绝大部分异步函数进入宏队列</li><li>微任务（队列）：<code>MutationObserver</code>，<code>Promise</code>产生的回调进入微队列</li></ul></li></ul><blockquote><p><code>MutationObserver</code>函数用于监听某个<code>DOM</code>对象的变化</p></blockquote><ul><li><p>当执行栈清空时，<code>JS</code>引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。</p></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;global&quot;</span>);</span><br><span class="line">a();</span><br><span class="line"><span class="comment">// global a b c</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a c*1000 b</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;container&quot;</span>&gt;&lt;/ul&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;添加了一个li&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>)</span><br><span class="line">    li.innerText = count++;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听ul</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当监听的dom元素发生变化时运行的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ul元素发生了变化&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//监听ul</span></span><br><span class="line">observer.observe(ul, &#123;</span><br><span class="line">    <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="comment">//监听属性的变化</span></span><br><span class="line">    <span class="attr">childList</span>: <span class="literal">true</span>, <span class="comment">//监听子元素的变化</span></span><br><span class="line">    <span class="attr">subtree</span>: <span class="literal">true</span> <span class="comment">//监听子树的变化</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//取消监听</span></span><br><span class="line"><span class="comment">// observer.disconnect();</span></span><br></pre></td></tr></table></figure><h3 id="事件和回调函数的缺陷"><a href="#事件和回调函数的缺陷" class="headerlink" title="事件和回调函数的缺陷"></a>事件和回调函数的缺陷</h3><ul><li><p>我们习惯于使用传统的回调或事件处理来解决异步问题</p></li><li><p>事件：某个对象的属性是一个函数，当发生某一件事时，运行该函数</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回调：运行某个函数以实现某个功能的时候，传入一个函数作为参数，当发生某件事的时候，会运行该函数。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>本质上，事件和回调并没有本质的区别，只是把函数放置的位置不同而已。</p></li><li><p>一直以来，该模式都运作良好。</p></li><li><p>直到前端工程越来越复杂…</p></li><li><p>目前，该模式主要面临以下两个问题：</p><ul><li>回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套</li><li>异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增</li></ul></li><li><p>回调地狱实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>),</span><br><span class="line">      btn2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn2&quot;</span>),</span><br><span class="line">      btn3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn3&quot;</span>);</span><br><span class="line">btn1.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//按钮1的其他事情</span></span><br><span class="line">    btn2.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//按钮2的其他事情</span></span><br><span class="line">        btn3.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`邓哥向女神【<span class="subst">$&#123;god&#125;</span>】发出了表白短信`</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">            <span class="comment">//女神同意拉</span></span><br><span class="line">            <span class="comment">//resolve</span></span><br><span class="line">            callback(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//resolve</span></span><br><span class="line">            callback(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">biaobai(<span class="string">&quot;女神1&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;女神1答应了，邓哥很开心!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;女神1拒绝了，邓哥表示无压力，然后向女神2表白&quot;</span>);</span><br><span class="line">        biaobai(<span class="string">&quot;女神2&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;女神2答应了，邓哥很开心!&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;女神2十分感动，然后拒绝了邓哥，邓哥向女神3表白&quot;</span>);</span><br><span class="line">                biaobai(<span class="string">&quot;女神3&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;女神3答应了，邓哥很开心!&quot;</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;邓哥表示生无可恋!!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    邓哥心中有二十个女神，他决定用更加高效的办法</span></span><br><span class="line"><span class="comment">    他同时给二十个女神表白，如果有女神同意，就拒绝其他的女神</span></span><br><span class="line"><span class="comment">    并且，当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析</span></span><br><span class="line"><span class="comment">    用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`邓哥向女神【<span class="subst">$&#123;god&#125;</span>】发出了表白短信`</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.05</span>) &#123;</span><br><span class="line">            <span class="comment">//女神同意拉</span></span><br><span class="line">            callback(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">3000</span> - <span class="number">1000</span>) + <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> agreeGod = <span class="literal">null</span>; <span class="comment">//同意邓哥的第一个女神</span></span><br><span class="line"><span class="keyword">const</span> results = []; <span class="comment">//用于记录回复结果的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    biaobai(<span class="string">`女神<span class="subst">$&#123;i&#125;</span>`</span>, <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        results.push(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`女神<span class="subst">$&#123;i&#125;</span>同意了`</span>)</span><br><span class="line">            <span class="keyword">if</span> (agreeGod) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`邓哥回复女神<span class="subst">$&#123;i&#125;</span>: 不好意思，刚才朋友用我手机，乱发的`</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                agreeGod = <span class="string">`女神<span class="subst">$&#123;i&#125;</span>`</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`邓哥终于找到了真爱`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`女神<span class="subst">$&#123;i&#125;</span>拒绝了`</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (results.length === <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;日志记录&quot;</span>, results)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步处理的通用模型"><a href="#异步处理的通用模型" class="headerlink" title="异步处理的通用模型"></a>异步处理的通用模型</h3><ul><li><p><code>ES</code>官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景。</p></li><li><p>值得注意的是，为了兼容旧系统，<code>ES6</code> 并不打算抛弃掉过去的做法，只是基于该模型推出一个全新的 <code>API</code>，使用该<code>API</code>，会让异步处理更加的简洁优雅。</p></li><li><p>理解该 <code>API</code>，最重要的，是理解它的异步模型</p></li></ul><ol><li><code>ES6</code> 将某一件可能发生异步操作的事情，分为两个阶段：<strong>unsettled</strong> 和 <strong>settled</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111633853.png"></li><li><strong>unsettled</strong>： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事</li><li><strong>settled</strong>：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转</li><li>事情总是从 未决阶段 逐步发展到 已决阶段的。并且，未决阶段拥有控制何时通向已决阶段的能力。</li></ol></li><li><strong>ES6</strong>将事情划分为三种状态： <strong>pending</strong>、<strong>resolved</strong>、<strong>rejected</strong><ol><li><strong>pending</strong>: 挂起，处于未决阶段，则表示这件事情还在挂起（最终的结果还没出来）</li><li><strong>resolved</strong>：已处理，已决阶段的一种状态，表示整件事情已经出现结果，并是一个可以按照正常逻辑进行下去的结果</li><li><strong>rejected</strong>：已拒绝，已决阶段的一种状态，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误</li></ol></li></ol><ul><li>既然未决阶段有权力决定事情的走向，因此，未决阶段可以决定事情最终的状态！</li><li>我们将 把事情变为<code>resolved</code>状态的过程叫做：<strong>resolve</strong>，推向该状态时，可能会传递一些数据</li><li>我们将 把事情变为<code>rejected</code>状态的过程叫做：<strong>reject</strong>，推向该状态时，同样可能会传递一些数据，通常为错误信息</li></ul><p><strong>始终记住，无论是阶段，还是状态，是不可逆的！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111634957.png"></p><ol start="3"><li>当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。<ol><li><strong>resolved</strong>状态：这是一个正常的已决状态，后续处理表示为 <strong>thenable</strong></li><li><strong>rejected</strong>状态：这是一个非正常的已决状态，后续处理表示为 <strong>catchable</strong></li></ol></li></ol><p>后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111632530.png"></p><ol start="4"><li>整件事称之为<strong>Promise</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111635604.png"></p><p><strong>理解上面的概念，对学习Promise至关重要！</strong></p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="Promise的基本使用"><a href="#Promise的基本使用" class="headerlink" title="Promise的基本使用"></a>Promise的基本使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 未决阶段的处理</span></span><br><span class="line">    <span class="comment">// 通过调用resolve函数将Promise推向已决阶段的resolved状态</span></span><br><span class="line">    <span class="comment">// 通过调用reject函数将Promise推向已决阶段的rejected状态</span></span><br><span class="line">    <span class="comment">// resolve和reject均可以传递最多一个参数，表示推向状态的数据</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pro.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行</span></span><br><span class="line">    <span class="comment">//data为状态数据</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行</span></span><br><span class="line">    <span class="comment">//err为状态数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><ul><li><p>未决阶段的处理函数是同步的，会立即执行</p></li><li><p><code>thenable</code>和<code>catchable</code>函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列</p></li><li><p><code>pro.then</code>可以只添加<code>thenable</code>函数，<code>pro.catch</code>可以单独添加<code>catchable</code>函数</p></li><li><p>在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向<code>rejected</code>，并会被<code>catchable</code>捕获</p></li><li><p>一旦状态推向了已决阶段，无法再对状态做任何更改</p></li><li><p><strong>Promise并没有消除回调，只是让回调变得可控</strong></p></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">                <span class="comment">//女神同意拉</span></span><br><span class="line">                resolve(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//resolve</span></span><br><span class="line">                resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">biaobai(<span class="string">&quot;女神1&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辅助函数,把传进来的对象拼接成url的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toData</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = i + <span class="string">&quot;=&quot;</span> + obj[i];</span><br><span class="line">        arr.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装Ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//指定提交方式的默认值</span></span><br><span class="line">        obj.type = obj.type || <span class="string">&quot;get&quot;</span>;</span><br><span class="line">        <span class="comment">//设置是否异步，默认为true(异步)</span></span><br><span class="line">        obj.async = obj.async || <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//设置数据的默认值</span></span><br><span class="line">        obj.data = obj.data || <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 根据不同的浏览器创建XHR对象</span></span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">            <span class="comment">// 非IE浏览器</span></span><br><span class="line">            xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// IE浏览器</span></span><br><span class="line">            xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区分get和post,发送HTTP请求</span></span><br><span class="line">        <span class="keyword">if</span> (obj.type === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">            xhr.open(obj.type, obj.url, obj.async);</span><br><span class="line">            xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> data = toData(obj.data);</span><br><span class="line">            xhr.send(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> url = obj.url + <span class="string">&quot;?&quot;</span> + toData(obj.data);</span><br><span class="line">            xhr.open(obj.type, url, obj.async);</span><br><span class="line">            xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收返回过来的数据</span></span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(xhr.status)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;./data/students.json?name=李华&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const pro = new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&quot;未决阶段&quot;)</span></span><br><span class="line"><span class="comment">//     resolve(123);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// pro.then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     // pro的状态是resolved</span></span><br><span class="line"><span class="comment">//     console.log(data);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// pro的状态是pending</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// pro的状态是pending</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// pro的状态是pending</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            resolve(<span class="number">123</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;asdfasdf&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//pro: resolved</span></span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// pro: rejected</span></span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    resolve(<span class="number">1</span>); <span class="comment">//无效</span></span><br><span class="line">    reject(<span class="number">2</span>); <span class="comment">//无效</span></span><br><span class="line">    resolve(<span class="number">3</span>); <span class="comment">//无效</span></span><br><span class="line">    reject(<span class="number">4</span>); <span class="comment">//无效</span></span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise的串联"><a href="#Promise的串联" class="headerlink" title="Promise的串联"></a>Promise的串联</h4><p>当后续的Promise需要用到之前的<code>Promise</code>的处理结果时，需要<code>Promise</code>的串联</p><p><code>Promise</code>对象中，无论是<code>then</code>方法还是<code>catch</code>方法，它们都具有返回值，返回的是一个全新的<code>Promise</code>对象，它的状态满足下面的规则：</p><ol><li>如果当前的<code>Promise</code>是未决的，得到的新的Promise是挂起状态</li><li>如果当前的<code>Promise</code>是已决的，会运行响应的后续处理函数，并将后续处理函数的结果（返回值）作为<code>resolved</code>状态数据，应用到新的<code>Promise</code>中；如果后续处理函数发生错误，则把返回值作为<code>rejected</code>状态数据，应用到新的<code>Promise</code>中。</li></ol><p><strong>后续的Promise一定会等到前面的Promise有了后续处理结果后，才会变成已决状态</strong></p><p>如果前面的<code>Promise</code>的后续处理，返回的是一个<code>Promise</code>，则返回的新的<code>Promise</code>状态和后续处理返回的<code>Promise</code>状态保持一致。</p><ul><li>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> pro2 = pro1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result * <span class="number">2</span></span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err * <span class="number">3</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        pro1.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err * <span class="number">2</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//pro2类型：Promise对象</span></span><br><span class="line">        <span class="comment">//pro2的状态：</span></span><br><span class="line">        pro2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result * <span class="number">2</span>), <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err * <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pro2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pro1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;结果出来了，得到的是一个Promise&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> pro2;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">                <span class="comment">//女神同意拉</span></span><br><span class="line">                resolve(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//resolve</span></span><br><span class="line">                resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> gods = [<span class="string">&quot;女神1&quot;</span>, <span class="string">&quot;女神2&quot;</span>, <span class="string">&quot;女神3&quot;</span>, <span class="string">&quot;女神4&quot;</span>, <span class="string">&quot;女神5&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> pro;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gods.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">        pro = biaobai(gods[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pro = pro.then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resp === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resp) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;gods[i]&#125;</span>同意了`</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;gods[i]&#125;</span>拒绝了`</span>)</span><br><span class="line">            <span class="keyword">if</span> (i &lt; gods.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> biaobai(gods[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise的其他api"><a href="#Promise的其他api" class="headerlink" title="Promise的其他api"></a>Promise的其他api</h4><ul><li><p>原型成员 (实例成员)</p><ul><li><strong>then</strong>：注册一个后续处理函数，当<code>Promise</code>为<code>resolved</code>状态时运行该函数</li><li><strong>catch</strong>：注册一个后续处理函数，当<code>Promise</code>为<code>rejected</code>状态时运行该函数</li><li><strong>finally</strong>：[<code>ES2018</code>]注册一个后续处理函数（无参），当<code>Promise</code>为已决时运行该函数</li></ul></li><li><p>构造函数成员 （静态成员）</p></li><li><p><strong>resolve</strong>(数据)：该方法返回一个<code>resolved</code>状态的<code>Promise</code>，传递的数据作为状态数据</p><ul><li>特殊情况：如果传递的数据是<code>Promise</code>，则直接返回传递的<code>Promise</code>对象</li></ul></li><li><p><strong>reject</strong>(数据)：该方法返回一个<code>rejected</code>状态的<code>Promise</code>，传递的数据作为状态数据</p></li><li><p>**all(iterable)**：这个方法返回一个新的<code>promise</code>对象，该<code>promise</code>对象在<code>iterable</code>参数对象里所有的<code>promise</code>对象都成功的时候才会触发成功，一旦有任何一个<code>iterable</code>里面的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>iterable</code>里所有promise返回值的数组作为成功回调的返回值，顺序跟<code>iterable</code>的顺序保持一致；如果这个新的<code>promise</code>对象触发了失败状态，它会把<code>iterable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。<code>Promise.all</code>方法常被用于处理多个<code>promise</code>对象的状态集合。</p></li><li><p>**race(iterable)**：当<code>iterable</code>参数里的任意一个子<code>promise</code>被成功或失败后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promise</code>绑定的相应句柄，并返回该<code>promise</code>对象</p></li><li><p>例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const pro = new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     resolve(1);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">//等效于：</span></span><br><span class="line"><span class="comment">// const pro = Promise.resolve(1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const pro = new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     reject(1);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">//等效于：</span></span><br><span class="line"><span class="comment">// const pro = Promise.reject(1);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// const pro = Promise.resolve(p);</span></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">const</span> pro = p;</span><br><span class="line"><span class="built_in">console</span>.log(pro === p)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proms = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    proms.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i, <span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                resolve(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i, <span class="string">&quot;失败&quot;</span>)</span><br><span class="line">                reject(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getRandom(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等到所有的promise变成resolved状态后输出: 全部完成</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">Promise</span>.all(proms)</span><br><span class="line">pro.then(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;全部完成&quot;</span>, datas);</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;有失败的&quot;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proms);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proms = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    proms.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i, <span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                resolve(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i, <span class="string">&quot;失败&quot;</span>)</span><br><span class="line">                reject(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getRandom(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等到所有的promise变成resolved状态后输出: 全部完成</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">Promise</span>.race(proms)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;有人完成了&quot;</span>, data);</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;有人失败了&quot;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proms);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邓哥心中有二十个女神，他决定用更加高效的办法</span></span><br><span class="line"><span class="comment">他同时给二十个女神表白，如果有女神同意，就拒绝其他的女神</span></span><br><span class="line"><span class="comment">并且，当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析</span></span><br><span class="line"><span class="comment">用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`邓哥向女神【<span class="subst">$&#123;god&#125;</span>】发出了表白短信`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.05</span>) &#123;</span><br><span class="line">                <span class="comment">//女神同意拉</span></span><br><span class="line">                <span class="built_in">console</span>.log(god, <span class="string">&quot;同意&quot;</span>)</span><br><span class="line">                resolve(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(god, <span class="string">&quot;拒绝&quot;</span>)</span><br><span class="line">                resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">3000</span> - <span class="number">1000</span>) + <span class="number">1000</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proms = [];</span><br><span class="line"><span class="keyword">let</span> hasAgree = <span class="literal">false</span>; <span class="comment">//是否有女神同意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> pro = biaobai(<span class="string">`女神<span class="subst">$&#123;i&#125;</span>`</span>).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasAgree) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;发错了短信，邓哥很机智的拒绝了&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hasAgree = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;邓哥很开心，终于成功了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;)</span><br><span class="line">    proms.push(pro);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(proms).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;日志记录&quot;</span>, results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise.all可以将多个Promise实例包装成一个新的Promise实例</span></span><br><span class="line"><span class="comment">// 同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组</span></span><br><span class="line"><span class="comment">// 而失败的时候则返回最先被reject失败状态的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reason,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Math</span>.random() * <span class="number">100</span> &gt; <span class="number">50</span> ? reason(x) : reject(x)</span><br><span class="line">        &#125;,<span class="number">100</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oP = <span class="built_in">Promise</span>.all([test(<span class="string">&#x27;a&#x27;</span>),test(<span class="string">&#x27;b&#x27;</span>),test(<span class="string">&#x27;c&#x27;</span>)]);</span><br><span class="line">oP.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顾名思义：Promise.race就是赛跑的意思，意思就是说</span></span><br><span class="line"><span class="comment">// Promise.race([p1,p2,p3])里那个结果获得的快，就返回那个结果</span></span><br><span class="line"><span class="comment">// 不管结果本身是成功状态还是失败状态</span></span><br><span class="line"><span class="built_in">Promise</span>.race([test(<span class="string">&#x27;a&#x27;</span>),test(<span class="string">&#x27;b&#x27;</span>),test(<span class="string">&#x27;c&#x27;</span>)]).then(<span class="function">(<span class="params">val</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val,<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason,<span class="string">&#x27;no&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="扩展手写Promise"><a href="#扩展手写Promise" class="headerlink" title="[扩展手写Promise]"></a>[扩展手写Promise]</h4><h5 id="ES6之手写Promise"><a href="#ES6之手写Promise" class="headerlink" title="ES6之手写Promise"></a>ES6之手写Promise</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyPromise = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>,</span><br><span class="line">        RESOLVED = <span class="string">&quot;resolved&quot;</span>,</span><br><span class="line">        REJECTED = <span class="string">&quot;rejected&quot;</span>,</span><br><span class="line">        PromiveValue = <span class="built_in">Symbol</span>(<span class="string">&quot;PromiseValue&quot;</span>), <span class="comment">//状态数据</span></span><br><span class="line">        PromiseStatus = <span class="built_in">Symbol</span>(<span class="string">&quot;PromiseStatus&quot;</span>),</span><br><span class="line">        thenables = <span class="built_in">Symbol</span>(<span class="string">&quot;thenables&quot;</span>), <span class="comment">//thenable</span></span><br><span class="line">        catchables = <span class="built_in">Symbol</span>(<span class="string">&quot;catchbles&quot;</span>), <span class="comment">//catchables</span></span><br><span class="line">        changeStatus = <span class="built_in">Symbol</span>(<span class="string">&quot;changeStatus&quot;</span>),<span class="comment">//当前状态</span></span><br><span class="line">        settleHandle = <span class="built_in">Symbol</span>(<span class="string">&quot;settleHandle&quot;</span>), <span class="comment">//后续处理的通用函数</span></span><br><span class="line">        linkPromise = <span class="built_in">Symbol</span>(<span class="string">&quot;linkPromise&quot;</span>);  <span class="comment">//创建串联的Promise</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 改变当前Promise的状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>newStatus </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>newValue </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>queue 执行的作业队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        [changeStatus](newStatus, newValue, queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>[PromiseStatus] !== PENDING) &#123;</span><br><span class="line">                <span class="comment">//状态无法变更</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>[PromiseStatus] = newStatus;</span><br><span class="line">            <span class="built_in">this</span>[PromiveValue] = newValue;</span><br><span class="line">            <span class="comment">//执行相应队列中的函数</span></span><br><span class="line">            queue.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler(newValue));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>executor 未决阶段（pending状态）下的处理函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>[PromiseStatus] = PENDING;</span><br><span class="line">            <span class="built_in">this</span>[PromiveValue] = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="built_in">this</span>[thenables] = []; <span class="comment">//后续处理函数的数组 -&gt; resolved</span></span><br><span class="line">            <span class="built_in">this</span>[catchables] = []; <span class="comment">//后续处理函数的数组 -&gt; rejected</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> resolve = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>[changeStatus](RESOLVED, data, <span class="built_in">this</span>[thenables]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>[changeStatus](REJECTED, reason, <span class="built_in">this</span>[catchables]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executor(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理 后续处理函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>handler 后续处理函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>immediatelyStatus 需要立即执行的状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>queue 作业队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        [settleHandle](handler, immediatelyStatus, queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>[PromiseStatus] === immediatelyStatus) &#123;</span><br><span class="line">                <span class="comment">//直接运行</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    handler(<span class="built_in">this</span>[PromiveValue]);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.push(handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [linkPromise](thenalbe, catchable) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">data, handler, resolve, reject</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = handler(data); <span class="comment">//得到当前Promise的处理结果</span></span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        result.then(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">                            resolve(d)</span><br><span class="line">                        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                            reject(err);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>[settleHandle](<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    exec(data, thenalbe, resolve, reject);</span><br><span class="line">                &#125;, RESOLVED, <span class="built_in">this</span>[thenables])</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>[settleHandle](<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                    exec(reason, catchable, resolve, reject);</span><br><span class="line">                &#125;, REJECTED, <span class="built_in">this</span>[catchables])</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">then</span>(<span class="params">thenable, catchable</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>[linkPromise](thenable, catchable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span>(catchable) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>[linkPromise](<span class="literal">undefined</span>, catchable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> results = proms.map(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">                        <span class="attr">result</span>: <span class="literal">undefined</span>,</span><br><span class="line">                        <span class="attr">isResolved</span>: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                        obj.result = data;</span><br><span class="line">                        obj.isResolved = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">//判断是否所有的全部完成</span></span><br><span class="line">                        <span class="keyword">const</span> unResolved = results.filter(<span class="function"><span class="params">r</span> =&gt;</span> !r.isResolved)</span><br><span class="line">                        <span class="keyword">if</span> (unResolved.length === <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//全部完成</span></span><br><span class="line">                            resolve(results.map(<span class="function"><span class="params">r</span> =&gt;</span> r.result));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                        reject(reason);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                proms.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">                    p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                        resolve(data);</span><br><span class="line">                    &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(data);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                reject(reason);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h5 id="ES5之手写Promise"><a href="#ES5之手写Promise" class="headerlink" title="ES5之手写Promise"></a>ES5之手写Promise</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生Promise特性</span></span><br><span class="line"><span class="comment">//new</span></span><br><span class="line"><span class="comment">// 参数：executor 同步执行，executor中要有两个参数(resolve,reject)</span></span><br><span class="line"><span class="comment">// 触发Fulfilled Rejected状态（成功，失败），没有触发之前是pending等待状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作</span></span><br><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line"><span class="comment">// then异步执行，抛出错误</span></span><br><span class="line"><span class="comment">// 空then</span></span><br><span class="line"><span class="comment">// 返回值是对象时</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将self事先等于window</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态：一开始为进行中pending</span></span><br><span class="line">    self.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了then可以调用函数的参数，为self声明两个参数来接收两个函数的参数</span></span><br><span class="line">    self.resolveValue = <span class="literal">null</span>;</span><br><span class="line">    self.rejectReason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调数组，当注册函数时不执行，先存入数组，当真正执行函数时，在执行</span></span><br><span class="line">    self.ResolveCallBackList = [];</span><br><span class="line">    self.RejectCallBackList = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//只有状态===pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            self.status = <span class="string">&#x27;Fulfilled&#x27;</span>; <span class="comment">//成功</span></span><br><span class="line">            <span class="comment">//将value赋值给self的resolveValue，以便then使用</span></span><br><span class="line">            self.resolveValue = value;</span><br><span class="line">            <span class="comment">// 执行回调函数中的函数</span></span><br><span class="line">            self.ResolveCallBackList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">                ele();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//只有状态===pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            self.status = <span class="string">&#x27;Rejected&#x27;</span>; <span class="comment">//失败</span></span><br><span class="line">            <span class="comment">// 将reason赋值给self的rejectReason，以便then使用</span></span><br><span class="line">            self.rejectReason = reason;</span><br><span class="line">            <span class="comment">// 执行回调函数中的函数</span></span><br><span class="line">            self.RejectCallBackList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">                ele();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用try&#123;&#125;catch&#123;&#125;判断错误，当executor抛出错误时，执行reject()来打印错误</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理返回值函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ResolutionReturnPromise</span>(<span class="params">nextPromise, returnValue, res, rej</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果返回值是Promise对象时</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        returnValue.then(</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                res(val);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">                rej(reason);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回值不是Promise对象时，执行res</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res(returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then函数，参数：onFulfilled,onRejected两个函数参数，分别代表完成、拒绝</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 空then处理方法：</span></span><br><span class="line">    <span class="comment">//若没有onFulfilled时则返回参数val</span></span><br><span class="line">    <span class="comment">//若onRejected则抛出参数reason错误</span></span><br><span class="line">    <span class="keyword">if</span> (!onFulfilled) &#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!onRejected) &#123;</span><br><span class="line">        onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将self事先等于window</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式操作</span></span><br><span class="line">    <span class="comment">// 拿到上一次函数返回结果，用于下一次then的参数</span></span><br><span class="line">    <span class="keyword">var</span> nextPromise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">res, rej</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当状态为Fulfilled时，执行onFulfilled完成</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;Fulfilled&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//异步方式执行操作：setTimeout</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 在then中抛出错误时，在下一个then中的reject函数中打印</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//拿到此次函数的返回结果，用于下一次then的参数</span></span><br><span class="line">                    <span class="keyword">var</span> nextResolveValue = onFulfilled(self.resolveValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理返回值函数</span></span><br><span class="line">                    ResolutionReturnPromise(nextPromise, nextResolveValue, res, rej);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    //拿到此次函数的返回结果，用于下一次then的参数</span></span><br><span class="line"><span class="comment">                    var nextResolveValue = onFulfilled(self.resolveValue);</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    //执行下一次函数时，使用上一次函数返回结果作为参数</span></span><br><span class="line"><span class="comment">                    res(nextResolveValue); */</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    rej(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为Rjected时，执行onRejected拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;Rejected&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> nextRejectValue = onRejected(self.rejectReason);</span><br><span class="line">                    ResolutionReturnPromise(nextPromise, nextRejectValue, res, rej);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    rej(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步操作实现</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 将函数推入回调函数</span></span><br><span class="line">            self.ResolveCallBackList.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> nextResolveValue = onFulfilled(self.resolveValue);</span><br><span class="line">                        ResolutionReturnPromise(nextPromise, nextResolveValue, res, rej);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        rej(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            self.RejectCallBackList.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> nextRejectValue = onRejected(self.rejectReason);</span><br><span class="line">                        ResolutionReturnPromise(nextPromise, nextRejectValue, res, rej);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        rej(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextPromise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 race</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (promiseArr.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">            resolve(ele).then(</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                    resolve(res);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 all</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> results = [], <span class="comment">//执行数组</span></span><br><span class="line">        promiseArrCount = <span class="number">0</span>, <span class="comment">//计算函数总执行次数</span></span><br><span class="line">        promiseArrLength = promiseArr.length; <span class="comment">//函数参数总长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">            resolve(ele).then(</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                    promiseArrCount++;</span><br><span class="line">                    results.push(res);</span><br><span class="line">                    <span class="comment">//当所有函数都正确执行了，resolve执行输出所有结果</span></span><br><span class="line">                    <span class="keyword">if</span> (promiseArrCount === promiseArrLength) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(results);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><ul><li><p><code>async</code>函数，是<code>Generator</code>语法糖，通过<code>babel</code>编译后可以看出它就是<code>Generator+promise+Co</code>思想实现的，配合<code>await</code>使用</p></li><li><p>目的：优雅的解决异步操作问题</p></li></ul><blockquote><p><code>async</code> 和 <code>await</code> 是 <code>ES2016</code> 新增两个关键字，它们借鉴了 <code>ES2015</code> 中生成器在实际开发中的应用，目的是简化 <code>Promise api</code> 的使用，并非是替代 <code>Promise</code>。</p></blockquote><h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><ul><li><p>目的是简化在函数的返回值中对Promise的创建</p></li><li><p><strong>async</strong> 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 <strong>Promise</strong> 对象。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><ul><li><p><strong>await关键字必须出现在async函数中！！！！</strong></p></li><li><p><strong>await</strong>用在某个表达式之前，如果表达式是一个<strong>Promise</strong>，则得到的是<strong>thenable</strong>中的状态数据。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> test1();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        test1().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = data;</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果<code>await</code>的表达式不是<code>Promise</code>，则会将其使用<code>Promise.resolve</code>包装后按照规则运行</p><ul><li>实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">                <span class="comment">//女神同意拉</span></span><br><span class="line">                resolve(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//resolve</span></span><br><span class="line">                resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">   有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">   用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> gods = [<span class="string">&quot;女神1&quot;</span>, <span class="string">&quot;女神2&quot;</span>, <span class="string">&quot;女神3&quot;</span>, <span class="string">&quot;女神4&quot;</span>, <span class="string">&quot;女神5&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gods.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> g = gods[i];</span><br><span class="line">        <span class="comment">// 当前循环等待的Promise没有resolve，下一次循环不运行</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> biaobai(g);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;g&#125;</span>同意了，不用再表白了！！！`</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;g&#125;</span>没有同意`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> getPromise();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;正常状态&quot;</span>, result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;错误状态&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="promise函数化"><a href="#promise函数化" class="headerlink" title="promise函数化"></a>promise函数化</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用NodeJs开始时，使用promise为中心的开发方式，带来的好处是大家都使用promise进行异步方案的解决，不用考虑回调callback，但是还是有一些库没有用promise来实现，所以就需要使用一个函数来把那些库要使用的函数来进行promise实现，不过promisify只可以把一个函数来进行promise转换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 在node中参数基本上都是error-firstb标准形式，所以基本可以写成(err,data)形式</span></span><br><span class="line">func(...arg, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(err) &#123;</span><br><span class="line">rej(err);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let readFile = promisify(fs.readFile);</span></span><br><span class="line"><span class="comment">// readFile(&#x27;./number.txt&#x27;,&#x27;utf-8&#x27;).then((val) =&gt; &#123;</span></span><br><span class="line"><span class="comment">// console.log(val);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// promisifyAll 函数可以把一个库中所有的函数都promise化并添加成另外一个函数，</span></span><br><span class="line"><span class="comment">// promisifyAll 函数可以为一个方法中的所有函数另外添加一个Async（promise化）的函数，可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisifyAll</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">let</span> fn = obj[key];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">obj[key + <span class="string">&#x27;Async&#x27;</span>] = promisify(fn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">promisifyAll(fs);</span><br><span class="line"><span class="comment">// fs.readFile -&gt; readFileAsync</span></span><br><span class="line"><span class="comment">// fs.writeFile -&gt; readFileAsync</span></span><br><span class="line"></span><br><span class="line">fs.readFileAsync(<span class="string">&#x27;./number.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>).then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bluebird库中有这个promisify函数和promisifyArr函数</span></span><br><span class="line"><span class="comment">// let bluebird = require(&#x27;bluebird&#x27;);</span></span><br><span class="line"><span class="comment">// bluebird.promisify(fs.readFile);</span></span><br></pre></td></tr></table></figure><h2 id="FetchApi"><a href="#FetchApi" class="headerlink" title="FetchApi"></a>FetchApi</h2><h3 id="Fetch-Api-概述"><a href="#Fetch-Api-概述" class="headerlink" title="Fetch Api 概述"></a>Fetch Api 概述</h3><ul><li><p><strong>XMLHttpRequest的问题</strong></p><ul><li>所有的功能全部集中在同一个对象上，容易书写出混乱不易维护的代码</li><li>采用传统的事件驱动模式，无法适配新的 <code>Promise Api</code></li></ul></li><li><p><strong>Fetch Api 的特点</strong></p><ul><li>并非取代 <code>AJAX</code>，而是对 <code>AJAX</code> 传统 <code>API</code> 的改进</li><li>精细的功能分割：头部信息、请求信息、响应信息等均分布到不同的对象，更利于处理各种复杂的 <code>AJAX</code> 场景</li><li>使用 <code>Promise Api</code>，更利于异步代码的书写</li><li><code>Fetch Api</code> 并非 <code>ES6</code> 的内容，属于 <code>HTML5</code> 新增的 <code>Web Api</code></li><li>需要掌握网络通信的知识</li></ul></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><blockquote><p>请求测试地址：<a href="http://101.132.72.36:5100/api/local">http://101.132.72.36:5100/api/local</a></p><p>​            <a href="http://jsonplaceholder.typicode.com/posts">http://jsonplaceholder.typicode.com/posts</a></p></blockquote><p>使用 <code>fetch</code> 函数即可立即向服务器发送网络请求</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>该函数有两个参数：</p><ol><li>必填，字符串，请求地址</li><li>选填，对象，请求配置</li></ol><p><strong>请求配置对象</strong></p><ul><li><strong>method</strong>：字符串，请求方法，默认值<code>GET</code></li><li><strong>headers</strong>：对象，请求头信息</li><li><strong>body</strong>: 请求体的内容，必须匹配请求头中的 <code>Content-Type</code></li><li><strong>mode</strong>：字符串，请求模式<ul><li><strong>cors</strong>：默认值，配置为该值，会在请求头中加入 <code>origin</code> 和 <code>referer</code></li><li><strong>no-cors</strong>：配置为该值，不会在请求头中加入 <code>origin</code> 和 <code>referer</code>，跨域的时候可能会出现问题</li><li><strong>same-origin</strong>：指示请求必须在同一个域中发生，如果请求其他域，则会报错</li></ul></li><li><strong>credentials</strong>: 如何携带凭据（<code>cookie</code>）<ul><li><strong>omit</strong>：默认值，不携带<code>cookie</code></li><li><strong>same-origin</strong>：请求同源地址时携带<code>cookie</code></li><li><strong>include</strong>：请求任何地址都携带<code>cookie</code></li></ul></li><li><strong>cache</strong>：配置缓存模式<ul><li><strong>default</strong>: 表示<code>fetch</code>请求之前将检查下<code>http</code>的缓存.</li><li><strong>no-store</strong>: 表示<code>fetch</code>请求将完全忽略<code>http</code>缓存的存在. 这意味着请求之前将不再检查下<code>http</code>的缓存, 拿到响应后, 它也不会更新<code>http</code>缓存.</li><li><strong>no-cache</strong>: 如果存在缓存, 那么<code>fetch</code>将发送一个条件查询<code>request</code>和一个正常的<code>request</code>, 拿到响应后, 它会更新<code>http</code>缓存.</li><li><strong>reload</strong>: 表示fetch请求之前将忽略<code>http</code>缓存的存在, 但是请求拿到响应后, 它将主动更新<code>http</code>缓存.</li><li><strong>force-cache</strong>: 表示<code>fetch</code>请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的<code>request</code>.</li><li><strong>only-if-cached</strong>: 表示<code>fetch</code>请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”<code>same-origin</code>”时有效).</li></ul></li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><strong>fetch</strong> 函数返回一个 <strong>Promise</strong> 对象</p><ul><li>当收到服务器的返回结果后，Promise 进入resolved状态，状态数据为 Response 对象</li><li>当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息</li></ul><p><strong>Response对象</strong></p><ul><li><strong>ok</strong>：<code>boolean</code>，当响应消息码在<code>200~299</code>之间时为<code>true</code>，其他为<code>false</code></li><li><strong>status</strong>：<code>number</code>，响应的状态码</li><li>**text()**：用于处理文本格式的 <code>Ajax</code> 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 <code>string</code> 对象的 <code>Promise</code>。</li><li>**blob()**：用于处理二进制文件格式（比如图片或者电子表格）的 <code>Ajax</code> 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 <code>blob</code> 对象的 <code>Promise</code>。</li><li>**json()**：用于处理 <code>JSON</code> 格式的 <code>Ajax</code> 的响应。它将 <code>JSON</code> 数据流转换为一个被解决为 <code>JavaScript</code> 对象的promise。</li><li>**redirect()**：可以用于重定向到另一个 <code>URL</code>。它会创建一个新的 <code>Promise</code>，以解决来自重定向的 <code>URL</code> 的响应。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;获得信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(url)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h3><p>除了使用基本的<code>fetch</code>方法，还可以通过创建一个<code>Request</code>对象来完成请求（实际上，<code>fetch</code>的内部会帮你创建一个<code>Request</code>对象）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Request(url地址, 配置)</span><br></pre></td></tr></table></figure><p>注意点：</p><p>尽量保证每次请求都是一个新的<code>Request</code>对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;获得信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        req = <span class="keyword">new</span> Request(url, &#123;&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(req);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo())</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;得到所有的省份数据&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        req = <span class="keyword">new</span> Request(url, &#123;&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(req);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// const resp = await fetch(getRequestInfo())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resp = <span class="keyword">new</span> Response(<span class="string">`[</span></span><br><span class="line"><span class="string">    &#123;&quot;id&quot;:1, &quot;name&quot;:&quot;北京&quot;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;天津&quot;&#125;</span></span><br><span class="line"><span class="string">]`</span>, &#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h3><blockquote><p>在<strong>Request</strong>和<strong>Response</strong>对象内部，会将传递的请求头对象，转换为<strong>Headers</strong></p></blockquote><p><strong>Headers</strong>对象中的方法：</p><ul><li>**has(key)**：检查请求头中是否存在指定的key值</li><li><strong>get(key)</strong>: 得到请求头中对应的key值</li><li>**set(key, value)**：修改对应的键值对</li><li>**append(key, value)**：添加对应的键值对</li><li>**keys()**：得到所有的请求头键的集合</li><li>**values()**：得到所有的请求头中的值的集合</li><li>**entries()**：得到所有请求头中的键值对的集合</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;获得信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCommonHeaders</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHeaders</span>(<span class="params">headers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> datas = headers.entries();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> datas) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;pair[<span class="number">0</span>]&#125;</span>，value: <span class="subst">$&#123;pair[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        <span class="keyword">const</span> headers = getCommonHeaders();</span><br><span class="line">        headers.set(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>)</span><br><span class="line">        req = <span class="keyword">new</span> Request(url, &#123;</span><br><span class="line">            headers</span><br><span class="line">        &#125;);</span><br><span class="line">        printHeaders(headers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo())</span><br><span class="line">    printHeaders(resp.headers);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>流程：</p><ol><li>客户端将文件数据发送给服务器</li><li>服务器保存上传的文件数据到服务器端</li><li>服务器响应给客户端一个文件访问地址</li></ol><blockquote><p>测试地址：<a href="http://101.132.72.36:5100/api/upload">http://101.132.72.36:5100/api/upload</a><br>键的名称（表单域名称）：<strong>imagefile</strong></p></blockquote><p>请求方法：<code>POST</code><br>请求的表单格式：<code>multipart</code> / <code>form-data</code><br>请求体中必须包含一个键值对，键的名称是服务器要求的名称，值是文件数据</p><blockquote><p><code>HTML5</code>中，<code>JS</code>仍然无法随意的获取文件数据，但是可以获取到<code>input</code>元素中，被用户选中的文件数据<br>可以利用<code>HTML5</code>提供的<code>FormData</code>构造函数来创建请求体</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;&quot;</span> alt=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;imgAvatar&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">async function upload() &#123;</span></span><br><span class="line"><span class="xml">    const inp = document.getElementById(&quot;avatar&quot;);</span></span><br><span class="line"><span class="xml">    if (inp.files.length === 0) &#123;</span></span><br><span class="line"><span class="xml">        alert(&quot;请选择要上传的文件&quot;);</span></span><br><span class="line"><span class="xml">        return;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    const formData = new FormData(); //构建请求体</span></span><br><span class="line"><span class="xml">    formData.append(&quot;imagefile&quot;, inp.files[0]);</span></span><br><span class="line"><span class="xml">    const url = &quot;http://101.132.72.36:5100/api/upload&quot;</span></span><br><span class="line"><span class="xml">    const resp = await fetch(url, &#123;</span></span><br><span class="line"><span class="xml">        method: &quot;POST&quot;,</span></span><br><span class="line"><span class="xml">        body: formData //自动修改请求头</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">    const result = await resp.json();</span></span><br><span class="line"><span class="xml">    return result;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">document.querySelector(&quot;button&quot;).onclick = async function() &#123;</span></span><br><span class="line"><span class="xml">    const result = await upload();</span></span><br><span class="line"><span class="xml">    const img = document.getElementById(&quot;imgAvatar&quot;)</span></span><br><span class="line"><span class="xml">    img.src = result.path;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><ul><li><p>什么是迭代？</p><ul><li>从一个数据集合中按照一定的顺序，不断取出数据的过程</li></ul></li><li><p>迭代和遍历的区别？</p><ul><li>迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完</li><li>遍历强调的是要把整个数据依次全部取出</li></ul></li><li><p>迭代器</p><ul><li>对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象</li><li>依照与迭代模式的思想而实现，分为内部迭代器和外部迭代器</li><li>内部迭代器：<ul><li>本身是函数，该函数内部定义好迭代规则，完全接手整个迭代过程，外部迭代只需要一次初始调用</li><li><code> Array.prototype.forEach</code>，<code>jQuery.each</code>内部迭代器</li></ul></li><li>外部迭代器：<ul><li>本身是函数，执行返回迭代对象，迭代下一个元素必须显示调用，调用复杂度增加，但灵活性增加</li><li><code>function outerIterator() &#123;&#125;</code> 外部迭代器</li></ul></li></ul></li><li><p>迭代模式</p><ul><li><p>一种设计模式，用于统一迭代过程，并规范了迭代器规格：</p></li><li><p>迭代器应该具有得到下一个数据的能力</p></li><li><p>迭代器应该具有判断是否还有后续数据的能力</p></li><li><p>提供一种方法可以顺序获得聚合对象的各个元素，是一种最简单也最常见的设计模式，它可以让用户透过特定的接口寻访集合中的每一个元素而不用了解底层的实现</p></li></ul></li><li><p>迭代器目的：</p><ul><li>从迭代模式思想中可以看出，就是要标准化迭代操作</li><li>举个例子：服务端提供数组数据给前端，前端for循环遍历，但由于业务变化，使得数据结构发生变化，返回对象或者<code>set</code>、<code>map</code>，导致前端遍历代码大量重写</li><li>解决方案<ul><li><code>ES6</code>引入<code>Interator</code>，部署在<code>NodeList</code>、<code>arguments</code>、<code>Array</code>、<code>Set</code>、Map、字符串上等数据的Symbol。iterator属性</li><li><code>使得这些数据``iterable</code>可迭代了，能进行<code>for of</code>、<code>...</code>、、<code>Array.from</code>等操作</li></ul></li></ul></li></ul><h4 id="JS中的迭代器"><a href="#JS中的迭代器" class="headerlink" title="JS中的迭代器"></a>JS中的迭代器</h4><p>JS规定，如果一个对象具有<code>next</code>方法，并且该方法返回一个对象，该对象的格式如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: 值, <span class="attr">done</span>: 是否迭代完成&#125;</span><br></pre></td></tr></table></figure><p>则认为该对象是一个迭代器</p><p>含义：</p><ul><li><strong>next</strong>方法：用于得到下一个数据</li><li>返回的对象<ul><li><strong>value</strong>：下一个数据的值</li><li><strong>done：boolean</strong>，是否迭代完成</li></ul></li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">//迭代数组arr</span></span><br><span class="line"><span class="keyword">const</span> iterator = &#123;</span><br><span class="line">    <span class="attr">i</span>: <span class="number">0</span>, <span class="comment">//当前的数组下标</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = &#123;</span><br><span class="line">            <span class="attr">value</span>: arr[<span class="built_in">this</span>.i],</span><br><span class="line">            <span class="attr">done</span>: <span class="built_in">this</span>.i &gt;= arr.length</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.i++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让迭代器不断的取出下一个数据，直到没有数据为止</span></span><br><span class="line"><span class="keyword">let</span> data = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!data.done) &#123; <span class="comment">//只要没有迭代完成，则取出数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(data.value)</span><br><span class="line">    <span class="comment">//进行下一次迭代</span></span><br><span class="line">    data = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;迭代完成&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器创建函数  iterator creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;<span class="comment">//当前的数组下标</span></span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = &#123;</span><br><span class="line">                <span class="attr">value</span>: arr[i],</span><br><span class="line">                <span class="attr">done</span>: i &gt;= arr.length</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter1 = createIterator(arr1);</span><br><span class="line"><span class="keyword">const</span> iter2 = createIterator(arr2);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依次得到斐波拉契数列前面n位的值</span></span><br><span class="line"><span class="comment">// 1 1 2 3 5 8 13 .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个斐波拉契数列的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFeiboIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev1 = <span class="number">1</span>,</span><br><span class="line">        prev2 = <span class="number">1</span>, <span class="comment">//当前位置的前1位和前2位</span></span><br><span class="line">        n = <span class="number">1</span>; <span class="comment">//当前是第几位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> value;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                value = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = prev1 + prev2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> result = &#123;</span><br><span class="line">                value,</span><br><span class="line">                <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line">            prev2 = prev1;</span><br><span class="line">            prev1 = result.value;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createFeiboIterator();</span><br></pre></td></tr></table></figure><h3 id="可迭代协议-与-for-of-循环"><a href="#可迭代协议-与-for-of-循环" class="headerlink" title="可迭代协议 与 for-of 循环"></a>可迭代协议 与 for-of 循环</h3><h4 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h4><ul><li><p><strong>概念回顾</strong></p><ul><li>迭代器(<strong>iterator</strong>)：一个具有<code>next</code>方法的对象，<code>next</code>方法返回下一个数据并且能指示是否迭代完成</li><li>迭代器创建函数（<strong>iterator creator</strong>）：一个返回迭代器的函数</li></ul></li><li><p><strong>可迭代协议</strong></p><ul><li><strong>ES6</strong>规定，如果一个对象具有知名符号属性<code>Symbol.iterator</code>，并且属性值是一个迭代器创建函数，则该对象是可迭代的（<strong>iterable</strong>）</li></ul></li></ul><blockquote><p>思考：如何知晓一个对象是否是可迭代的？<br>思考：如何遍历一个可迭代对象？</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可迭代对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> propName = keys[i];</span><br><span class="line">                <span class="keyword">const</span> propValue = <span class="built_in">this</span>[propName];</span><br><span class="line">                <span class="keyword">const</span> result = &#123;</span><br><span class="line">                    <span class="attr">value</span>: &#123;</span><br><span class="line">                        propName,</span><br><span class="line">                        propValue</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">done</span>: i &gt;= keys.length</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// &#123;propName:&quot;a&quot;, propValue:1&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h4><p><strong>for-of</strong> 循环用于遍历可迭代对象，格式如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代完成后循环结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">in</span> iterable)&#123;</span><br><span class="line">    <span class="comment">//iterable：可迭代对象</span></span><br><span class="line">    <span class="comment">//item：每次迭代得到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// const iterator = arr[Symbol.iterator]();</span></span><br><span class="line"><span class="comment">// let result = iterator.next();</span></span><br><span class="line"><span class="comment">// while (!result.done) &#123;</span></span><br><span class="line"><span class="comment">//     const item = result.value; //取出数据</span></span><br><span class="line"><span class="comment">//     console.log(item);</span></span><br><span class="line"><span class="comment">//     //下一次迭代</span></span><br><span class="line"><span class="comment">//     result = iterator.next();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// const iterator = divs[Symbol.iterator]()</span></span><br><span class="line"><span class="comment">// let result = iterator.next();</span></span><br><span class="line"><span class="comment">// while (!result.done) &#123;</span></span><br><span class="line"><span class="comment">//     const item = result.value; //取出数据</span></span><br><span class="line"><span class="comment">//     console.log(item);</span></span><br><span class="line"><span class="comment">//     //下一次迭代</span></span><br><span class="line"><span class="comment">//     result = iterator.next();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> divs) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="展开运算符与可迭代对象"><a href="#展开运算符与可迭代对象" class="headerlink" title="展开运算符与可迭代对象"></a>展开运算符与可迭代对象</h4><ul><li>展开运算符可以作用于可迭代对象，这样，就可以轻松的将可迭代对象转换为数组</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> propName = keys[i];</span><br><span class="line">                <span class="keyword">const</span> propValue = <span class="built_in">this</span>[propName];</span><br><span class="line">                <span class="keyword">const</span> result = &#123;</span><br><span class="line">                    <span class="attr">value</span>: &#123;</span><br><span class="line">                        propName,</span><br><span class="line">                        propValue</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">done</span>: i &gt;= keys.length</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...obj];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(...obj);</span><br></pre></td></tr></table></figure><h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 (Generator)"></a>生成器 (Generator)</h3><ul><li>什么是生成器？<ul><li>生成器是一个通过构造函数<strong>Generator</strong>创建的对象，生成器既是一个迭代器，同时又是一个可迭代对象</li></ul></li><li>如何创建生成器？<ul><li>生成器的创建，必须使用生成器函数（<strong>Generator Function</strong>）</li></ul></li><li>如何书写一个生成器函数呢？</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个生成器函数，该函数一定返回一个生成器，就是在function和函数名之间添加*号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>生成器函数内部是如何执行的？</p><ul><li>生成器函数内部是为了给生成器的每次迭代提供的数据</li><li>每次调用生成器的<code>next</code>方法，将导致生成器函数运行到下一个<code>yield</code>关键字位置</li><li><code>yield</code>是一个关键字，该关键字只能在生成器函数内部使用，表达“产生”一个迭代数据。</li><li>函数体内部<code>yield</code>表达式，产出不同的内部状态（值）</li><li>遇到<code>yield</code>即暂停</li></ul></li><li><p>有哪些需要注意的细节？</p><ul><li><p>生成器函数可以有返回值，返回值出现在第一次<code>done</code>为<code>true</code>时的<code>value</code>属性中</p></li><li><p>调用生成器的<code>next</code>方法时，可以传递参数，传递的参数会交给<code>yield</code>表达式的返回值</p></li><li><p>第一次调用<code>next</code>方法时，传参没有任何意义</p></li><li><p>在生成器函数内部，可以调用其他生成器函数，但是要注意加上<code>*</code>号</p></li><li><p><code>function</code>和函数名之间要带<code>*</code>星号</p></li></ul></li><li><p>生成器的其他<strong>API</strong></p><ul><li><strong>return</strong>方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束</li><li><strong>throw</strong>方法：调用该方法，可以在生成器中产生一个错误</li></ul></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第1次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第2次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第3次运行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"><span class="comment">// generator.next()</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器创建函数  iterator creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter1 = createIterator(arr1);</span><br><span class="line"><span class="keyword">const</span> iter2 = createIterator(arr2);</span><br><span class="line"><span class="comment">// iter1/2.next()</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个斐波拉契数列的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createFeiboIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev1 = <span class="number">1</span>,</span><br><span class="line">        prev2 = <span class="number">1</span>, <span class="comment">//当前位置的前1位和前2位</span></span><br><span class="line">        n = <span class="number">1</span>; <span class="comment">//当前是第几位</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> newValue = prev1 + prev2</span><br><span class="line">            <span class="keyword">yield</span> newValue;</span><br><span class="line">            prev2 = prev1;</span><br><span class="line">            prev1 = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createFeiboIterator();</span><br><span class="line"><span class="comment">// iterator.next()</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第1次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第2次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第3次运行&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用return，可以提前结束生成器函数，从而提前让整个迭代过程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"><span class="comment">// generator.next()</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;函数开始&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> info = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(info)</span><br><span class="line">    info = <span class="keyword">yield</span> <span class="number">2</span> + info;</span><br><span class="line">    <span class="built_in">console</span>.log(info)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"><span class="comment">// generator.next()</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">t1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* t1();</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"><span class="comment">// generator.next()</span></span><br></pre></td></tr></table></figure><ul><li>生成器，异步任务控制</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> d = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">    <span class="comment">// //d : 1</span></span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">yield</span> fetch(<span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> resp.json();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(task)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> generator = generatorFunc();</span><br><span class="line">    <span class="keyword">let</span> result = generator.next(); <span class="comment">//启动任务（开始迭代）, 得到迭代数据</span></span><br><span class="line">    handleResult();</span><br><span class="line">    <span class="comment">//对result进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//迭代完成，不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代没有完成，分为两种情况</span></span><br><span class="line">        <span class="comment">//1. 迭代的数据是一个Promise</span></span><br><span class="line">        <span class="comment">//2. 迭代的数据是其他数据</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 迭代的数据是一个Promise</span></span><br><span class="line">            <span class="comment">//等待Promise完成后，再进行下一次迭代</span></span><br><span class="line">            result.value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                result = generator.next(data)</span><br><span class="line">                handleResult();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2. 迭代的数据是其他数据，直接进行下一次迭代</span></span><br><span class="line">            result = generator.next(result.value)</span><br><span class="line">            handleResult();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多的集合类型"><a href="#更多的集合类型" class="headerlink" title="更多的集合类型"></a>更多的集合类型</h2><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h3><blockquote><p>一直以来，<code>JS</code>只能使用数组和对象来保存多个数据，缺乏像其他语言那样拥有丰富的集合类型。因此，<code>ES6</code>新增了两种集合类型（<code>set</code> 和 <code>map</code>），用于在不同的场景中发挥作用。</p></blockquote><p><strong>set用于存放不重复的数据</strong></p><ul><li><p>简介：<code>Set</code>是<code>ES6</code>提供给我们的构造函数，能够造出一种新的存储数据的结构</p></li><li><p>特点：只有属性值，成员值唯一（不重复）</p></li><li><p>用途：可以转成数组，其本身具备去重、交集、并集，差集的作用等</p></li><li><p>如何创建<strong>set</strong>集合</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//创建一个没有任何内容的set集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(iterable); <span class="comment">//创建一个具有初始内容的set集合，内容来自于可迭代对象每一次迭代的结果</span></span><br></pre></td></tr></table></figure><ul><li><p>如何对<code>set</code>集合进行后续操作</p><ul><li><strong>add(数据)</strong>: 添加一个数据到<code>set</code>集合末尾，如果数据已存在，则不进行任何操作<ul><li><code>set</code>使用<code>Object.is</code>的方式判断两个数据是否相同，但是，针对<code>+0</code>和<code>-0</code>，<code>set</code>认为是相等</li></ul></li><li><strong>has(数据)</strong>: 判断<code>set</code>中是否存在对应的数据</li><li>**delete(数据)**：删除匹配的数据，返回是否删除成功</li><li>**clear()**：清空整个<code>set</code>集合</li><li><strong>size</strong>: 获取<code>set</code>集合中的元素数量，只读属性，无法重新赋值</li></ul></li><li><p>如何与数组进行相互转换</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([x,x,x,x,x]);</span><br><span class="line"><span class="comment">// set本身也是一个可迭代对象，每次迭代的结果就是每一项的值</span></span><br><span class="line"><span class="keyword">const</span> arr = [...s];</span><br></pre></td></tr></table></figure><ul><li><p>如何遍历</p><ul><li>使用<code>for-of</code>循环</li><li>使用<code>set</code>中的实例方法<code>forEach</code></li></ul></li><li><p>注意：<code>set</code>集合中不存在下标，因此<code>forEach</code>中的回调的第二个参数和第一个参数是一致的，均表示<code>set</code>中的每一项</p></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&quot;asdfasfasf&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">s1.add(<span class="number">1</span>);</span><br><span class="line">s1.add(<span class="number">2</span>);</span><br><span class="line">s1.add(<span class="number">3</span>);</span><br><span class="line">s1.add(<span class="number">1</span>); <span class="comment">//无效</span></span><br><span class="line">s1.add(+<span class="number">0</span>);</span><br><span class="line">s1.add(-<span class="number">0</span>); <span class="comment">//无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (const item of s1) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(item)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">s1.forEach(<span class="function">(<span class="params">item, index, s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, index, s);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;总数为：&quot;</span>, s1.size);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">45</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">46</span>, <span class="number">6</span>, <span class="number">57</span>, <span class="number">8</span>, <span class="number">55</span>, <span class="number">6</span>, <span class="number">46</span>];</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;asf23sdfgsdgfsafasdfasfasfasfsafsagfdsfg&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> s = [...new <span class="built_in">Set</span>(str)].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个数组的并集、交集、差集 （不能出现重复项），得到的结果是一个新数组</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">33</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">33</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">22</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">99</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="comment">// const result = [...new Set(arr1.concat(arr2))];</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;并集&quot;</span>, [...new <span class="built_in">Set</span>([...arr1, ...arr2])]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cross = [...new <span class="built_in">Set</span>(arr1)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.indexOf(item) &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;交集&quot;</span>, cross)</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="comment">// console.log(&quot;差集&quot;, [...new Set([...arr1, ...arr2])].filter(item =&gt; arr1.indexOf(item) &gt;= 0 &amp;&amp; arr2.indexOf(item) &lt; 0 || arr2.indexOf(item) &gt;= 0 &amp;&amp; arr1.indexOf(item) &lt; 0))</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集&quot;</span>, [...new <span class="built_in">Set</span>([...arr1, ...arr2])].filter(<span class="function"><span class="params">item</span> =&gt;</span> cross.indexOf(item) &lt; <span class="number">0</span>))</span><br></pre></td></tr></table></figure><h3 id="手写Set"><a href="#手写Set" class="headerlink" title="手写Set"></a>手写Set</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">iterator = []</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//验证是否是可迭代的对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> iterator[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;iterator&#125;</span>不是一个可迭代的对象`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._datas = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">            <span class="built_in">this</span>.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._datas.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.has(data)) &#123;</span><br><span class="line">            <span class="built_in">this</span>._datas.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(data, item)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">delete</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> element = <span class="built_in">this</span>._datas[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(element, data)) &#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                <span class="built_in">this</span>._datas.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._datas.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">forEach</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">            callback(item, item, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个数据是否相等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data1 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data2 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">isEqual</span>(<span class="params">data1, data2</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data1 === <span class="number">0</span> &amp;&amp; data2 === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.is(data1, data2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><blockquote><p>键值对（key value pair）数据集合的特点：键不可重复</p></blockquote><ul><li><p><strong>map</strong>集合专门用于存储多个键值对数据。</p></li><li><p>在<strong>map</strong>出现之前，我们使用的是对象的方式来存储键值对，键是属性名，值是属性值。</p></li><li><p>使用对象存储有以下问题：</p><ul><li>键名只能是字符串</li><li>获取数据的数量不方便</li><li>键名容易跟原型上的名称冲突</li></ul></li><li><p>如何创建<strong>Map</strong></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//创建一个空的map</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(iterable); <span class="comment">//创建一个具有初始内容的map，初始内容来自于可迭代对象每一次迭代的结果，但是，它要求每一次迭代的结果必须是一个长度为2的数组，数组第一项表示键，数组的第二项表示值</span></span><br></pre></td></tr></table></figure><ul><li><p>如何进行后续操作</p><ul><li><strong>size</strong>：只读属性，获取当前<code>map</code>中键的数量</li><li>set(键, 值)：设置一个键值对，键和值可以是任何类型<ul><li>如果键不存在，则添加一项</li><li>如果键已存在，则修改它的值</li><li>比较键的方式和<code>set</code>相同</li></ul></li><li><strong>get(键)</strong>: 根据一个键得到对应的值</li><li>has(键)：判断某个键是否存在</li><li>**delete(键)**：删除指定的键</li><li><strong>clear()</strong>: 清空<code>map</code></li></ul></li><li><p>数组互相转换和<strong>set</strong>一样</p></li><li><p>遍历</p><ul><li><strong>for-of</strong>，每次迭代得到的是一个长度为2的数组</li><li><strong>forEach</strong>，通过回调函数遍历<ul><li>参数<code>1</code>：每一项的值</li><li>参数<code>2</code>：每一项的键</li><li>参数<code>3</code>：<strong>map</strong>本身</li></ul></li></ul></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;a&quot;</span>, <span class="number">3</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">4</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">5</span>]]);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">mp1.set(obj, <span class="number">6456</span>);</span><br><span class="line">mp1.set(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">mp1.set(obj, <span class="number">111</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mp1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;总数：&quot;</span>, mp1.size);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;get(&#x27;a&#x27;)&quot;</span>, mp1.get(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;has(&#x27;a&#x27;)&quot;</span>, mp1.has(<span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;a&quot;</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="string">&quot;c&quot;</span>, <span class="number">10</span>],</span><br><span class="line">    [<span class="string">&quot;b&quot;</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="string">&quot;c&quot;</span>, <span class="number">5</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> result = [...mp]</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for (const [key, value] of mp) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(key, value)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">mp.forEach(<span class="function">(<span class="params">value, key, mp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, key, mp)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="手写Map"><a href="#手写Map" class="headerlink" title="手写Map"></a>手写Map</h3><h4 id="ES6之实现Map"><a href="#ES6之实现Map" class="headerlink" title="ES6之实现Map"></a>ES6之实现Map</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">iterable = []</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//验证是否是可迭代的对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> iterable[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;iterable&#125;</span>不是一个可迭代的对象`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._datas = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">            <span class="comment">// item 也得是一个可迭代对象</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> item[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;item&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> iterator = item[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">            <span class="keyword">const</span> key = iterator.next().value;</span><br><span class="line">            <span class="keyword">const</span> value = iterator.next().value;</span><br><span class="line">            <span class="built_in">this</span>.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> obj = <span class="built_in">this</span>._getObj(key);</span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            <span class="comment">//修改</span></span><br><span class="line">            obj.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._datas.push(&#123;</span><br><span class="line">                key,</span><br><span class="line">                value</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> item = <span class="built_in">this</span>._getObj(key);</span><br><span class="line">        <span class="keyword">if</span> (item) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._datas.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">delete</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> element = <span class="built_in">this</span>._datas[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(element.key, key)) &#123;</span><br><span class="line">                <span class="built_in">this</span>._datas.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._datas.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key值从内部数组中，找到对应的数组项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>key </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">_getObj</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(item.key, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._getObj(key) !== <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个数据是否相等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data1 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data2 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">isEqual</span>(<span class="params">data1, data2</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data1 === <span class="number">0</span> &amp;&amp; data2 === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.is(data1, data2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">            <span class="keyword">yield</span> [item.key, item.value];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">forEach</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">            callback(item.value, item.key, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mp1 = <span class="keyword">new</span> MyMap([</span><br><span class="line">    [<span class="string">&quot;a&quot;</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="string">&quot;b&quot;</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="string">&quot;c&quot;</span>, <span class="number">5</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">mp1.set(obj, <span class="number">6456</span>);</span><br><span class="line">mp1.set(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">mp1.set(obj, <span class="number">111</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for (const item of mp1) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(item)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const result = [...mp1];</span></span><br><span class="line"><span class="comment">// console.log(result)</span></span><br><span class="line">mp1.forEach(<span class="function">(<span class="params">a1, a2, a3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a1, a2, a3);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ES5之实现Map"><a href="#ES5之实现Map" class="headerlink" title="ES5之实现Map"></a>ES5之实现Map</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原生Map特性</span></span><br><span class="line"><span class="comment">//1.不重复</span></span><br><span class="line"><span class="comment">//2.属性不只是字符串，还可以是 &#123;&#125; null [] function number</span></span><br><span class="line"><span class="comment">//3.实现方法 delete set get has clear </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myMap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//桶长度 = 8</span></span><br><span class="line">    <span class="built_in">this</span>.bucketLength = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">myMap.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//初始化 桶 长度8</span></span><br><span class="line">    <span class="built_in">this</span>.bucket = <span class="keyword">new</span> <span class="built_in">Array</span>( <span class="built_in">this</span>.bucketLength );</span><br><span class="line">    <span class="comment">//循环遍历桶添加初始化值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="built_in">this</span>.bucket.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.bucket[i] = &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;bucket&#x27;</span> + i,</span><br><span class="line">            <span class="attr">next</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash算法</span></span><br><span class="line"><span class="comment">//1. [0,8]</span></span><br><span class="line"><span class="comment">//2. 重复算值固定</span></span><br><span class="line">myMap.prototype.makeHash = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// key 可能是 string number boolean null  NaN [] &#123;&#125; function()&#123;&#125; undefine</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> key !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为数字，hash直接等于key</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> key == <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//number NaN</span></span><br><span class="line">            <span class="comment">//判断key是否等于NaN</span></span><br><span class="line">            hash = <span class="built_in">Object</span>.is(key,<span class="literal">NaN</span>) ? <span class="number">0</span> : key;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> key == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//null &#123;&#125; [] </span></span><br><span class="line">            hash = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> key == <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//true 1  |  false 0</span></span><br><span class="line">            hash += key;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//undefine function() &#123;&#125;</span></span><br><span class="line">            hash = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//string</span></span><br><span class="line">        <span class="comment">//&#x27;a&#x27; &#x27;ab&#x27; &#x27;....很多个字符&#x27;</span></span><br><span class="line">        <span class="comment">//长度大于等于3，取字符串前三个字符的ascii，累加 取余 变为0-8（规则由自己定义）</span></span><br><span class="line">        <span class="comment">//长度不大于3时，就取长度位数进行计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//判断如果字符没有第三位时返回0，有时就返回该位的ascii码</span></span><br><span class="line">            hash += key[i] ? key[i].charCodeAt(<span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">8</span>; <span class="comment">//生成0-8范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line">myMap.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line">    <span class="comment">//循环条件，oTempBucket.next是否有值</span></span><br><span class="line">    <span class="keyword">while</span>(oTempBucket.next) &#123;</span><br><span class="line">        <span class="comment">//如果next中的值与传入的值相同，那么就让next的value等于传入的value</span></span><br><span class="line">        <span class="keyword">if</span> (oTempBucket.next.key == key) &#123;</span><br><span class="line">            oTempBucket.next.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果在key不等于next.key，就让oTempBucket自己等于自己的下一个，再次循环比较</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//给最后一个oTempBucket添加值</span></span><br><span class="line">    oTempBucket.next = &#123;</span><br><span class="line">        <span class="attr">key</span>: key,</span><br><span class="line">        <span class="attr">value</span>: value,</span><br><span class="line">        <span class="attr">next</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line">myMap.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line">    <span class="comment">//循环条件，oTempBucket.next是否有值</span></span><br><span class="line">    <span class="keyword">while</span>(oTempBucket.next) &#123;</span><br><span class="line">        <span class="comment">//如果next中的值与传入的值相同，那么就返回next中的value</span></span><br><span class="line">        <span class="keyword">if</span>(oTempBucket.next.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> oTempBucket.next.value;</span><br><span class="line">        <span class="comment">//如果在key不等于next.key，就让oTempBucket自己等于自己的下一个，再次循环比较</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果oTempBucket.next没有值，直接返回undefine</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delete方法</span></span><br><span class="line">myMap.prototype.delete = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line">    <span class="comment">//循环条件，oTempBucket.next是否有值</span></span><br><span class="line">    <span class="keyword">while</span> (oTempBucket.next) &#123;</span><br><span class="line">        <span class="comment">//如果next中的值与传入的值相同，那么就将next的指向改变为next.next</span></span><br><span class="line">        <span class="keyword">if</span>(oTempBucket.next.key == key) &#123;</span><br><span class="line">            oTempBucket.next = oTempBucket.next.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果传入的key不等于next.key，就让oTempBucket自己等于自己的下一个，再次循环比较</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//has方法</span></span><br><span class="line">myMap.prototype.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(oTempBucket.next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(oTempBucket.next.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear方法</span></span><br><span class="line">myMap.prototype.clear = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oMp = <span class="keyword">new</span> myMap();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;yzl&#x27;</span>&#125;;</span><br><span class="line">oMp.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;yzl&#x27;</span>);</span><br><span class="line">oMp.set(<span class="string">&#x27;name1&#x27;</span>,<span class="string">&#x27;yzl&#x27;</span>);</span><br><span class="line">oMp.set(obj,<span class="string">&#x27;----&#x27;</span>);</span><br><span class="line">oMp.set(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="string">&#x27;----&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="WeakSet-和-WeakMap"><a href="#WeakSet-和-WeakMap" class="headerlink" title="WeakSet 和 WeakMap"></a>WeakSet 和 WeakMap</h3><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>使用该集合，可以实现和<strong>set</strong>一样的功能，不同的是：</p><ol><li><p><strong>它内部存储的对象地址不会影响垃圾回收</strong></p></li><li><p>只能添加对象</p></li><li><p>不能遍历（不是可迭代的对象）、没有<code>size</code>属性、没有<code>forEach</code>方法</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yj&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj;</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">set.add(obj);</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(set)</span><br></pre></td></tr></table></figure><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>类似于<strong>map</strong>的集合，不同的是：</p><ol><li><p><strong>它的键存储的地址不会影响垃圾回收</strong></p></li><li><p>它的键只能是对象</p></li><li><p>不能遍历（不是可迭代的对象）、没有<code>size</code>属性、没有<code>forEach</code>方法</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123; id:&quot;1&quot;, name:&quot;姓名1&quot; &#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123; id:&quot;2&quot;, name:&quot;姓名2&quot; &#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123; id:&quot;3&quot;, name:&quot;姓名3&quot; &#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> wmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">const</span> li <span class="keyword">of</span> lis) &#123;</span></span><br><span class="line"><span class="javascript">        wmap.set(li, &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: li.innerHTML,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">`姓名<span class="subst">$&#123;li.innerHTML&#125;</span>`</span></span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    lis[<span class="number">0</span>].remove();</span></span><br><span class="line"><span class="javascript">    lis = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(wmap);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h2><h3 id="【回顾】属性描述符"><a href="#【回顾】属性描述符" class="headerlink" title="【回顾】属性描述符"></a>【回顾】属性描述符</h3><ul><li><p><strong>Property Descriptor</strong> 属性描述符  是一个普通对象，用于描述一个属性的相关信息</p></li><li><p>通过<code>Object.getOwnPropertyDescriptor(对象, 属性名)</code>可以得到一个对象的某个属性的属性描述符</p><ul><li><strong>value</strong>：属性值</li><li><strong>configurable</strong>：该属性的描述符是否可以修改</li><li><strong>enumerable</strong>：该属性是否可以被枚举</li><li><strong>writable</strong>：该属性是否可以被重新赋值</li></ul></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如果需要为某个对象添加属性时 或 修改属性时， 配置其属性描述符，可以使用下面的代码:</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">Object.defineProperty(对象, 属性名, 描述符);</span><br><span class="line">Object.defineProperties(对象, 多个属性的描述符)</span><br></pre></td></tr></table></figure></blockquote><h4 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h4><ul><li><p>属性描述符中，如果配置了 <code>get</code> 和 <code>set</code> 中的任何一个，则该属性，不再是一个普通属性，而变成了存取器属性。</p></li><li><p><code>get</code> 和 <code>set</code>配置均为函数，如果一个属性是存取器属性，则读取该属性时，会运行<code>get</code>方法，将<code>get</code>方法得到的返回值作为属性值；如果给该属性赋值，则会运行<code>set</code>方法。</p></li><li><p>存取器属性最大的意义，在于可以控制属性的读取和赋值。</p></li></ul><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Object.defineProperty(obj, &quot;a&quot;, &#123;</span></span><br><span class="line"><span class="comment">//     value: 3,</span></span><br><span class="line"><span class="comment">//     configurable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">obj.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(obj)</span></span><br><span class="line"><span class="comment">// // for (const prop in obj) &#123;</span></span><br><span class="line"><span class="comment">// //     console.log(prop);</span></span><br><span class="line"><span class="comment">// // &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const props = Object.keys(obj)</span></span><br><span class="line"><span class="comment">// console.log(props)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const values = Object.values(obj);</span></span><br><span class="line"><span class="comment">// console.log(values);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const desc = Object.getOwnPropertyDescriptor(obj, &quot;a&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(desc);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;运行了属性a的get函数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> obj._a;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;运行了属性a的set函数&quot;</span>, val)</span><br><span class="line">        obj._a = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// obj.a = 20 + 10; // set(20 + 10)</span></span><br><span class="line"><span class="comment">// console.log(obj.a); // console.log(get())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.a = obj.a + 1; // set(obj.a + 1)   set(get() + 1)</span></span><br><span class="line"><span class="comment">// console.log(obj.a);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(obj.a)</span></span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;adsf&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj._age;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> val !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;年龄必须是一个数字&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; <span class="number">200</span>) &#123;</span><br><span class="line">            val = <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        obj._age = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.age = <span class="string">&quot;Asdfasasdf&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>年龄：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> spanName = <span class="built_in">document</span>.getElementById(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> spanAge = <span class="built_in">document</span>.getElementById(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(user, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> spanName.innerText;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">            spanName.innerText = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> +spanAge.innerText;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> val !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;年龄必须是一个数字&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                val = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                val = <span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            spanAge.innerText = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li><p><strong>Reflect</strong>是什么？</p><ul><li><code>Reflect</code>是一个内置的<code>JS</code>对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些<code>JS</code>底层功能</li><li>由于它类似于其他语言的<strong>反射</strong>，因此取名为<code>Reflect</code></li></ul></li><li><p>它可以做什么？</p><ul><li>使用<code>Reflect</code>可以实现诸如 属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中  等等功能</li></ul></li><li><p>这些功能不是已经存在了吗？为什么还需要用<code>Reflect</code>实现一次？</p><ul><li>有一个重要的理念，在<code>ES5</code>就被提出：减少魔法、让代码更加纯粹</li><li>这种理念很大程度上是受到函数式编程的影响</li><li><code>ES6</code>进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的<code>API</code>，并高度聚合到某个对象中，于是，就造就了<code>Reflect</code>对象</li><li>因此，你可以看到<code>Reflect</code>对象中有很多的<code>API</code>都可以使用过去的某种语法或其他<code>API</code>实现。</li></ul></li><li><p>它里面到底提供了哪些<code>API</code>呢？</p><ul><li><strong>Reflect.set(target, propertyKey, value)</strong>: 设置对象<code>target</code>的属性<code>propertyKey</code>的值为<code>value</code>，等同于给对象的属性赋值</li><li><strong>Reflect.get(target, propertyKey)</strong>: 读取对象<code>target</code>的属性<code>propertyKey</code>，等同于读取对象的属性值</li><li>**Reflect.apply(target, thisArgument, argumentsList)**：调用一个指定的函数，并绑定this和参数列表。等同于函数调用</li><li>**Reflect.deleteProperty(target, propertyKey)**：删除一个对象的属性</li><li>**Reflect.defineProperty(target, propertyKey, attributes)**：类似于<code>Object.defineProperty</code>，不同的是如果配置出现问题，返回false而不是报错</li><li>**Reflect.construct(target, argumentsList)**：用构造函数的方式创建一个对象</li><li><strong>Reflect.has(target, propertyKey)</strong>: 判断一个对象是否拥有一个属性</li><li>其他<strong>API</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>实例</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.a = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&quot;a&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(obj, <span class="string">&quot;a&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function method(a, b)&#123;</span></span><br><span class="line"><span class="comment">//     console.log(&quot;method&quot;, a, b);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // method(3, 4);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.apply(method, null, [3, 4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const obj = &#123;</span></span><br><span class="line"><span class="comment">//     a: 1,</span></span><br><span class="line"><span class="comment">//     b: 2</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // delete obj.a;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.deleteProperty(obj, &quot;a&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(obj);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function Test(a, b) &#123;</span></span><br><span class="line"><span class="comment">//     this.a = a;</span></span><br><span class="line"><span class="comment">//     this.b = b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // const t = new Test(1, 3);</span></span><br><span class="line"><span class="comment">// const t = Reflect.construct(Test, [1, 3]);</span></span><br><span class="line"><span class="comment">// console.log(t)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(&quot;a&quot; in obj);</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(obj, <span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><blockquote><p>代理：提供了修改底层实现的方式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理一个目标对象</span></span><br><span class="line"><span class="comment">//target：目标对象</span></span><br><span class="line"><span class="comment">//handler：是一个普通对象，其中可以重写底层实现</span></span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, propertyKey, value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(target, propertyKey, value);</span></span><br><span class="line">        <span class="comment">// target[propertyKey] = value;</span></span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, propertyKey, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, propertyKey</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(target, propertyKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propertyKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">target, propertyKey</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// console.log(proxy);</span></span><br><span class="line"><span class="comment">// proxy.a = 10;</span></span><br><span class="line"><span class="comment">// console.log(proxy.a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.d);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> proxy);</span><br></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>有一个对象，是观察者，它用于观察另外一个对象的属性值变化，当属性值变化后会收到一个通知，可能会做一些事。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.container</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> ob = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="built_in">Object</span>.keys(target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> props) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(ob, prop, &#123;</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> target[prop];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">                target[prop] = val;</span><br><span class="line">                render();</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(ob)) &#123;</span><br><span class="line">            html += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;span&gt;<span class="subst">$&#123;prop&#125;</span>：&lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;ob[prop]&#125;</span>&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        div.innerHTML = html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = observer(target)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.container</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target, prop, value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">Reflect</span>.set(target, prop, value);</span><br><span class="line">            render();</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    render();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(target)) &#123;</span><br><span class="line">            html += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;span&gt;<span class="subst">$&#123;prop&#125;</span>：&lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;target[prop]&#125;</span>&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        div.innerHTML = html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = observer(target)</span><br></pre></td></tr></table></figure><h3 id="偷懒的构造函数"><a href="#偷懒的构造函数" class="headerlink" title="偷懒的构造函数"></a>偷懒的构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorProxy</span>(<span class="params">Class, ...propNames</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(Class, &#123;</span><br><span class="line">        <span class="function"><span class="title">construct</span>(<span class="params">target, argumentsList</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> obj = <span class="built_in">Reflect</span>.construct(target, argumentsList)</span><br><span class="line">            propNames.forEach(<span class="function">(<span class="params">name, i</span>) =&gt;</span> &#123;</span><br><span class="line">                obj[name] = argumentsList[i];</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserProxy = ConstructorProxy(User, <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> UserProxy(<span class="string">&quot;袁&quot;</span>, <span class="string">&quot;进&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MonsterProxy = ConstructorProxy(Monster, <span class="string">&quot;attack&quot;</span>, <span class="string">&quot;defence&quot;</span>, <span class="string">&quot;hp&quot;</span>, <span class="string">&quot;rate&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MonsterProxy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">30</span>, <span class="string">&quot;怪物&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure><h3 id="可验证的函数参数"><a href="#可验证的函数参数" class="headerlink" title="可验证的函数参数"></a>可验证的函数参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validatorFunction</span>(<span class="params">func, ...types</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, &#123;</span><br><span class="line">        <span class="function"><span class="title">apply</span>(<span class="params">target, thisArgument, argumentsList</span>)</span> &#123;</span><br><span class="line">            types.forEach(<span class="function">(<span class="params">t, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> arg = argumentsList[i]</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== t) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`第<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>个参数<span class="subst">$&#123;argumentsList[i]&#125;</span>不满足类型<span class="subst">$&#123;t&#125;</span>`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target, thisArgument, argumentsList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = validatorFunction(sum, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validatorFunction</span>(<span class="params">func, ...types</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...argumentsList</span>) </span>&#123;</span><br><span class="line">        types.forEach(<span class="function">(<span class="params">t, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> arg = argumentsList[i]</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`第<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>个参数<span class="subst">$&#123;argumentsList[i]&#125;</span>不满足类型<span class="subst">$&#123;t&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> func(...argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = validatorFunction(sum, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="增强的数组功能"><a href="#增强的数组功能" class="headerlink" title="增强的数组功能"></a>增强的数组功能</h2><h3 id="新增的数组API"><a href="#新增的数组API" class="headerlink" title="新增的数组API"></a>新增的数组API</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li><strong>Array.of(…args)</strong>: 使用指定的数组项创建一个新数组</li><li><strong>Array.from(arg)</strong>: 通过给定的类数组或可迭代对象 创建一个新的数组。</li></ul><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li><strong>find(callback)</strong>: 用于查找满足条件的第一个元素</li><li>**findIndex(callback)**：用于查找满足条件的第一个元素的下标</li><li>**fill(data)**：用指定的数据填充满数组所有的内容</li><li><strong>copyWithin(target, start?, end?)</strong>: 在数组内部完成复制</li><li>**includes(data)**：判断数组中是否包含某个值，使用<code>Object.is</code>匹配</li></ul><h3 id="扩展-类型化数组"><a href="#扩展-类型化数组" class="headerlink" title="[扩展]类型化数组"></a>[扩展]类型化数组</h3><h4 id="数字存储的前置知识"><a href="#数字存储的前置知识" class="headerlink" title="数字存储的前置知识"></a>数字存储的前置知识</h4><ul><li>计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的。</li><li><code>n</code>位的无符号整数能表示的数字是<code>2^n</code>个，取值范围是：<code>0 ~ 2^n - 1</code></li><li><code>n</code>位的有符号整数能表示的数字是<code>2^n</code>个，取值范围是：<code>-2^(n-1) ~ 2^(n-1) - 1</code></li><li>浮点数表示法可以用于表示整数和小数，目前分为两种标准：<ul><li><code>32</code>位浮点数：又称为单精度浮点数，它用<code>1</code>位表示符号，<code>8</code>位表示阶码，<code>23</code>位表示尾数</li><li><code>64</code>位浮点数：又称为双精度浮点数，它用<code>1</code>位表示符号，<code>11</code>位表示阶码，<code>52</code>位表示尾数</li></ul></li><li><code>JS</code>中的所有数字，均使用双精度浮点数保存</li></ul><h4 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h4><p>类型化数组：用于优化多个数字的存储</p><p>具体分为：</p><ul><li><p><strong>Int8Array</strong>： <code>8</code>位有符号整数（<code>-128 ~ 127</code>）</p></li><li><p><strong>Uint8Array</strong>： <code>8</code>位无符号整数（<code>0 ~ 255</code>）</p></li><li><p><strong>Int16Array</strong>: …</p></li><li><p><strong>Uint16Array</strong>: …</p></li><li><p><strong>Int32Array</strong>: …</p></li><li><p><strong>Uint32Array</strong>: …</p></li><li><p><strong>Float32Array</strong>:</p></li><li><p><strong>Float64Array</strong></p></li><li><p>如何创建数组</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(长度)</span><br><span class="line"></span><br><span class="line">数组构造函数.of(元素...)</span><br><span class="line"></span><br><span class="line">数组构造函数.from(可迭代对象)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(其他类型化数组)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>得到长度</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组.length   <span class="comment">//得到元素数量</span></span><br><span class="line">数组.byteLength <span class="comment">//得到占用的字节数</span></span><br></pre></td></tr></table></figure><ul><li>其他的用法跟普通数组一致，但是：<ul><li>不能增加和删除数据，类型化数组的长度固定</li><li>一些返回数组的方法，返回的数组是同类型化的新数组</li></ul></li></ul><h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const arr = new Int32Array(10);</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Uint8Array</span>.of(<span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// console.log(arr.length);</span></span><br><span class="line"><span class="comment">// console.log(arr.byteLength);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Int32Array</span>.of(<span class="number">35111</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(arr1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1, arr2);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Int8Array</span>.of(<span class="number">125</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">const</span> arr2 = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[1] = 100;</span></span><br><span class="line"><span class="comment">// console.log(arr);</span></span><br><span class="line"><span class="comment">// console.log(arr[1])</span></span><br><span class="line"><span class="comment">// for (const item of arr) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(item)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[4] = 1000; //无效</span></span><br><span class="line"><span class="comment">// delete arr[0]; //无效</span></span><br><span class="line"><span class="comment">// console.log(arr)</span></span><br></pre></td></tr></table></figure><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><blockquote><p><strong>ArrayBuffer</strong>：一个对象，用于存储一块固定内存大小的数据。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(字节数)</span><br></pre></td></tr></table></figure><ul><li>可以通过属性<code>byteLength</code>得到字节数，可以通过方法<code>slice</code>得到新的<code>ArrayBuffer</code></li></ul><h4 id="读写ArrayBuffer"><a href="#读写ArrayBuffer" class="headerlink" title="读写ArrayBuffer"></a>读写ArrayBuffer</h4><ul><li><p>使用<strong>DataView</strong></p><ul><li>通常会在需要混用多种存储格式时使用<code>DataView</code></li></ul></li><li><p>使用类型化数组</p></li><li><p>实际上，每一个类型化数组都对应一个<code>ArrayBuffer</code>，如果没有手动指定<code>ArrayBuffer</code>，类型化数组创建时，会新建一个<code>ArrayBuffer</code></p></li><li><p>练习</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建了一个用于存储10个字节的内存空间</span></span><br><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bf2 = bf.slice(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bf, bf2);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建了一个用于存储10个字节的内存空间</span></span><br><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(bf, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(view);</span></span><br><span class="line"></span><br><span class="line">view.setInt16(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(view);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>); <span class="comment">//10个字节的内存</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(bf);</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(bf);</span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1.buffer === arr2.buffer);</span><br><span class="line"></span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>); <span class="comment">//10个字节的内存</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(bf);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2344</span>; <span class="comment">//操作了两个字节</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Es6&quot;&gt;&lt;a href=&quot;#Es6&quot; class=&quot;headerlink&quot; title=&quot;Es6&quot;&gt;&lt;/a&gt;Es6&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;介绍：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ES2015&lt;/code&gt;年退出&lt;code&gt;JavaScript&lt;/code&gt;新版本也叫&lt;code&gt;ES2015&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;现在已经&lt;code&gt;ES7（2016）&lt;/code&gt;，&lt;code&gt;ES8（2017）&lt;/code&gt;，&lt;code&gt;ES9（2018）&lt;/code&gt;很多新增内容仍是填&lt;/li&gt;
&lt;li&gt;普遍使用的依然是&lt;code&gt;ES6&lt;/code&gt;，&lt;code&gt;ES7&lt;/code&gt;部分内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES7&lt;/code&gt;及后面版本浏览器或node环境未完全支持，但已有&lt;code&gt;babel&lt;/code&gt;工具可对其进行编译支持（转成&lt;code&gt;ES5&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;所以：新版本语言只是在原有基础上新增了一些语法糖，执行时还会转换为&lt;code&gt;ES5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ECMAScript&lt;/strong&gt;、&lt;strong&gt;JavaScript&lt;/strong&gt;、&lt;strong&gt;NodeJs&lt;/strong&gt;，它们的区别是什么？&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ECMAScript&lt;/code&gt;：简称&lt;code&gt;ES&lt;/code&gt;，是一个语言标准（循环、判断、变量、数组等数据类型）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JavaScript&lt;/code&gt;：运行在浏览器端的语言，该语言使用&lt;code&gt;ES&lt;/code&gt;标准，&lt;code&gt;ES + web api = JavaScript&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NodeJs&lt;/code&gt;：运行在服务器端的语言，该语言使用&lt;code&gt;ES&lt;/code&gt;标准，&lt;code&gt;ES + node api = JavaScript&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ECMAScript&lt;/strong&gt;有哪些关键的版本？&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ES3.0&lt;/code&gt;：&lt;code&gt;1999&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES5.0&lt;/code&gt;：&lt;code&gt;2009&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES6.0&lt;/code&gt;：&lt;code&gt;2015&lt;/code&gt;，从该版本不再使用数字作为编号，而使用年份，也叫&lt;code&gt;ES2015&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES7.0&lt;/code&gt;：&lt;code&gt;2016&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为什么&lt;strong&gt;ES6&lt;/strong&gt;如此重要？&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ES6&lt;/code&gt;解决&lt;code&gt;JS&lt;/code&gt;无法开发大型应用的语言层面的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为什么要学习&lt;code&gt;ES6&lt;/code&gt;？&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ES6&lt;/code&gt;引入的语言新特性，更具规范性，易读性，方便操作，简化了大型项目开发的复杂程度、降低了出错概率，提升了开发效率&lt;/li&gt;
&lt;li&gt;大部分公司（不代表所有，代表着一个趋势）都在用&lt;code&gt;ES6&lt;/code&gt;开发，已成为开发，求职必会内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>包管理器</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/PackageManager/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/PackageManager/</id>
    <published>2021-11-08T07:35:53.000Z</published>
    <updated>2022-05-17T01:12:47.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h1><h2 id="包管理工具概述"><a href="#包管理工具概述" class="headerlink" title="包管理工具概述"></a>包管理工具概述</h2><blockquote><p>本门课程的前置知识：JavaScript、ES6、模块化、git<br>本门课程的所有代码均书写在 nodejs 环境中，不涉及浏览器环境</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>模块（module）</strong></p><p>通常以单个文件形式存在的功能片段，入口文件通常称之为<strong>入口模块</strong>或<strong>主模块</strong></p><p><strong>库（library，简称lib）</strong></p><p>以一个或多个模块组成的完整功能块，为开发中某一方面的问题提供完整的解决方案</p><p><strong>包（package）</strong></p><p>包含元数据的库，这些元数据包括：名称、描述、git主页、许可证协议、作者、依赖等等</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111717653.png"></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>CommonJS</code> 的出现，使 <code>node</code> 环境下的 <code>JS</code> 代码可以用模块更加细粒度的划分。一个类、一个函数、一个对象、一个配置等等均可以作为模块，这种细粒度的划分，是开发大型应用的基石。</p><p>为了解决在开发过程中遇到的常见问题，比如加密、提供常见的工具方法、模拟数据等等，一时间，在前端社区涌现了大量的第三方库。这些库使用 <code>CommonJS</code> 标准书写而成，非常容易使用。</p><p>然而，在下载使用这些第三方库的时候，遇到难以处理的问题：</p><ul><li><strong>下载过程繁琐</strong><ul><li>进入官网或 <code>github</code> 主页</li><li>找到并下载相应的版本</li><li>拷贝到工程的目录中</li><li>如果遇到有同名的库，需要更改名称</li></ul></li><li><strong>如果该库需要依赖其他库，还需要按照要求先下载其他库</strong></li><li><strong>开发环境中安装的大量的库如何在生产环境中还原，又如何区分</strong></li><li><strong>更新一个库极度麻烦</strong></li><li><strong>自己开发的库，如何在下一次开发使用</strong></li></ul><p><strong>以上问题，就是包管理工具要解决的问题</strong></p><span id="more"></span><h3 id="前端包管理器"><a href="#前端包管理器" class="headerlink" title="前端包管理器"></a>前端包管理器</h3><blockquote><p>本门课程讲解的包管理器<br>npm：重点<br>yarn：次重点<br>其他：了解</p></blockquote><p>几乎可以这样认为，前端所有的包管理器都是基于 <code>npm</code> 的，目前，<code>npm</code> 即是一个包管理器，也是其他包管理的基石</p><p><code>npm</code> 全称为 <code>node package manager</code>，即 <code>node</code> 包管理器，它运行在 <code>node</code> 环境中，让开发者可以用简单的方式完成包的查找、安装、更新、卸载、上传等操作</p><blockquote><p>npm 之所以要运行在 node 环境，而不是浏览器环境，根本原因是因为浏览器环境无法提供下载、删除、读取本地文件的功能。而 node 属于服务器环境，没有浏览器的种种限制，理论上可以完全掌控运行 node 的计算机。</p></blockquote><p><code>npm</code> 的出现，弥补了 <code>node</code> 没有包管理器的缺陷，于是很快，<code>node</code> 在安装文件中内置了 <code>npm</code>，当开发者安装好 <code>node</code> 之后，就自动安装了 <code>npm</code>，不仅如此，<code>node</code> 环境还专门为 <code>npm</code> 提供了良好的支持，使用 <code>npm</code> 下载的包更加方便了。</p><p><code>npm</code> 由三部分组成：</p><ul><li><strong>registry</strong>：入口<ul><li>可以把它想象成一个庞大的数据库</li><li>第三方库的开发者，将自己的库按照 npm 的规范，打包上传到数据库中</li><li>使用者通过统一的地址下载第三方包</li></ul></li><li>官网：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a><ul><li>查询包</li><li>注册、登录、管理个人信息</li></ul></li><li><strong>CLI</strong>：<code>command-line interface</code> 命令行接口<ul><li>这一部分是本门课讲解的重点</li><li>安装好 <code>npm</code> 后，通过 CLI 来使用 <code>npm</code> 的各种功能</li></ul></li></ul><blockquote><p>node 和 npm 是互相成就的，node 的出现让 npm 火了，npm 的火爆带动了大量的第三方库的发展，很多优秀的第三方库打包上传到了 npm，这些第三方库又为 node 带来了大量的用户</p></blockquote><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="包的安装"><a href="#包的安装" class="headerlink" title="包的安装"></a>包的安装</h3><blockquote><p>安装（install）即下载包<br>由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址。目前，淘宝 <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 提供了国内的 registry 地址，先设置到该地址。设置方式为<code>npm config set registry https://registry.npm.taobao.org</code>。设置好后，通过命令<code>npm config get registry</code>进行检查<br><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111719794.png"></p></blockquote><p><code>npm</code> 安装一个包，分为两种安装方式：</p><ol><li>本地安装</li><li>全局安装</li></ol><h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h4><p>使用命令<code>npm install 包名</code>或<code>npm i 包名</code>即可完成本地安装</p><p>本地安装的包出现在当前目录下的<code>node_modules</code>目录中</p><blockquote><p>随着开发的进展，<code>node_modules</code>目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用<code>.gitignore</code>文件忽略该目录中的内容<br>本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用<br>通常在项目的根目录中使用本地安装<br>安装一个包的时候，<code>npm</code> 会自动管理依赖，它会下载该包的依赖包到<code>node_modules</code>目录中<br>如果本地安装的包带有 <code>CLI</code>，<code>npm</code> 会将它的 <code>CLI</code> 脚本文件放置到<code>node_modules/.bin</code>下，使用命令<code>npx 命令名</code>即可调用</p></blockquote><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><p>全局安装的包放置在一个特殊的全局目录，该目录可以通过命令<code>npm config get prefix</code>查看</p><p>使用命令<code>npm install --global 包名</code> 或 <code>npm i -g 包名</code></p><p>重要：<strong>全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具</strong></p><p>大部分情况下，都不需要全局安装包，除非：</p><ol><li>包的版本非常稳定，很少有大的更新</li><li>提供的 <code>CLI</code> 工具在各个工程中使用的非常频繁</li><li><code>CLI</code> 工具仅为开发环境提供支持，而非部署环境</li></ol><h3 id="包配置"><a href="#包配置" class="headerlink" title="包配置"></a>包配置</h3><p>目前遇到的问题：</p><ol><li>拷贝工程后如何还原？</li><li>如何区分开发依赖和生产依赖？</li><li>如果自身的项目也是一个包，如何描述包的信息</li></ol><p>以上这些问题都需要通过包的<strong>配置文件</strong>解决</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><code>npm</code> 将每个使用 <code>npm</code> 的工程本身都看作是一个包，包的信息需要通过一个名称固定的配置文件来描述</p><p><strong>配置文件的名称固定为：package.json</strong></p><p>可以手动创建该文件，而更多的时候，是通过命令<code>npm init</code>创建的</p><p>配置文件中可以描述大量的信息，包括：</p><ul><li><strong>name</strong>：包的名称，该名称必须是<strong>英文单词字符</strong>，支持连接符</li><li><strong>version</strong>：版本<ul><li>版本规范：主版本号.次版本号.补丁版本号</li><li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的<code>API</code>、技术架构发生了重大变化</li><li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的<code>API</code></li><li>补丁版本号：仅当解决了一些 <code>bug</code> 或 进行了一些局部优化时更新，如修复了某个函数的 <code>bug</code>、提升了某个函数的运行效率</li></ul></li><li><strong>description</strong>：包的描述</li><li><strong>homepage</strong>：官网地址</li><li><strong>author</strong>：包的作者，必须是有效的 <code>npm</code> 账户名，书写规范是 <code>account &lt;mail&gt;</code>，例如：<code>zhangsan &lt;zhangsan@gmail.com&gt;</code>，不正确的账号和邮箱可能导致发布包时失败</li><li>repository：包的仓储地址，通常指 <code>git</code> 或 <code>svn</code> 的地址，它是一个对象<ul><li><strong>type</strong>：仓储类型，<code>git</code> 或 <code>svn</code></li><li><strong>url</strong>：地址</li></ul></li><li><strong>main</strong>：包的入口文件，使用包的人默认从该入口文件导入包的内容</li><li><strong>keywords</strong>: 搜索关键字，发布包后，可以通过该数组中的关键字搜索到包</li></ul><p>使用<code>npm init --yes</code>或<code>npm init -y</code>可以在生成配置文件时自动填充默认配置</p><h4 id="保存依赖关系"><a href="#保存依赖关系" class="headerlink" title="保存依赖关系"></a>保存依赖关系</h4><p>大部分时候，我们仅仅是开发项目，并不会把它打包发布出去，尽管如此，我们仍然需要<code>package.json</code>文件</p><p><strong>package.json文件最重要的作用，是记录当前工程的依赖</strong></p><ul><li><strong>dependencies</strong>：生产环境的依赖包</li><li><strong>devDependencies</strong>：仅开发环境的依赖包</li></ul><p>配置好依赖后，使用下面的命令即可安装依赖</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 本地安装所有依赖 dependencies + devDependencies</span></span></span><br><span class="line">npm install</span><br><span class="line">npm i</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 仅安装生产环境的依赖 dependencies</span></span></span><br><span class="line">npm install --production</span><br></pre></td></tr></table></figure><p>这样一来，代码移植就不是问题了，只需要移植源代码和<code>package.json</code>文件，不用移植<code>node_modules</code>目录，然后在移植之后通过命令即可重新恢复安装</p><p>为了更加方便的添加依赖，<code>npm</code>支持在使用<code>install</code>命令时，加入一些额外的参数，用于将安装的依赖包保存到<code>package.json</code>文件中</p><p>涉及的命令如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装依赖到生产环境</span></span></span><br><span class="line">npm i 包名</span><br><span class="line">npm i --save 包名</span><br><span class="line">npm i -S 包名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装依赖到开发环境</span></span></span><br><span class="line">npm i --save-dev 包名</span><br><span class="line">npm i -D 包名</span><br></pre></td></tr></table></figure><blockquote><p>自动保存的依赖版本，例如<code>^15.1.3</code>，这种书写方式叫做语义版本号（semver version），具体规则后续讲解</p></blockquote><h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><p><code>nodejs</code> 对 <code>npm</code> 支持非常良好</p><p>当使用 <code>nodejs</code> 导入模块时，如果模块路径不是以 <code>./</code> 或 <code>../</code> 开头，则 <code>node</code> 会认为导入的模块来自于 <code>node_modules</code> 目录，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&quot;lodash&quot;</span>);</span><br></pre></td></tr></table></figure><p>它首先会从当前目录的以下位置寻找文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node_modules/lodash.js</span><br><span class="line">node_modules/lodash/入口文件</span><br></pre></td></tr></table></figure><p>若当前目录没有这样的文件，则会回溯到上级目录按照同样的方式查找</p><p>如果到顶级目录都无法找到文件，则抛出错误</p><p>上面提到的入口文件按照以下规则确定</p><ol><li>查看导入包的<code>package.json</code>文件，读取<code>main</code>字段作为入口文件</li><li>若不包含<code>main</code>字段，则使用<code>index.js</code>作为入口文件</li></ol><blockquote><p>入口文件的规则同样适用于自己工程中的模块<br>在 node 中，还可以手动指定路径来导入相应的文件，这种情况比较少见</p></blockquote><h3 id="练习-简易数据爬虫"><a href="#练习-简易数据爬虫" class="headerlink" title="[练习] 简易数据爬虫"></a>[练习] 简易数据爬虫</h3><ul><li>结构</li></ul><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">getMovies.js</span><br><span class="line">index.js</span><br><span class="line">movie.json //没有数据</span><br><span class="line">package-lock.json</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><ul><li><p>需要用到的包：</p><ol><li><code>axios</code>：专门用于在各种环境中发送网络请求，并获取到服务器响应结果</li><li><code>cheerio</code>：<code>jquery</code>的核心逻辑包，支持所有环境，可用于讲一个<code>html</code>字符串转换成为<code>jquery</code>对象，并通过<code>jquery</code>对象完成后续操作</li><li><code>fs</code>：<code>node</code>核心模块，专门用于文件处理<ul><li><code>fs.writeFile</code>(文件名, 数据)</li></ul></li></ol></li><li><p>内容</p><ul><li><strong>index.js</strong></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getMovies = <span class="built_in">require</span>(<span class="string">&quot;./getMovies&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">getMovies().then(<span class="function"><span class="params">movies</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(movies);</span><br><span class="line">    fs.writeFile(<span class="string">&quot;movie.json&quot;</span>, json, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;成功！&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>getMovie.js</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&quot;axios&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&quot;cheerio&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到所有电影的html字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getMoviesHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> axios.get(<span class="string">&quot;https://movie.douban.com/chart&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> resp.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有电影数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getMoviesData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="keyword">await</span> getMoviesHtml();</span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(html);</span><br><span class="line">    <span class="keyword">var</span> trs = $(<span class="string">&quot;tr.item&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> movies = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; trs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> tr = trs[i];</span><br><span class="line">        <span class="comment">//分析每个tr的数据，得到一部电影对象</span></span><br><span class="line">        <span class="keyword">var</span> m = getMovie($(tr));</span><br><span class="line">        movies.push(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> movies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析tr，得到一部电影对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>tr </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMovie</span>(<span class="params">tr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = tr.find(<span class="string">&quot;div.pl2 a&quot;</span>).text();</span><br><span class="line">    name = name.replace(<span class="regexp">/\s/g</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//去掉空白字符</span></span><br><span class="line">    name = name.split(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> imgSrc = tr.find(<span class="string">&quot;a.nbg img&quot;</span>).attr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> detail = tr.find(<span class="string">&quot;div.pl2 p.pl&quot;</span>).text();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        imgSrc,</span><br><span class="line">        detail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = getMoviesData;</span><br></pre></td></tr></table></figure><h3 id="语义版本"><a href="#语义版本" class="headerlink" title="语义版本"></a>语义版本</h3><p>思考：如果你编写了一个包<code>A</code>，依赖另外一个包<code>B</code>，你在编写代码时，包<code>B</code>的版本是<code>2.4.1</code>，你是希望使用你包的人一定要安装包<code>B</code>，并且是<code>2.4.1</code>版本，还是希望他可以安装更高的版本，如果你希望它安装更高的版本，高的什么程度呢？</p><p>回顾：版本号规则</p><p>版本规范：主版本号.次版本号.补丁版本号</p><ul><li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的<code>API</code>、技术架构发生了重大变化</li><li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的<code>API</code></li><li>补丁版本号：仅当解决了一些 <code>bug</code> 或 进行了一些局部优化时更新，如修复了某个函数的 <code>bug</code>、提升了某个函数的运行效率</li></ul><p>有的时候，我们希望：安装我的依赖包的时候，次版本号和补丁版本号是可以有提升的，但是主版本号不能变化</p><p>有的时候，我们又希望：安装我的依赖包的时候，只有补丁版本号可以提升，其他都不能提升</p><p>甚至我们希望依赖包保持固定的版本，尽管这比较少见</p><p>这样一来，就需要在配置文件中描述清楚具体的依赖规则，而不是直接写上版本号那么简单。</p><p>这种规则的描述，即<strong>语义版本</strong></p><p>语义版本的书写规则非常丰富，下面列出了一些常见的书写方式</p><table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="center">示例</th><th align="center">示例描述</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于某个版本</td><td align="center">&gt;1.2.1</td><td align="center">大于1.2.1版本</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于某个版本</td><td align="center">&gt;=1.2.1</td><td align="center">大于等于1.2.1版本</td></tr><tr><td align="center">&lt;</td><td align="center">小于某个版本</td><td align="center">&lt;1.2.1</td><td align="center">小于1.2.1版本</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于某个版本</td><td align="center">&lt;=1.2.1</td><td align="center">小于等于1.2.1版本</td></tr><tr><td align="center">-</td><td align="center">介于两个版本之间</td><td align="center">1.2.1 - 1.4.5</td><td align="center">介于1.2.1和1.4.5之间</td></tr><tr><td align="center">x</td><td align="center">不固定的版本号</td><td align="center">1.3.x</td><td align="center">只要保证主版本号是1，次版本号是3即可</td></tr><tr><td align="center">~</td><td align="center">补丁版本号可增</td><td align="center">~1.3.4</td><td align="center">保证主版本号是1，次版本号是3，补丁版本号大于等于4</td></tr><tr><td align="center">^</td><td align="center">此版本和补丁版本可增</td><td align="center">^1.3.4</td><td align="center">保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4</td></tr><tr><td align="center">*</td><td align="center">最新版本</td><td align="center">*</td><td align="center">始终安装最新版本</td></tr></tbody></table><h4 id="避免还原的差异"><a href="#避免还原的差异" class="headerlink" title="避免还原的差异"></a>避免还原的差异</h4><p>版本依赖控制始终是一个两难的问题</p><p>如果允许版本增加，可以让依赖包的<code>bug</code>得以修复（补丁版本号），可以带来一些意外的惊喜（次版本号），但同样可能带来不确定的风险（新的<code>bug</code>）</p><p>如果不允许版本增加，可以获得最好的稳定性，但失去了依赖包自我优化的能力</p><p>而有的时候情况更加复杂，如果依赖包升级后，依赖也发生了变化，会有更多不确定的情况出现</p><p>基于此，<code>npm</code> 在安装包的时候，会自动生成一个 <code>package-lock.json</code> 文件，该文件记录了安装包时的确切依赖关系</p><p>当移植工程时，如果移植了 <code>package-lock.json</code> 文件，恢复安装时，会按照 <code>package-lock.json</code> 文件中的确切依赖进行安装，最大限度的避免了差异</p><h4 id="扩展-npm的差异版本处理"><a href="#扩展-npm的差异版本处理" class="headerlink" title="[扩展]npm的差异版本处理"></a>[扩展]npm的差异版本处理</h4><p>如果两个包依赖同一个包的不同版本，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111720309.png"></p><p>面对这种情况，在 <code>node_modules</code> 目录中，不会使用扁平的目录结构，而会形成嵌套的目录，如下图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">│   ├── a </span><br><span class="line">│   │   ├── node_modules</span><br><span class="line">│   │   │   ├── c</span><br><span class="line">│   │   │   |   |—— c包的文件</span><br><span class="line">│   │   │── a包的文件     </span><br><span class="line">│   ├── b </span><br><span class="line">│   │   ├── node_modules</span><br><span class="line">│   │   │   ├── c</span><br><span class="line">│   │   │   |   |—— c包的文件</span><br><span class="line">│   │   │── b包的文件           </span><br></pre></td></tr></table></figure><h3 id="npm-脚本-（npm-scripts）"><a href="#npm-脚本-（npm-scripts）" class="headerlink" title="npm 脚本 （npm scripts）"></a>npm 脚本 （npm scripts）</h3><p>在开发的过程中，我们可能会反复使用很多的 <code>CLI</code> 命令，例如：</p><ul><li>启动工程命令（<code>node</code> 或 一些第三方包提供的CLI<code>命令</code>）</li><li>部署工程命令（一些第三方包提供的<code>CLI</code>命令）</li><li>测试工程命令（一些第三方包提供的<code>CLI</code>命令）</li></ul><p>这些命令纷繁复杂，根据第三方包的不同命令也会不一样，非常难以记忆</p><p>于是，<code>npm</code> 非常贴心的支持了脚本，只需要在 <code>package.json</code> 中配置 <code>scripts</code> 字段，即可配置各种脚本名称</p><p>之后，我们就可以运行简单的指令来完成各种操作了</p><p>运行方式是 <code>npm run 脚本名称</code></p><p>不仅如此，npm 还对某些常用的脚本名称进行了简化，下面的脚本名称是不需要使用<code>run</code>的：</p><ul><li><code>start</code></li><li><code>stop</code></li><li><code>test</code></li></ul><p>一些细节：</p><ul><li>脚本中可以省略<code>npx</code></li><li><code>start</code>脚本有默认值：<code>node server.js</code></li></ul><h3 id="运行环境配置"><a href="#运行环境配置" class="headerlink" title="运行环境配置"></a>运行环境配置</h3><p>我们书写的代码一般有三种运行环境：</p><ol><li>开发环境</li><li>生产环境</li><li>测试环境</li></ol><p>有的时候，我们可能需要在 <code>node</code> 代码中根据不同的环境做出不同的处理</p><p>如何优雅的让 <code>node</code> 知道处于什么环境，是极其重要的</p><p>通常我们使用如下的处理方式：</p><p><code>node</code>中有一个全局变量 <code>global</code> (可以类比浏览器环境的<code>window</code>)，该变量是一个对象，对象中的所有属性均可以直接使用</p><p><code>global</code>有一个属性是<code>process</code>，该属性是一个对象，包含了当前运行<code>node</code>程序的计算机的很多信息，其中有一个信息是<code>env</code>，是一个对象，包含了计算机中所有的系统变量</p><p>通常，我们通过系统变量 <code>NODE_ENV</code> 的值，来判定node程序处于何种环境</p><p>有两种方式设置 <code>NODE_ENV</code> 的值</p><ol><li>永久设置</li><li>临时设置</li></ol><p>我们一般使用临时设置</p><p>因此，我们可以配置 <code>scripts</code> 脚本，在设置好了 <code>NODE_ENV</code> 后启动程序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;没有环境变量&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV)</span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">&quot;development&quot;</span>)&#123;</span><br><span class="line">    a = <span class="string">&quot;开发环境&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">&quot;production&quot;</span>)&#123;</span><br><span class="line">    a = <span class="string">&quot;生产环境&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">&quot;test&quot;</span>)&#123;</span><br><span class="line">    a = <span class="string">&quot;测试环境&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><blockquote><p>为了避免不同系统的设置方式的差异，可以使用第三方库 <code>cross-env</code> 对环境变量进行设置</p></blockquote><h4 id="在node中读取package-json"><a href="#在node中读取package-json" class="headerlink" title="在node中读取package.json"></a>在node中读取package.json</h4><p>有的时候，我们可能在 <code>package.json</code> 中配置一些自定义的字段，这些字段需要在<code>node</code>中读取</p><p>在<code>node</code> 中，可以直接导入一个<code>json</code>格式的文件，它会自动将其转换为<code>js</code>对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development node index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production node index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=test node index.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="其他npm命令-ignore"><a href="#其他npm命令-ignore" class="headerlink" title="其他npm命令 {ignore}"></a>其他npm命令 {ignore}</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li>精确安装最新版本</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-exact 包名 </span><br><span class="line">npm install -E 包名</span><br></pre></td></tr></table></figure><ol start="2"><li>安装指定版本</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install 包名@版本号</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ol><li>查询包安装路径</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm root [-g]</span><br></pre></td></tr></table></figure><ol start="2"><li>查看包信息</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm view 包名 [子信息]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># view aliases：v info show</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>查询安装包</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm list [-g] [--depth=依赖深度]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># list aliases: ls  la  ll</span></span></span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ol><li>检查有哪些包需要更新</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure><ol start="2"><li>更新包</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm update [-g] [包名]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># update 别名（aliases）：up、upgrade</span></span></span><br></pre></td></tr></table></figure><h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall [-g] 包名</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># uninstall aliases: remove, rm, r, un, unlink</span></span></span><br></pre></td></tr></table></figure><h4 id="npm-配置"><a href="#npm-配置" class="headerlink" title="npm 配置"></a>npm 配置</h4><p><code>npm</code>的配置会对其他命令产生或多或少的影响</p><p>安装好<code>npm</code>之后，最终会产生两个配置文件，一个是用户配置，一个是系统配置，当两个文件的配置项有冲突的时候，用户配置会覆盖系统配置</p><p>通常，我们不关心具体的配置文件，而只关心最终生效的配置</p><p>通过下面的命令可以查询目前生效的各种配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config ls [-l] [--json]</span><br></pre></td></tr></table></figure><p>另外，可以通过下面的命令操作配置</p><ol><li>获取某个配置项</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get 配置项</span><br></pre></td></tr></table></figure><ol start="2"><li>设置某个配置项</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set 配置项=值</span><br></pre></td></tr></table></figure><ol start="3"><li>移除某个配置项</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config delete 配置项</span><br></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>移除淘宝镜像源</li><li>到npm官网注册一个账号，并完成邮箱认证</li><li>本地使用 npm cli 进行登录<ol><li>使用命令<code>npm login</code>登录</li><li>使用命令<code>npm whoami</code>查看当前登录的账号</li><li>使用命令<code>npm logout</code>注销</li></ol></li><li>创建工程根目录</li><li>使用npm init进行初始化</li></ol><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><ol><li>开发</li><li>确定版本</li><li>使用命令<code>npm publish</code>完成发布</li></ol><h4 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h4><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111722994.png"></p><ul><li>可以通过网站 <a href="http://choosealicense.online/appendix/">http://choosealicense.online/appendix/</a> 选择协议，并复制协议内容</li></ul><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><h3 id="yarn-简介"><a href="#yarn-简介" class="headerlink" title="yarn 简介"></a>yarn 简介</h3><blockquote><p>yarn 官网：<a href="https://www.yarnpkg.com/zh-Hans/">https://www.yarnpkg.com/zh-Hans/</a></p></blockquote><p><code>yarn</code> 是由<code>Facebook</code>、<code>Google</code>、<code>Exponent</code> 和 <code>Tilde</code> 联合推出了一个新的 <code>JS</code> 包管理工具，<strong>它仍然使用 npm 的registry</strong>，不过提供了全新 <code>CLI</code> 来对包进行管理</p><p>过去，<code>yarn</code> 的出现极大的抢夺了 <code>npm</code> 的市场，甚至有人戏言，<code>npm</code> 只剩下一个 <code>registry</code> 了。</p><p>之所以会出现这种情况，是因为在过去，<code>npm</code> 存在下面的问题：</p><ul><li>依赖目录嵌套层次深：过去，<code>npm</code> 的依赖是嵌套的，这在 <code>windows</code> 系统上是一个极大的问题，由于众所周知的原因，<code>windows</code> 系统无法支持太深的目录</li><li>下载速度慢<ul><li>由于嵌套层次的问题，所以<code>npm</code>对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有完全利用</li><li>多个相同版本的包被重复的下载</li></ul></li><li>控制台输出繁杂：过去，<code>npm</code> 安装包的时候，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量的信息输出到控制台，遇到错误极难查看</li><li>工程移植问题：由于 <code>npm</code> 的版本依赖可以是模糊的，可能会导致工程移植后，依赖的确切版本不一致。</li></ul><p>针对上述问题，<code>yarn</code> 从诞生那天就已经解决，它用到了以下的手段：</p><ul><li>使用扁平的目录结构</li><li>并行下载</li><li>使用本地缓存</li><li>控制台仅输出关键信息</li><li>使用<code>yanr-lock</code>文件记录确切依赖</li></ul><p>不仅如此，<code>yarn</code>还优化了以下内容：</p><ul><li>增加了某些功能强大的命令</li><li>让既有的命令更加语义化</li><li>本地安装的<code>CLI</code>工具可以使用 <code>yarn</code> 直接启动</li><li>将全局安装的目录当作一个普通的工程，生成<code>package.json</code>文件，便于全局安装移植</li></ul><p><code>yarn</code> 的出现给 <code>npm</code> 带来了巨大的压力，很快，<code>npm</code> 学习了 <code>yarn</code> 先进的理念，不断的对自身进行优化，到了目前的<code>npm6</code>版本，几乎完全解决了上面的问题：</p><ul><li>目录扁平化</li><li>并行下载</li><li>本地缓存</li><li>使用<code>package-lock</code>记录确切依赖</li><li>增加了大量的命令别名</li><li>内置了<code>npx</code>，可以启动本地的<code>CLI</code>工具</li><li>极大的简化了控制台输出</li></ul><p><strong>总结</strong></p><p><code>npm6</code> 之后，可以说<code>npm</code>已经和<code>yarn</code>非常接近，甚至没有差距了。很多新的项目，又重新从<code>yarn</code>转回到<code>npm</code>。</p><p>这两个包管理器是目前的主流，都必须要学习。</p><h3 id="yarn-的核心命令"><a href="#yarn-的核心命令" class="headerlink" title="yarn 的核心命令"></a>yarn 的核心命令</h3><ol><li><strong>初始化</strong></li></ol><p>初始化：<code>yarn init [--yes/-y]</code></p><ol start="2"><li><strong>安装</strong></li></ol><p>添加指定包：<code>yarn [global] add package-name [--dev/-D] [--exact/-E]</code></p><p>安装<code>package.json</code>中的所有依赖：<code>yarn install [--production/--prod]</code></p><ol start="3"><li><strong>脚本和本地CLI</strong></li></ol><p>运行脚本：<code>yarn run 脚本名</code> </p><blockquote><p>start、stop、test可以省略run</p></blockquote><p>运行本地安装的<code>CLI</code>：<code>yarn run CLI名</code></p><ol start="4"><li><strong>查询</strong></li></ol><p>查看bin目录：<code>yarn [global] bin</code></p><p>查询包信息：<code>yarn info 包名 [子字段]</code></p><p>列举已安装的依赖：<code>yarn [global] list [--depth=依赖深度]</code></p><blockquote><p>yarn的list命令和npm的list不同，yarn输出的信息更加丰富，包括顶级目录结构、每个包的依赖版本号</p></blockquote><ol start="5"><li><strong>更新</strong></li></ol><p>列举需要更新的包：<code>yarn outdated</code></p><p>更新包：<code>yarn [global] upgrade [包名]</code></p><ol start="6"><li><strong>卸载</strong></li></ol><p>卸载包：<code>yarn remove 包名</code></p><h3 id="yarn-的特别礼物"><a href="#yarn-的特别礼物" class="headerlink" title="yarn 的特别礼物"></a>yarn 的特别礼物</h3><p>在终端命令上，<code>yarn</code>不仅仅是对<code>npm</code>的命令做了一个改名，还增加了一些原本没有的命令，这些命令在某些时候使用起来非常方便</p><ol><li><strong>yarn check</strong></li></ol><p>使用<code>yarn check</code>命令，可以验证<code>package.json</code>文件的依赖记录和<code>lock</code>文件是否一致</p><p>这对于防止篡改非常有用</p><ol start="2"><li><strong>yarn audit</strong></li></ol><p>使用<code>yarn audit</code>命令，可以检查本地安装的包有哪些已知漏洞，以表格的形式列出，漏洞级别分为以下几种：</p><ul><li><strong>INFO</strong>：信息级别</li><li><strong>LOW</strong>: 低级别</li><li><strong>MODERATE</strong>：中级别</li><li><strong>HIGH</strong>：高级别</li><li><strong>CRITICAL</strong>：关键级别</li></ul><ol start="3"><li><strong>yarn why</strong></li></ol><p>使用<code>yarn why 包名</code>命令，可以在控制台打印出为什么安装了这个包，哪些包会用到它</p><ol start="4"><li><strong>yarn create</strong></li></ol><p>非常有趣的命令</p><p>今后，我们会学习一些脚手架，所谓脚手架，就是使用一个命令来搭建一个工程结构</p><p>过去，我们都是使用如下的做法：</p><ol><li>全局安装脚手架工具</li><li>使用全局命令搭建脚手架</li></ol><p>由于大部分脚手架工具都是以<code>create-xxx</code>的方式命名的，比如react的官方脚手架名称为<code>create-react-app</code></p><p>因此，可以使用<code>yarn create</code>命令来一步完成安装和搭建</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的两条命令</span></span><br><span class="line">yarn global add create-react-app</span><br><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure><h2 id="其他包管理器"><a href="#其他包管理器" class="headerlink" title="其他包管理器"></a>其他包管理器</h2><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><blockquote><p>官网地址：<a href="https://npm.taobao.org/">https://npm.taobao.org/</a></p></blockquote><p>为解决国内用户连接<code>npm registry</code>缓慢的问题，淘宝搭建了自己的<code>registry</code>，即淘宝npm镜像源</p><p>过去，<code>npm</code>没有提供修改registry的功能，因此，淘宝提供了一个<code>CLI</code>工具即<code>cnpm</code>，它支持除了<code>npm publish</code>以外的所有命令，只不过连接的是淘宝镜像源</p><p>如今，<code>npm</code>已经支持修改<code>registry</code>了，可能<code>cnpm</code>唯一的作用就是和<code>npm</code>共存，即如果要使用官方源，则使用<code>npm</code>，如果使用淘宝源，则使用<code>cnpm</code></p><h3 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h3><p><code>nvm</code>并非包管理器，它是用于管理多个<code>node</code>版本的工具</p><p>在实际的开发中，可能会出现多个项目分别使用的是不同的<code>node</code>版本，在这种场景下，管理不同的<code>node</code>版本就显得尤为重要</p><p><code>nvm</code>就是用于切换版本的一个工具</p><h4 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h4><p>最新版下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p>下载<code>nvm-setup.zip</code>后，直接安装</p><h4 id="使用nvm"><a href="#使用nvm" class="headerlink" title="使用nvm"></a>使用nvm</h4><p><code>nvm</code>提供了<code>CLI</code>工具，用于管理<code>node</code>版本</p><p>在终端中输入<code>nvm</code>，以查看各种可用命令</p><blockquote><p>为了加快下载速度，建议设置淘宝镜像<br>node淘宝镜像：<a href="https://npm.taobao.org/mirrors/node/">https://npm.taobao.org/mirrors/node/</a><br>npm淘宝镜像：<a href="https://npm.taobao.org/mirrors/npm/">https://npm.taobao.org/mirrors/npm/</a></p></blockquote><h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3><p><code>pnpm</code>是一种新起的包管理器，从<code>npm</code>的下载量看，目前还没有超过<code>yarn</code>，但它的实现方式值得主流包管理器学习，某些开发者极力推荐使用<code>pnpm</code></p><p>从结果上来看，它具有以下优势：</p><ol><li>目前，安装效率高于<code>npm</code>和<code>yarn</code>的最新版</li><li>极其简洁的<code>node_modules</code>目录</li><li>避免了开发时使用间接依赖的问题</li><li>能极大的降低磁盘空间的占用</li></ol><h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4><p>全局安装<code>pnpm</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><p>之后在使用时，只需要把<code>npm</code>替换为<code>pnpm</code>即可</p><p>如果要执行安装在本地的<code>CLI</code>，可以使用<code>pnpx</code>，它和 <code>npx</code> 的功能完全一样，唯一不同的是，在使用<code>pnpx</code>执行一个需要安装的命令时，会使用<code>pnpm</code>进行安装</p><blockquote><p>比如<code>npx mocha</code>执行本地的<code>mocha</code>命令时，如果<code>mocha</code>没有安装，则npx会自动的、临时的安装mocha，安装好后，自动运行mocha命令</p></blockquote><h4 id="pnpm原理"><a href="#pnpm原理" class="headerlink" title="pnpm原理"></a>pnpm原理</h4><ol><li><p>同 <code>yarn</code> 和 <code>npm</code> 一样，<code>pnpm</code> 仍然使用缓存来保存已经安装过的包，以及使用 <code>pnpm-lock.yaml</code> 来记录详细的依赖版本</p></li><li><p>不同于 <code>yarn</code> 和 <code>npm</code>， <code>pnpm</code> 使用<strong>符号链接和硬链接</strong>（可将它们想象成快捷方式）的做法来放置依赖，从而规避了从缓存中拷贝文件的时间，使得安装和卸载的速度更快</p></li><li><p>由于使用了<strong>符号链接和硬链接</strong>，<code>pnpm</code>可以规避<code>windows</code>操作系统路径过长的问题，因此，它选择使用树形的依赖结果，有着几乎完美的依赖管理。也因为如此，项目中只能使用直接依赖，而不能使用间接依赖</p></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于 <code>pnpm</code> 会改动 <code>node_modules</code> 目录结构，使得每个包只能使用直接依赖，而不能使用间接依赖，因此，如果使用 <code>pnpm</code> 安装的包中包含间接依赖，则会出现问题(<strong>现在不会了，除非使用了绝对路径</strong>)</p><p>由于 <code>pnpm</code> 超高的安装卸载效率，越来越多的包开始修正之前的间接依赖代码</p><h4 id="pnpm-原理"><a href="#pnpm-原理" class="headerlink" title="pnpm 原理"></a>pnpm 原理</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><blockquote><p>要彻底理解pnpm是怎么做的，需要有一些操作系统知识</p></blockquote><ol><li><strong>文件的本质</strong></li></ol><p>在操作系统中，文件实际上是一个指针，只不过它指向的不是内存地址，而是一个外部存储地址（这里的外部存储可以是硬盘、<code>U</code>盘、甚至是网络）</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111722420.png"></p><p>当我们删除文件时，删除的实际上是指针，因此，无论删除多么大的文件，速度都非常快。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111723627.png"></p><ol start="2"><li><strong>文件的拷贝</strong></li></ol><p>如果你复制一个文件，是将该文件指针指向的内容进行复制，然后产生一个新文件指向新的内容</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111723231.png"></p><ol start="3"><li><strong>硬链接 hard link</strong></li></ol><p>硬链接的概念来自于 <code>Unix</code> 操作系统，它是指将一个文件<code>A</code>指针复制到另一个文件B指针中，文件<code>B</code>就是文件<code>A</code>的硬链接</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111724005.png"></p><p>通过硬链接，不会产生额外的磁盘占用，并且，两个文件都能找到相同的磁盘内容</p><p>硬链接的数量没有限制，可以为同一个文件产生多个硬链接</p><p><code>windows Vista</code>操作系统开始，支持了创建硬链接的操作，在<code>cmd</code>中使用下面的命令可以创建硬链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mklink /h 链接名称 目标文件</span><br></pre></td></tr></table></figure><p>由于文件夹（目录）不存在文件内容，所以文件夹（目录）不能创建硬链接</p><blockquote><p>由于种种原因，在windows操作系统中，通常不要跨越盘符创建硬链接</p></blockquote><ol start="4"><li><strong>符号链接 symbol link</strong></li></ol><p>符号链接又称为软连接，如果为某个文件或文件夹<code>A</code>创建符号连接<code>B</code>，则B指向<code>A</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111725700.png"></p><p><code>windows Vista</code>操作系统开始，支持了创建符号链接的操作，在<code>cmd</code>中使用下面的命令可以创建符号链接：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mklink /d 链接名称 目标文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> /d表示创建的是目录的符号链接，不写则是文件的符号链接</span></span><br></pre></td></tr></table></figure><blockquote><p>早期的windows系统不支持符号链接，但它提供了一个工具junction来达到类似的功能</p></blockquote><p><strong>符号链接和硬链接的区别</strong></p><ol><li>硬链接仅能链接文件，而符号链接可以链接目录</li><li>硬链接在链接完成后仅和文件内容关联，和之前链接的文件没有任何关系。而符号链接始终和之前链接的文件关联，和文件内容不直接相关</li></ol><ol start="5"><li><strong>快捷方式</strong></li></ol><p>快捷方式类似于符号链接，是<code>windows</code>系统早期就支持的链接方式。</p><p>它不仅仅是一个指向其他文件或目录的指针，其中还包含了各种信息：如权限、兼容性启动方式等其他各种属性</p><p>由于快捷方式是<code>windows</code>系统独有的，在跨平台的应用中一般不会使用</p><ol start="6"><li><strong>node环境对硬链接和符号链接的处理</strong></li></ol><p><strong>硬链接</strong>：硬链接是一个实实在在的文件，<code>node</code>不对其做任何特殊处理，也无法区别对待，实际上，<code>node</code>根本无从知晓该文件是不是一个硬链接</p><p><strong>符号链接</strong>：由于符号链接指向的是另一个文件或目录，当<code>node</code>执行符号链接下的<code>JS</code>文件时，会使用原始路径。</p><h5 id="pnpm原理-1"><a href="#pnpm原理-1" class="headerlink" title="pnpm原理"></a>pnpm原理</h5><p><code>pnpm</code>使用符号链接和硬链接来构建<code>node_modules</code>目录</p><p>下面用一个例子来说明它的构建方式</p><p>假设两个包<code>a</code>和b，<code>a</code>依赖<code>b</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111726366.png"></p><p>假设我们的工程为<code>proj</code>，直接依赖<code>a</code>，则安装时，<code>pnpm</code>会做下面的处理</p><ol><li>查询依赖关系，得到最终要安装的包：<code>a</code>和<code>b</code></li><li>查看<code>a</code>和<code>b</code>是否已经有缓存，如果没有，下载到缓存中，如果有，则进入下一步</li><li>创建 <code>node_modules</code> 目录，并对目录进行结构初始化</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111726216.png"></p><ol start="4"><li>从缓存的对应包中使用硬链接放置文件到相应包代码目录中</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111726722.png"></p><ol start="5"><li>使用符号链接，将每个包的<strong>直接依赖</strong>放置到自己的目录中</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111727002.png"></p><p>这样做的目的，是为了保证<code>a</code>的代码在执行过程中，可以读取到它们的直接依赖</p><ol start="6"><li>新版本的<code>pnpm</code>为了解决一些书写不规范的包（读取间接依赖）的问题，又将所有的工程非直接依赖，使用符号链接加入到了 <code>.pnpm/node_modules</code> 中</li></ol><p>在本例中好像没有必要，但是如果<code>b</code>依赖<code>c</code>，<code>a</code>又要直接用<code>c</code>，这种不规范的用法现在<code>pnpm</code>通过这种方式支持了。</p><blockquote><p>但对于那些使用绝对路径的奇葩写法，可能永远也无法支持</p></blockquote><ol start="7"><li>在工程的<code>node_modules</code>目录中使用符号链接，放置直接依赖</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111727794.png"></p><ol start="8"><li>完成</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;包管理器&quot;&gt;&lt;a href=&quot;#包管理器&quot; class=&quot;headerlink&quot; title=&quot;包管理器&quot;&gt;&lt;/a&gt;包管理器&lt;/h1&gt;&lt;h2 id=&quot;包管理工具概述&quot;&gt;&lt;a href=&quot;#包管理工具概述&quot; class=&quot;headerlink&quot; title=&quot;包管理工具概述&quot;&gt;&lt;/a&gt;包管理工具概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本门课程的前置知识：JavaScript、ES6、模块化、git&lt;br&gt;本门课程的所有代码均书写在 nodejs 环境中，不涉及浏览器环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;模块（module）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常以单个文件形式存在的功能片段，入口文件通常称之为&lt;strong&gt;入口模块&lt;/strong&gt;或&lt;strong&gt;主模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;库（library，简称lib）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以一个或多个模块组成的完整功能块，为开发中某一方面的问题提供完整的解决方案&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;包（package）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含元数据的库，这些元数据包括：名称、描述、git主页、许可证协议、作者、依赖等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111717653.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CommonJS&lt;/code&gt; 的出现，使 &lt;code&gt;node&lt;/code&gt; 环境下的 &lt;code&gt;JS&lt;/code&gt; 代码可以用模块更加细粒度的划分。一个类、一个函数、一个对象、一个配置等等均可以作为模块，这种细粒度的划分，是开发大型应用的基石。&lt;/p&gt;
&lt;p&gt;为了解决在开发过程中遇到的常见问题，比如加密、提供常见的工具方法、模拟数据等等，一时间，在前端社区涌现了大量的第三方库。这些库使用 &lt;code&gt;CommonJS&lt;/code&gt; 标准书写而成，非常容易使用。&lt;/p&gt;
&lt;p&gt;然而，在下载使用这些第三方库的时候，遇到难以处理的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;下载过程繁琐&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;进入官网或 &lt;code&gt;github&lt;/code&gt; 主页&lt;/li&gt;
&lt;li&gt;找到并下载相应的版本&lt;/li&gt;
&lt;li&gt;拷贝到工程的目录中&lt;/li&gt;
&lt;li&gt;如果遇到有同名的库，需要更改名称&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果该库需要依赖其他库，还需要按照要求先下载其他库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开发环境中安装的大量的库如何在生产环境中还原，又如何区分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新一个库极度麻烦&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自己开发的库，如何在下一次开发使用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以上问题，就是包管理工具要解决的问题&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PackageManager" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/PackageManager/"/>
    
    
    <category term="包管理器" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Touch</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/Touch%20%E4%BA%8B%E4%BB%B6/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/Touch%20%E4%BA%8B%E4%BB%B6/</id>
    <published>2021-11-08T07:35:53.000Z</published>
    <updated>2022-05-17T01:12:47.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端-js-touch事件"><a href="#移动端-js-touch事件" class="headerlink" title="移动端 js touch事件"></a><a href="https://www.cnblogs.com/fengfan/p/4506555.html">移动端 js touch事件</a></h1><p>随着智能手机和平板电脑的普及, 越来越多的人用移动设备浏览网页，我们平时在<code>pc</code>浏览器上用的鼠标事件，比如：<code>click</code>, <code>mouseover</code>等， 已经无法满足移动设备触摸屏的特点，触摸时代的到来，离不开那些触摸事件。</p><h3 id="触摸事件包含4个接口。"><a href="#触摸事件包含4个接口。" class="headerlink" title="触摸事件包含4个接口。"></a>触摸事件包含4个接口。</h3><p><strong>TouchEvent</strong></p><ul><li>代表当触摸行为在平面上变化的时候发生的事件.</li></ul><p><strong>Touch</strong></p><ul><li>代表用户手指与触摸平面间的一个接触点.</li></ul><p><strong>TouchList</strong></p><ul><li>代表一系列的<code>Touch</code>; 一般在用户多个手指同时接触触控平面时使用这个接口.</li></ul><p><strong>DocumentTouch</strong></p><ul><li><p>包含了一些创建 <code>Touch</code>对象与<code>TouchList</code>对象的便捷方法.</p></li><li><p>（参考于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events">https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events</a> ）</p></li><li><p><code>TouchEvent</code>接口可以响应基本触摸事件（如单个手指点击），它包含了一些具体的事件， </p></li></ul><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul><li><p><code>touchstart</code> : 触摸开始（手指放在触摸屏上）</p></li><li><p><code>touchmove</code> : 拖动（手指在触摸屏上移动）</p></li><li><p><code>touchend</code>: 触摸结束（手指从触摸屏上移开）</p></li><li><p><code>touchenter</code> ：移动的手指进入一个<code>dom</code>元素。</p></li><li><p><code>touchleave</code> ：移动的手指离开一个<code>dom</code>元素。</p></li><li><p>还有一个<code>touchcancel</code>，是在拖动中断时候触发。</p></li></ul><h3 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h3><ul><li><code>altKey </code> : 该属性返回一个布尔值，表示在指定的事件发生时，<code>Alt</code> 键是否处于按下状态， <code>event.altKey=true|false|1|0</code></li><li><code>type</code> : 触摸时触发的事件类型，比如<code>touchstart</code></li><li><strong>每个触摸事件都包括了三个触摸属性列表：</strong></li><li><code>touches</code>：当前位于屏幕上的所有手指触摸点的一个列表。</li><li><code>targetTouches</code>：当前元素对象上所有触摸点的列表。</li><li><code>changedTouches</code>：涉及当前事件的触摸点的列表。</li><li>它们都是一个数组，每个元素代表一个触摸点。</li><li>每个触摸点对应的Touch都有三对重要的属性，<code>clientX/clientY</code>、<code>pageX/pageY</code>、<code>screenX/screenY</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移动端-js-touch事件&quot;&gt;&lt;a href=&quot;#移动端-js-touch事件&quot; class=&quot;headerlink&quot; title=&quot;移动端 js touch事件&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fengfan/p/4</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/JavaScript/"/>
    
    
    <category term="Touch" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/Touch/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 &amp; CSS3</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/HTML5%20&amp;%20CSS3/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/HTML5%20&amp;%20CSS3/</id>
    <published>2021-11-08T07:35:53.000Z</published>
    <updated>2022-05-17T01:12:47.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="HTML5结构"><a href="#HTML5结构" class="headerlink" title="HTML5结构"></a>HTML5结构</h2><hr><ul><li><code>HTML5</code> 是新一代的 <code>HTML</code></li><li><code>DTD</code>声明改变    <code>&lt;!DOCTYPE html&gt;</code><ul><li>新的结构标签            </li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文档申明 文档类型申明，html代表html5的文档类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--字符编码，charset=&#x27;utf-8&#x27;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">版本兼容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.省略引号，当属性值（&lt;、&gt;、=、单引号、双引号、空字符串）时，属性两边的引号可以省略，如&lt;input type=text&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.省略属性值，具有布尔值的属性，比如disabled，readonly，致谢属性值代表true，如：&lt;input type=checkbox checked&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="常用的一些新的结构标签"><a href="#常用的一些新的结构标签" class="headerlink" title="常用的一些新的结构标签"></a>常用的一些新的结构标签</h3><hr><ul><li><p>结构标签：（块状标签）有意义的<code>div</code></p><ul><li><code>header</code>：标记定义一个页面或一个区域的头部</li><li><code>footer</code>：标记定义一个页面或一个区域的底部</li><li><code>nav</code>：标记定义导航链接</li><li><code>article</code>：标记定义一篇文章</li><li><code>section</code>：标记定义一个区域</li><li><code>aside</code>：侧边栏导航</li><li><code>hgroup</code>：标记定义文件中一个区块的相关信息</li><li><code>flgure</code>：标记定义一组媒体内容以及它们的标题（图像）</li><li><code>figcaption</code>：标签定义<code>figure</code>元素的标题</li></ul></li><li><p>多媒体交互标签</p><ul><li><code>video</code>：标记定义一个视频</li><li><code>audio</code>：标记定义音频内容</li><li><code>source</code>：标记定义媒体资源</li><li><code>canvas</code>：标记定义画布（图片）</li><li><code>embed</code>：标记定义外部的可交互的内容或插件，比如<code>flash</code></li></ul></li><li><p>特殊样式标签</p><ul><li><code>mark</code>：突出显示文字</li><li><code>meter</code>：刻度百分占比</li><li><code>progress</code>：进度条</li><li><code>wbr</code>：长单词换行位置</li></ul></li><li><p>兼容性不是很好的标签</p><ul><li><code>dialog</code>：定义一个对话框</li><li><code>bdi</code>：单独设置文字播放方式（<code>dir=&#39;rti&#39; dir=&#39;ltr&#39;</code>）</li><li><code>details / summary</code>：描述部分的详情<code>summary</code>为<code>details</code>的标题</li><li><code>wbr</code>：长单词换行位置</li><li><code>datalist</code></li></ul></li><li><p>补充说明</p><ul><li><code>small</code> 这个元素表示边栏评论，如附属细则</li><li><code>cite</code>这个元素可用于显示作品标题（图书、电影、诗歌等）</li><li><code>adress</code>这个元素显示<code>article</code>或整个文档的合同信息，且位于<code>footer</code>这个元素之中</li><li><code>time</code>显示人和机器可读的日期和时间，而且机器可读的时间戳是属性<code>datetime</code>的值第二个可选的是<code>pubtime</code>用于表示出版日期值</li></ul></li></ul><h3 id="删除的HTML标签"><a href="#删除的HTML标签" class="headerlink" title="删除的HTML标签"></a>删除的<code>HTML</code>标签</h3><hr><ul><li><p>纯表现的元素：</p><ul><li><code>basefont</code></li><li><code>big</code></li><li><code>center</code></li><li><code>font</code></li><li><code>s</code></li><li><code>strike</code></li><li><code>tt</code></li><li><code>u</code></li></ul></li><li><p>对可用性产生负面影响的元素：</p><ul><li><code>frame</code></li><li><code>frameset</code></li><li><code>noframes</code></li><li>产生混淆的元素：<ul><li><code>acronym</code></li><li><code>applet</code></li><li><code>isindex</code></li><li><code>dir</code></li></ul></li></ul></li><li><p><strong>重新定义的<code>HTML</code>标签</strong></p><ul><li><code>&lt;b&gt;</code>  代表内联文本，通常是粗体，没有传递表示重要的意思</li><li><code>&lt;i&gt; </code> 代表内联文本，通常是斜体，没有传递表示重要的意思</li><li><code>&lt;dd&gt;</code> 可以同<code>details</code>与<code>figure</code>一同使用，定义包含文本，<code>ialog</code>也可用</li><li><code>&lt;dt&gt;</code> 可以同<code>details</code>与<code>figure</code>一同使用，汇总细节，<code>dialog</code>也可用</li><li><code>&lt;hr&gt; </code>表示主题结束，而不是水平线，虽然显示相同</li><li><code>&lt;menu&gt;</code> 重新定义用户界面的菜单，配合<code>commond</code>或者<code>menuitem</code>使用</li><li><code>&lt;small&gt;</code> 表示小字体，例如打印注释或者法律条款</li><li><code>&lt;strong&gt;</code> 表示重要性而不是强调符号</li></ul></li><li><p>崭新新的页面布局</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111700992.jpg" alt="传统的布局"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111700528.png" alt="实例-from-dunitian"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111700486.png" alt="草图--from-dunitian"></p><h2 id="HTML5智能表单"><a href="#HTML5智能表单" class="headerlink" title="HTML5智能表单"></a>HTML5智能表单</h2><hr><h3 id="HTML4-01-form表单复习"><a href="#HTML4-01-form表单复习" class="headerlink" title="HTML4.01 form表单复习"></a>HTML4.01 form表单复习</h3><hr><ul><li><code>input</code>表单<code>type</code>属性值<ul><li><code>type=&quot;text&quot;  </code>          单行文本输入框</li><li><code>type=&quot;password&quot; </code>  密码（<code>maxlength=&quot;&quot;</code>）</li><li><code>type=&quot;radio&quot;   </code>       单项选择（<code>checked=&quot;checked&quot;</code>）</li><li><code>type=&quot;checkbox&quot; </code>  多项选择</li><li><code>type=&quot;button&quot; </code>     按钮</li><li><code>type=&quot;submit&quot;</code>         提交</li><li><code>type=&quot;file&quot;</code>           上传文件</li><li><code>type=&quot;reset&quot;     </code>    重置</li></ul></li></ul><h3 id="HTML5智能表单-1"><a href="#HTML5智能表单-1" class="headerlink" title="HTML5智能表单"></a>HTML5智能表单</h3><hr><ul><li><code>input</code>表单<code>type</code>属性值：<ul><li><code>type=&quot;email&quot; </code> 限制用户输入必须为<code>Email</code>类型</li><li><code>type=&quot;url&quot;</code>          限制用户输入必须为<code>URL</code>类型</li><li><code>type=&quot;date&quot; </code>     限制用户输入必须为日期类型</li><li><code>type=&quot;datetime&quot;</code> 显示完整日期 含时区</li><li><code>type=&quot;datetime-local&quot; </code> 显示完整日期 不含时区</li><li><code>type=&quot;time&quot;  </code>    限制用户输入必须为时间类型</li><li><code>type=&quot;month&quot; </code>  限制用户输入必须为月类型</li><li><code>type=&quot;week&quot; </code>    限制用户输入必须为周类型</li><li><code>type=&quot;number&quot;</code> 限制用户输入必须为数字类型</li><li><code>type=&quot;range&quot;</code>    生成一个滑动条</li><li><code>type=&quot;search&quot;</code>  具有搜索意义的表单<code>results=&quot;n&quot;</code>属性</li><li><code>type=&quot;color&quot; </code>    生成一个颜色选择表单</li><li><code>type=&quot;tel&quot; </code>    显示电话号码</li></ul></li></ul><h3 id="Input-类型-Date-Pickers（日期选择器）"><a href="#Input-类型-Date-Pickers（日期选择器）" class="headerlink" title="Input 类型 - Date Pickers（日期选择器）"></a>Input 类型 - Date Pickers（日期选择器）</h3><hr><ul><li><p>**<code>HTML5</code> 拥有多个可供选取日期和时间的新输入类型：</p></li><li><p><code>date</code> 选取日、月、年</p></li><li><p><code>month</code> 选取月、年</p></li><li><p><code>week</code>  选取周和年</p></li><li><p><code>time </code>  选取时间（小时和分钟）</p></li><li><p>以下两个没有作用</p><ul><li><code>datetime</code>  选取时间、日、月、年（UTC 时间）</li><li><code>datetime-local</code>  选取时间、日、月、年（本地时间）</li></ul></li></ul><h3 id="HTML5新增表单属性"><a href="#HTML5新增表单属性" class="headerlink" title="HTML5新增表单属性"></a>HTML5新增表单属性</h3><hr><ul><li><code>required:</code> <code>required </code>内容不能为空</li><li><code>placeholder:</code> 表单提示信息</li><li><code>autofocus:</code>自动聚焦</li><li><code>pattern:</code> 正则表达式  输入的内容必须匹配到指定正则范围</li><li><code>autocomplete:</code>是否保存用户输入值<ul><li>默认为<code>on</code>，关闭提示选择<code>off</code></li></ul></li><li><code>formaction:</code> 在<code>submit</code>里定义提交地址</li><li><code>datalist:</code> 输入框选择列表配合<code>list</code>使用 <code> list</code>值为<code>datalist</code>的<code>id</code>值</li><li><code>output:</code> 计算或脚本输出</li></ul><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><hr><ul><li><p><code>validity</code>对象，通过下面的<code>valid</code>可以查看验证是否通过，如果八种验证都返回<code>true</code>,一种验证失败返回<code>false</code></p><ul><li><code>oText.addEventListener(&quot;invalid&quot;,fn1,false)</code></li><li><code>ev.preventDefault()</code>: 阻止默认事件</li><li><code>valueMissing</code>: 当输入值为空的时候，返回<code>true</code></li><li><code>typeMismatch</code>: 控件值与预期不吻合，返回<code>true</code></li><li><code>patternMismatch</code>: 输入值不满足<code>pattern</code>正则，返回<code>true</code></li><li><code>cusomError</code><ul><li><code>setCustomValidity()</code></li></ul></li></ul></li></ul><h2 id="audio-video"><a href="#audio-video" class="headerlink" title="audio/video"></a>audio/video</h2><ul><li><p>视频音频格式的简单介绍</p><ul><li>常见的视频格式<ul><li>视频的组成部分：画面、音频、编码格式</li><li>视频编码：<code>H.264</code>、<code>Theora</code>、<code>VP8</code>(<code>google</code>开源)</li></ul></li><li>常见的音频格式<ul><li>视频编码：<code>ACC</code>、<code>MP3</code>、<code>Vorbis</code></li></ul></li></ul></li><li><p><code>HTML5</code>能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。</p></li><li><p><strong>支持的视频格式：</strong></p><ul><li><code>Ogg=</code>带有<code>Theora</code>视频编码<code>+Vorbis</code>音频编码的<code>Ogg</code>文件</li><li><code>MEPG4=</code>带有<code>H.264</code>视频编码<code>+AAC</code>音频编码的<code>MPEG4</code>文件</li><li><code>WebM=</code>带有<code>VP8</code>视频编码<code>+Vorbis</code>音频编码的<code>WebM</code>格式</li></ul></li></ul><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><ul><li><p>单独用法</p><ul><li><code>&lt;audio id=&quot;audio&quot; src=&quot;./成都.mp3&quot;&gt;&lt;/audio&gt;</code></li><li><code>&lt;video id=&quot;video&quot; src=&quot;./成都.mp4&quot;&gt;&lt;/video&gt;</code></li><li>注意：<code>video</code>和<code>audio</code>的方法属性和事件是共有的</li></ul></li><li><p>多类型资源，兼容方法</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">&#x27;music&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;./成都.mp3&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;audio/mpeg&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;成都.ogg&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;audio/ogg&#x27;</span>&gt;</span></span><br><span class="line">    您的浏览器暂不支持audio标签。播放音乐</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>  <span class="attr">width</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;./成都.mp4&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/mpeg&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;成都.avi&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/ogg&#x27;</span>&gt;</span></span><br><span class="line">    您的浏览器暂不支持video标签。播放视频</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><ul><li><p>例：<code>&lt;video id=&quot;video&quot; src=&quot;./成都.mp4&quot; 属性1 属性2 属性……&gt;&lt;/video&gt;</code></p></li><li><p><code>autoplay</code> ：播放</p></li><li><p><code>controls</code>：显示控件</p></li><li><p><code>preload(none/metadata/auto)</code>：预加载</p><ul><li><code>node</code>：不需要加载数据</li><li><code>metadata</code>：元数据，诸如时长、比特率、帧大小这样的原数据而不是媒体内容需要加载的</li><li><code>auto</code>：浏览器应当加载它认为适量的媒体内容</li><li><code>&lt;video id=&quot;video&quot; src=&quot;***.mp4&quot; preload=&#39;auto&#39;&gt;&lt;/video&gt;</code></li></ul></li><li><p><code>loop</code>：是否循环播放视频</p></li><li><p><code>poster（video独有）</code>：当视频不可用时，使用一张图片替代，否则是空白</p><ul><li><code>&lt;video src=&quot;成都.mp4&quot; poster=&quot;***.jpg&quot; controls&gt;&lt;/video&gt;</code></li></ul></li><li><p>脚本化</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> audio = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;audio&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> audio = <span class="keyword">new</span> Audio(<span class="string">&#x27;./laojie.mp3&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> video= <span class="built_in">document</span>.createElement(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//audio可以通过new来创建，video不可以通过new来创建</span></span><br></pre></td></tr></table></figure><ul><li><p>设置属性值</p><ul><li><code>controls = true</code></li><li><code>loop = &#39;loop&#39;</code></li><li><code>preload = &#39;none/metadata/auto&#39;</code></li><li><code>autoplay = true</code></li><li><code>currentSrc = &#39;媒体数据的url地址&#39;</code></li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p><code>play()</code>：播放方法，方法运行后播放</p></li><li><p><code>pause()</code>：暂停方法，方法运行后暂停</p></li><li><p><code>load()</code>：重新加载视频/音频，用于在更改来源或其他设置后对音频/视频元素进行更新</p></li><li><p><code>addTextTrack()</code>：向音频/视频添加新的文本轨道</p></li><li><p><code>canPlayType()</code></p><ul><li>检测浏览器是否能播放指定的音频/视频类型</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Audio();</span><br><span class="line"><span class="keyword">if</span>(a.canPlayType(<span class="string">&quot;audio/mp3&quot;</span>))&#123;</span><br><span class="line">    a.src=<span class="string">&quot;./成都.mp3&quot;</span>;</span><br><span class="line">    a.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><strong>playbackRate</strong></p><ul><li>播放速率，用于指定媒体播放的速度，该属性值为<code>1.0</code>表示正常速度，大于<code>1</code>则表示快进，<code>0~1</code>之间表示慢放，负值表示回放</li><li>每个浏览器实现的会有差别，具体看浏览器实现</li></ul></li><li><p><strong>volume</strong>：</p><ul><li>调整音量大小，介于<code>0</code>（静音）——<code>1</code>（最大音量）之间，默认为<code>1</code>，将<code>muted</code>属性设置为<code>true</code>则会进入静音模式，设置为<code>false</code>则会恢复之前指定音量继续播放</li><li>超过范围会报错<code>[0,1]</code></li></ul></li><li><p><strong>currentTIme / duration</strong></p><ul><li><code>currentTime</code>：设置或返回音频/视频播放的时间位置</li><li><code>duration</code>：返回当前音频/视频的时长（<code>window.onload</code>），单位：秒</li></ul></li><li><p><strong>played / buffered / seekable</strong></p><ul><li><code>played</code>：返回已经播放的时间段</li><li><code>buffered</code>：返回当前已经缓冲的时间段<ul><li>确定当前缓存内容的百分比</li><li><code>Math.floor(song.buffered.end(0) / song.duration*100);</code></li></ul></li><li><code>seekable</code>：返回用户可以跳转的时间段</li><li><em>注意：</em>这三个属性都是<code>TImeRanges</code>对象，每个对象都有一个<code>length</code>属性以及<code>start()</code>和<code>end()</code>方法，<code>length</code>属性表示当前的一个时间段，<code>start()</code>与<code>end()</code>分别返回当前时间段的起始时间点和结束时间点（单位是秒，起始参数是<code>0</code>）</li></ul></li><li><p><strong>paused / seeking / ended</strong></p><ul><li><code>paused</code>：为<code>true</code>表示播放器暂停</li><li><code>seeking</code>：为<code>true</code>表示播放器正在调到一个新的播放点，它是一个事件</li><li><code>ended</code>：如果播放器播放完并且停下来，则属性为<code>true</code></li></ul></li><li><p><strong>preload</strong>：是否预加载视频/音频</p></li><li><p><a href="https://techbrood.com/tagsref?p=ref-av-dom">更多属性</a></p></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li>事件是当达到某个条件的时候会触发这个事件</li><li><code>play</code>：开始播放的时候触发事件</li><li><code>pause</code>：暂停播放的时候触发事件</li><li><code>loadedmetadata</code>：浏览器获取完媒体的元数据触发</li><li><code>loadeddata</code>：浏览器已经加载完当前帧数据，准备播放时触发，注意兼容<code>IE8</code></li><li><code>ended</code>：当前播放结束后触发</li><li><code>readyState</code>：音频当前就绪状态<ul><li>表示音频元素的当前网络状态</li><li><code>0 = NETWORK_EMPTY - 音频尚未初始化</code></li><li><code>1 = NETWORK_lDLE - 音频是活动的且选取资源，但并未使用网络</code></li><li><code>2 = NETWORK_LOADING - 浏览器正在下载数据</code></li><li><code>3 = NETWORK_NO_SOURCE - 未找到音频来源</code></li></ul></li><li><code>error</code>：在音频/视频<code>(audio/video)</code>加载发生错误时触发<ul><li><code>MediaError</code>对象的<code>code</code>属性返回一个数字值，它表示音频 / 视频的错误状态</li><li><code>1 = MEDIA_ERR_ABORTED - 取回过程被用户中止</code></li><li><code>2 = MEDIA_ERR_NETWORK - 当下载时发生错误</code></li><li><code>3 = MEDIA_ERR_DECODE - 当解码时发生错误</code></li><li><code>4 = MEDIA_ERR_SRC_NOT_SUPPORTED - 不支持音频/视频</code></li></ul></li><li>[更多事件](</li></ul><h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><ul><li><p>标签 <code>&lt;canvas&gt;</code></p><ul><li>不支持<code>canvas</code> 的浏览器可以看到的内容</li><li>注意：<code>canvas</code>宽高需要设置在标签中 否则绘制的东西可能出错</li></ul></li><li><p><code>canvas</code>的应用场景</p><ul><li>游戏</li><li>图表</li><li>动画</li><li><code>codepen.io</code>(<code>HTML5</code>动效)</li></ul></li><li><p><code>canvas</code>发展历史</p><ul><li>最早在<code>apple</code>的<code>safari1.3</code>中引入</li><li>ie9之前的浏览器不支持<code>canvas</code></li><li><a href="http://caniuse.com/">http://caniuse.com/</a></li></ul></li></ul><h3 id="使用canvas"><a href="#使用canvas" class="headerlink" title="使用canvas"></a>使用canvas</h3><ul><li><p><code>canvas</code>标签（画布）</p><ul><li><code>&lt;canvas width=&#39;&#39; height=&#39;&#39;&gt;&lt;/canvas&gt;</code></li></ul></li><li><p>获取<code>canvas</code>元素</p><ul><li><code>var canvas = document.getElementsById(&#39;mycanvas&#39;)</code></li></ul></li><li><p>获得<code>canvas</code>上下文对象（画笔）</p><ul><li><code>var ctx = canvas.getContext(&#39;2d&#39;);</code></li><li>因为<code>canvas</code>是画<code>2d</code>图形的</li><li><code>WebGL</code>绘图是画<code>3d</code>图形的</li></ul></li><li><p>注意：</p><ul><li>元素对象（<code>canvas</code>元素）和上下文对象（通过<code>getContext(&#39;2d&#39;)</code>⽅方法获取到的<code>CanvasRenderingContext2D</code>对象）</li><li>元素对象相当于我们的画布，上下文对象相当于画笔，我们接下来的所有操作是基于上下文对象的</li></ul></li><li><p><code>ctx</code>是画笔，就是<code>canvas</code>的上下文对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 画布 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&#x27;myCanvas&#x27;</span> <span class="attr">width</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">height</span>=<span class="string">&#x27;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>); <span class="comment">//获取canvas对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>); <span class="comment">//获取mycanvas的上下文对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><ul><li><code>moveTo(x,y)</code>：起始坐标点<code>x，y</code>（将触笔移动到<code>x,y</code>点）</li><li><code>lineTo(x,y)</code>：从起始点绘制到<code>x,y</code>点</li><li><code>stroke()</code>：触笔方法 画线  默认为黑色</li><li><code>closePath()</code>：闭合当前路径，和回到起始点的区别</li><li><code>fill()</code>：填充方法</li><li><code>fillStyle = color</code>：更改填充颜色</li><li><code>strokeStyle = color</code>：更改线段颜色</li><li><code>lineWidth = size</code>：设置线段宽度</li><li><code>beginPath()</code>：结束路径，开启一段新的路径</li><li><code>save()</code>：保存当前画布</li><li><code>restore()</code>：释放<code>save()</code>保存的画布</li><li>重点<ul><li><code>fill</code>和<code>stroke</code>方法都是作用在当前的所有子路径</li><li>完成一条路径后要重新开始另一条路径时必须使用<code>beginPath()</code>方法, <code>betinPath</code>开始子路径的一个新的集合</li></ul></li></ul><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><ul><li><code>rect(x,y,w,h)</code>：创建一个矩形<ul><li><code>x,y</code>代表起始点，<code>w,h</code>代表宽高</li></ul></li><li><code>fillRect(x,y,w,h)</code>：绘制填充的矩形</li><li><code>strokeRect(x,y,w,h)</code>：绘制空心矩形（无填充）</li><li><code>clearRect(x,y,w,h)</code>：擦除当前矩形区域<ul><li><code>x,y</code>代表起始点，<code>w,h</code>代表宽高</li></ul></li><li>注意：<ul><li><code>fillRect</code>和<code>strokeRect</code>都会自动结束路径</li></ul></li></ul><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="弧度"><a href="#弧度" class="headerlink" title="弧度"></a>弧度</h4><ul><li><code>arc(起始x位置,起始y位置,半径,起始弧度,结束弧度,弧形的方向)</code>：弧度<ul><li><code>ctx.arc(250,250,100,0,Math.PI()/2,0)</code></li><li>弧度的方向，<code>0</code>顺时针<code>1</code>逆时针</li></ul></li><li><code>arcTo(x1,y1,x2,y2,r)</code>：画布上创建介于两个切线之间的弧/曲线<ul><li><code>x1</code>,<code>y1</code> 坐标一  </li><li><code>x2</code>,<code>y2</code>坐标二   </li><li><code>r</code>：圆弧半斤</li><li>绘制的弧线与当前点和<code>x1,y1</code>连线，<code>x1,y1</code>和<code>x2,y2</code>连线都相切</li></ul></li></ul><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><ul><li><code>quadraticCurveTo(x1,y1,ex,ey)</code>：二次贝塞尔曲线<ul><li><code>x1,y1</code>：控制点</li><li><code>ex,ey</code>：结束点</li></ul></li><li><code>bezierCurveTo(x1,y1,x2,y2,ex,ey)</code>：三次贝塞尔曲线<ul><li><code>x1,y1,x2,y2</code>：控制点</li><li><code>ex,ey</code>：结束点</li></ul></li></ul><h3 id="坐标轴转换"><a href="#坐标轴转换" class="headerlink" title="坐标轴转换"></a>坐标轴转换</h3><ul><li><code>translate(x,y)</code>：重新映射画布上的(0,0)位置<ul><li>移动整张画布的位置</li></ul></li><li><code>scale(sx,sy)</code>：缩放当前<code>canvas</code>绘图</li><li><code>rotate(Math.PI)</code>：旋转当前的绘图，<code>弧度公式=角度*PI/180</code></li><li><code>setTransform(a,b,c,d,e,f)</code>：先重置画布再转换<ul><li>参数：<code>setTransform(水平旋转,水平倾斜,垂直倾斜,垂直缩放,水平移动,垂直移动)</code></li></ul></li><li><code>transform(a,b,c,d,e,f)</code>：不重置画布转换，和<code>setTransfrom</code>差不多</li></ul><h3 id="填充图案"><a href="#填充图案" class="headerlink" title="填充图案"></a>填充图案</h3><ul><li><p><code>createPattern(image,&#39;repeat|repeat-x|repeat-y|no-repeat&#39;)</code></p></li><li><p>不止可以添加<code>img</code>元素，还可以添加<code>canvas</code>元素</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">img元素(image对象),canvas元素，video元素（有图型的）</span><br><span class="line"></span><br><span class="line">&lt;canvas id=<span class="string">&quot;canvas1&quot;</span> width=<span class="string">&quot;500&quot;</span> height=<span class="string">&quot;500&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCanvas1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = oCanvas1.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> w = oCanvas1.width; <span class="comment">//画布的宽</span></span><br><span class="line"><span class="keyword">var</span> h = oCanvas1.height; <span class="comment">//画布的高</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oImg = <span class="keyword">new</span> Image();</span><br><span class="line">oImg.src = <span class="string">&#x27;图片的路径&#x27;</span>;</span><br><span class="line"></span><br><span class="line">oImg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fill = ctx.createPattern(oImg,<span class="string">&#x27;repeat&#x27;</span>);<span class="comment">//oImg元素和是否重复</span></span><br><span class="line">    ctx.fillStyle = fill;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,w,h); <span class="comment">//坐标点和宽高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ul><li><p><code>createLinearGradient(x1,y1,x2,y2)</code>：线性渐变</p><ul><li><code>x1</code>,<code>y1</code>起始坐标点</li><li><code>x2</code>,<code>y2</code>结束坐标点</li><li>线性渐变，必须在填充渐变的区域里定义渐变，否则没有效果</li></ul></li><li><p><code>createRedialGradient(x1,y1,r1,x2,y2,r2)</code>：径向渐变</p><ul><li><p><code>x1</code>,<code>y1</code>,<code>r1</code>内圆坐标及半径</p></li><li><p><code>x2</code>,<code>y2</code>,<code>r2</code>外圆坐标及半径</p></li><li><p><code>addColorStop</code>(位置,颜色)  位置:渐变点  <code>0-1</code>之间 可多个</p></li><li><p><code>bg.addColorStop(p,color)</code> ：添加颜色</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性渐变</span></span><br><span class="line">&lt;canvas id=<span class="string">&quot;canvas1&quot;</span> width=<span class="string">&quot;500&quot;</span> height=<span class="string">&quot;500&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCanvas1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = oCanvas1.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> w = oCanvas1.width; <span class="comment">//画布的宽</span></span><br><span class="line"><span class="keyword">var</span> h = oCanvas1.height; <span class="comment">//画布的高</span></span><br><span class="line"><span class="keyword">var</span> bg = ctx.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,h); <span class="comment">//背景渐变</span></span><br><span class="line"></span><br><span class="line">bg.addColorStop(<span class="number">0</span>,<span class="string">&#x27;red&#x27;</span>); </span><br><span class="line">bg.addColorStop(<span class="number">1</span>,<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">ctx.fillStyle = bg;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line"></span><br><span class="line"><span class="comment">//径向渐变</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCanvas1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = oCanvas1.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> w = oCanvas1.width; <span class="comment">//画布的宽</span></span><br><span class="line"><span class="keyword">var</span> h = oCanvas1.height; <span class="comment">//画布的高</span></span><br><span class="line"><span class="keyword">var</span> bg = ctx.createRadialGradient(<span class="number">250</span>,<span class="number">250</span>,<span class="number">50</span>,<span class="number">250</span>,<span class="number">250</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">bg.addColorStop(<span class="number">0</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">bg.addColorStop(<span class="number">0.5</span>,<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">bg.addColorStop(<span class="number">1</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">ctx.fillStyle = bg;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br></pre></td></tr></table></figure><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li><code>ctx.shadowColor = color</code>：阴影颜色，默认颜色：<code>rgba(0,0,0,0);</code></li><li><code>ctx.shadowOffsetX = x</code>：阴影<code>x</code>轴偏移量</li><li><code>ctx.shadowOffsetY = y</code>：阴影<code>y</code>轴偏移量</li><li><code>ctx.shadowBlur</code>：阴影模糊程度</li><li>这里的阴影偏移量不受坐标系变幻的影响</li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li><code>ctx.fillText(text,x,y,[,maxWidth])</code>：文本填充<ul><li>参数值：<code>text</code>:文本，<code>x,y</code>为坐标轴，<code>[,maxWidth]</code>:最大文本宽度</li></ul></li><li><code>ctx.strokeText(text,x,y,[,maxWidth])</code>：描边字体（空心文本）<ul><li>参数值：<code>text</code>:文本，<code>x,y</code>为坐标轴，<code>[,maxWidth]</code>:最大文本宽度</li></ul></li><li><code>ctx.measureText(text)</code>：测量文本尺寸<ul><li><code>text</code>：文字</li></ul></li><li><code>ctx.font = &#39;字体大小 字体类型&#39;</code>：尺寸、字体缺一不可</li><li>文本对齐方式<ul><li><code>ctx.textBaseline</code>：垂直方向</li><li><code>ctx.textAline</code>：水平方向</li><li>下图中小圆点就是x,y轴的起始位置，可以用<code>textBaseline</code>和<code>textAlign</code>更改圆点的位置</li><li><code>x,y</code>轴从字体的左下角开始</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111700800.jpg"></li></ul></li></ul><h3 id="线段样式"><a href="#线段样式" class="headerlink" title="线段样式"></a>线段样式</h3><ul><li><p><code>lineCap</code>：端点样式</p><ul><li><code>butt</code>(默认值),<code>round</code>(圆角),<code>square</code>(高度多出线宽一半)</li></ul></li><li><p><code>lineJoin</code>：边界连接点样式</p><ul><li>属性：<code>miter</code>(默认值),<code>round</code>(圆角),<code>bevel</code>(斜角)</li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111700725.jpg" alt="样式"></p></li><li><p><code>ctx.miterLimit;</code></p><ul><li>当<code>lineJoin</code>是<code>miter</code>时，用于控制斜接部分的长度</li><li>如果斜接长度超过 <code>miterLimit</code> 的值，变成<code>bevel</code></li><li>注:实际运算是大于<code>limit*lineWidth/2</code>的值，了解就好</li></ul></li></ul><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><ul><li><code>ctx.clip()</code>：当前路径外的区域不再绘制</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oCanvas1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = oCanvas1.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(<span class="number">200</span>,<span class="number">200</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.clip();</span><br><span class="line">ctx.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure><ul><li>注：可在<code>clip()</code> 前用 <code>save()</code> 方法保存，后续通过 <code>restore()</code> 方法恢复</li></ul><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><ul><li><p><code>ctx.globalAlpha = 0-1</code>：全局透明度</p></li><li><p><code>ctx.globalCompositeOperation = &#39;source-over&#39;</code>：新像素和原像素的合并方式</p><ul><li><code>11</code>种值，默认<code>source-over</code>，<code>w3c</code>标准</li></ul></li><li><p>```javascript<br>var oCanvas1 = document.getElementById(‘canvas1’);<br>var ctx = oCanvas1.getContext(‘2d’);</p><p>ctx.fillStyle = ‘red’;<br>ctx.fillRect(100,100,100,100);<br>ctx.globalCompositeOperation = ‘source-in’; //需要放在新像素和旧像素之间<br>ctx.fillStyle = ‘green’;<br>ctx.arc(180,180,50,0,Math.PI*2);<br>ctx.fill();</p></li><li><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td><code>source-over</code></td><td>默认值，将新图形画在旧图形之上</td></tr><tr><td><code>destination-over</code></td><td>将新图形画在旧图形之下</td></tr><tr><td><code>source-in</code></td><td>只保留新的，旧图形重叠的新图形区域，其余皆变透明</td></tr><tr><td><code>destination-in</code></td><td>只保留新，旧图形重叠的旧图形区域，其余皆变为透明</td></tr><tr><td><code>source-out</code></td><td>只保留新，旧图形非重叠的新图形区域，其余皆变为透明</td></tr><tr><td><code>destination-out</code></td><td>只保留新，旧图形非重叠的旧图形区域，其余皆变透明</td></tr><tr><td><code>source-atop</code></td><td>新图形只放置在新，旧图形重叠的新图形区域，然后盖在旧图形之上</td></tr><tr><td><code>destination-atop</code></td><td>旧图形只保留在新，旧图形重叠的旧图形区域，然后盖在新图形之上</td></tr><tr><td><code>lighter</code></td><td>新旧图形重叠区域的颜色，由新，旧图形的颜色码相加而得</td></tr><tr><td><code>darker</code></td><td>新旧图形重叠区域的颜色，由新，旧图形的颜色代码相减而得</td></tr><tr><td><code>xor</code></td><td>新旧图形重叠区域设置透明</td></tr><tr><td><code>copy</code></td><td>移除其他图形，只保留新图形</td></tr></tbody></table></li></ul><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><ul><li><p><code>ctx.drawImage();</code> </p><ul><li>第1个参数是<code>img(Image/canvas/video)</code> 注：<code>onload</code>调用</li><li>填2、3个参数 <code>(x, y)</code>：起始点坐标</li><li>填4、5个参数 <code>(x, y, dx, dy)</code> ：起始点坐标及图片所存区域的宽高</li><li>填2-9个参数 <code>(x1, y1, dx1, dy1, x2, y2, dx2, dy2)</code> <ul><li> 前四个为控制所绘制目标元素的起始点和宽高</li><li> 前四个写完之后，可以插入后面四个参数写的区域里面</li><li> 后四个为控制<code>canvas</code>绘制的起始点和大小</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;./demo/js/slideBox/carousel/img/2.jpg&quot;</span> alt=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;myImg&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> myImg = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myImg&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myImg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        ctx.drawImage(myImg,<span class="number">80</span>,<span class="number">80</span>,<span class="number">80</span>,<span class="number">80</span>,<span class="number">300</span>,<span class="number">300</span>,<span class="number">200</span>,<span class="number">200</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//ctx.drawImage(图片，x坐标轴，y坐标轴，宽，高，canvas的x标轴，canvas的y轴，宽，高)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>设置背景<ul><li><code>createPattern(img,平铺方式)</code></li><li>平铺方式:<code>repeat</code>,<code>repeat-x</code>,<code>repeat-y</code>,<code>no-repeat</code></li></ul></li></ul><h3 id="将canvas内容导出"><a href="#将canvas内容导出" class="headerlink" title="将canvas内容导出"></a>将canvas内容导出</h3><ul><li><p><code>canvas.toDataURL()</code></p></li><li><p>是<code>canvas</code>自身的方法不是上下文对象</p></li><li><p>将<code>canvas</code>的内容抽取成一张图片， <code>base64</code>编码格式</p></li><li><p>注：同源策略的显示</p></li><li><p>将<code>canvas</code>的内容放入<code>img</code>元素里</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oImg = <span class="keyword">new</span> Image(); <span class="comment">//声明了图片对象</span></span><br><span class="line"></span><br><span class="line">ctx.arc(<span class="number">250</span>,<span class="number">250</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = myCanvas.toDataURL(); <span class="comment">//把canvas转换为base64编码格式的图片信息</span></span><br><span class="line"></span><br><span class="line">oImg.src = data; <span class="comment">//让img图片的src等于data数据</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(oImg);</span><br></pre></td></tr></table></figure><h3 id="获取canvas像素信息"><a href="#获取canvas像素信息" class="headerlink" title="获取canvas像素信息"></a>获取canvas像素信息</h3><ul><li><p><code>ctx.getImageData(x,y,w,h)</code>：返回<code>ImageData</code>对象</p><ul><li><code>getImageData()</code>方法返回<code>ImageData</code>对象，该对象为画布上指定的矩形复制像素数据。</li><li>参数：<ul><li><code>x</code>：开始左上角<code>x</code>坐标</li><li><code>y</code>：开始左上角<code>y</code>坐标</li><li><code>w</code>：返回的矩形区域的宽度</li><li><code>h</code>：返回的矩形区域的高度</li></ul></li><li>对于 <code>ImageData</code> 对象中的每个像素，都存在着四方面的信息，即 <code>RGBA</code> 值：<ul><li><strong>R</strong> - 红色 <code>(0-255)</code></li><li><strong>G</strong> - 绿色 <code>(0-255)</code></li><li><strong>B</strong> - 蓝色 <code>(0-255)</code></li><li><strong>A</strong> - alpha 通道 <code>(0-255; 0 是透明的，255 是完全可见的)</code></li></ul></li></ul></li><li><p><code>ctx.createImageData(w,h)</code>：创建新的空白<code>ImageData</code>对象</p></li><li><p><code>ctx.putImageData(imgData,x,y)</code>：将图像数据放回画布上</p><ul><li>一般将处理完成的<code>getImageData()</code>数据放回<code>canvas</code>中</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//白色变成灰色</span></span><br><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"><span class="keyword">var</span> pixel = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//获取画布的像素数据</span></span><br><span class="line"><span class="keyword">var</span> row = pixel.width;</span><br><span class="line"><span class="keyword">var</span> col = pixel.height;</span><br><span class="line"><span class="keyword">var</span> d = pixel.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; row; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = i * col * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; col; j++)&#123;</span><br><span class="line">        d[c + j * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将处理过的数据放回canvas</span></span><br><span class="line">ctx.putImageData(pixel,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="命中检测"><a href="#命中检测" class="headerlink" title="命中检测"></a>命中检测</h3><ul><li><p><code>ctx.isPointInPath(x,y)</code>：检测是否在区域内，<code>chrome</code>与<code>safari</code>的区别</p></li><li><p><code>ctx.isPointInStroke(x,y)</code>：检测是否在线上</p></li><li><p>还可以通过检测当前点的像素值，如果为透明，则该点不在路径上</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ctx.isPointInPath(<span class="number">180</span>,<span class="number">120</span>));</span><br><span class="line"><span class="built_in">console</span>.log(ctx.isPointInStroke(<span class="number">200</span>,<span class="number">200</span>));</span><br></pre></td></tr></table></figure><h3 id="非零绕数准则"><a href="#非零绕数准则" class="headerlink" title="非零绕数准则"></a>非零绕数准则</h3><ul><li>判断点<code>p</code>是否在多边形内，从点<code>p</code>向外做一条射线（可以任意方向），多边形的边从左到右经过射线时环绕数减<code>1</code>，多边形的边从右往左经过射线时环绕数加<code>1</code>，最后环数不为<code>0</code>，即表示在多边形内部。  </li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111701073.jpg"></p><h3 id="如何解决canvas高分屏模糊问题"><a href="#如何解决canvas高分屏模糊问题" class="headerlink" title="如何解决canvas高分屏模糊问题"></a>如何解决canvas高分屏模糊问题</h3><ul><li>在分辨率比较高的屏幕，例如<code>ip6/6s/mac</code>等机器上，因为<code>canvs</code>绘制的是位图，所以会导致模糊，解决方法是根据屏幕分辨率修改<code>canvas</code>样式代码中的宽和高与<code>canvas</code>的<code>width</code>和<code>height</code>属性的比例</li></ul><ul><li>扩展阅读<ul><li><a href="http://luckykun.com/work/2016-09-01/canvas-study01.html">canvas学习之API整理笔记（一）</a></li><li><a href="http://jartto.wang/2016/07/25/make-an-inventory-of-html5-api/">HTML5 API大盘点</a></li></ul></li></ul><h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><ul><li><code>Scalable Vector Graphics</code>：可缩放矢量图形</li><li>应用场景<ul><li>图表</li><li>图标<code>icon</code></li><li>动效</li><li>矢量图</li></ul></li></ul><h3 id="使用svg"><a href="#使用svg" class="headerlink" title="使用svg"></a>使用svg</h3><ul><li>方式一：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">svg</span> </span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD SVG 1.1//EN&quot;</span>  <span class="meta-string">&quot;http://www.w3.org/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">Graphics/SVG/1.1/DTD/svg11.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span> </span><br></pre></td></tr></table></figure><ul><li>方式二：<ul><li>图片、背景、框架</li></ul></li><li>方式三: <ul><li><code>html</code>页面中添加<code>svg</code></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&#x27;500&#x27;</span> <span class="attr">height</span>=<span class="string">&#x27;500&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">    ···</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="形状标签"><a href="#形状标签" class="headerlink" title="形状标签"></a>形状标签</h3><blockquote><blockquote><p>所有的线段和路径都需要使用stroke属性来添加颜色</p></blockquote></blockquote><ul><li><p><strong>line：线条</strong></p><ul><li><code>&lt;line&gt;&lt;/line&gt;</code></li><li><code>x1</code>，<code>y1</code>：起始<code>x、y</code>点</li><li><code>x2</code>，<code>y2</code>：终点<code>x、y</code>点</li><li>例：<code>&lt;line x1=100 y1=100 x2=200 y2=100&gt;&lt;/line&gt;</code></li></ul></li><li><p><strong>rect：矩形</strong></p><ul><li><code>&lt;rect&gt;&lt;/rect&gt;</code></li><li><code>x，y</code>：起始点</li><li><code>width，height</code>：宽高</li><li><code>rx，ry</code>：<code>x，y</code>轴上面的圆角</li><li>例：<code>&lt;rect x=200 y=200 width=100 height=100 rx=10 ry=30&gt;&lt;/rect&gt;</code></li></ul></li><li><p><strong>circle：圆形</strong></p><ul><li><code>&lt;circle&gt;&lt;/circle&gt;</code></li><li><code>r</code>:圆的半径</li><li><code>cx，cy</code>:<code>x，y</code>的坐标点，圆的中心点</li><li>例：<code>&lt;circle r=50 cx=250 cy=250&gt;&lt;/circle&gt;</code></li></ul></li><li><p><strong>ellipse：椭圆</strong></p><ul><li><code>&lt;ellipse&gt;&lt;/ellipse&gt;</code></li><li><code>rx，ry</code>：圆在<code>x，y</code>轴的半径</li><li><code>cx，cy</code>：<code>x，y</code>的坐标点，圆的中心点</li><li>例：<code>&lt;ellipse rx=50 ry=100 cx=250 cy=250&gt;&lt;/ellipse&gt;</code></li></ul></li><li><p><strong>polyline：折线</strong></p><ul><li><code>&lt;polyline&gt;&lt;/polyline&gt;</code></li><li><code>points</code>:点坐标（<code>x1 y1 x2 y2...</code>）或(<code>x1,y1,x2,y2....</code>)    </li><li><code>x</code>代表起始点，<code>y</code>代表终止点</li><li>点和点连接起来，形成一条折线</li><li>例：<code>&lt;polyline points=&quot;60 50, 75 35, 100 50, 125 35, 150 50,175 35, 190 50&quot;&gt;&lt;/polyline&gt;</code></li></ul></li><li><p><strong>polygon：多边形</strong></p><ul><li><code>&lt;polygon&gt;&lt;/polygon&gt;</code></li><li><code>points</code>:点坐标（<code>x1 y1 x2 y2...</code>）或(<code>x1,y1,x2,y2....</code>)    </li><li><code>x</code>代表起始点，<code>y</code>代表终止点</li><li>折线闭合  <code>fill-rule:evenodd/nonzero</code>;</li><li>点和点连接起来，形成一条折线，最后一个点和第一个点闭合，形成多边形</li><li>例：<code>&lt;polygon points=&quot;60 50, 75 35, 100 50, 125 35, 150 50,175 35, 190 50&quot;&gt;&lt;/polygon&gt;</code></li></ul></li><li><p><strong>text：文本</strong></p><ul><li><code>&lt;text&gt;&lt;/text&gt;</code></li><li><code>x，y</code>：起始点，在<code>x，y</code>的那个点进行书写</li><li>例：<code>&lt;text x=100 y=100&gt;&lt;/text&gt;</code></li></ul></li><li><p><strong>g：组合对象的容器</strong></p><ul><li>添加到<code>g</code>元素上的变换会应用到其所有的子元素上。添加到<code>g</code>元素的属性会被其所有的子元素继承。此外，<code>g</code>元素也可以用来定义复杂的对象，之后可以通过<code>use</code>元素来引用它们</li></ul></li></ul><h3 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h3><blockquote><blockquote><p>所有的样式属性要在css进行设置</p><blockquote><p>所有的线段和路径都需要使用stroke属性来添加描边颜色</p></blockquote></blockquote></blockquote><ul><li><strong>fill</strong>：填充颜色</li><li><strong>stroke</strong>：描边颜色</li><li><strong>stroke-width</strong>：描边宽度</li><li><strong>stroke-opacity</strong>：描边透明度</li><li><strong>stroke-dasharray</strong>：描边虚线<ul><li><code>&lt;path stroke-dasharray=&quot;10,10&quot; d=&quot;M 5 40 l 215 0&quot; /&gt;</code></li></ul></li><li><strong>stroke-dashoffset</strong>：描边向左右缩进</li><li><strong>fill-opacity</strong>：填充透明度</li><li><strong>stroke-linecap</strong>：线的两端样式<ul><li><code>butt</code>：默认值</li><li><code>round</code>：多出来线宽的一半变成半圆</li><li><code>square</code>：两端多出来线宽的一半</li></ul></li><li><strong>stroke-lineJoin</strong>：边界连接点样式<ul><li><code>bevel</code>：斜角</li><li><code>round</code>：圆角</li><li><code>miter</code>：默认值</li></ul></li></ul><h3 id="path元素"><a href="#path元素" class="headerlink" title="path元素"></a>path元素</h3><ul><li><p><strong>路径的意思</strong></p><blockquote><p>指令也区分大小写，大写的指令是绝对定位，小写的指令是相对定位，相对于元素进行多少个像素进行移动</p><blockquote><p>path元素使用d属性来控制路径，如：<path d=""></path></p><blockquote><p>所有的指令大写的指令为绝对坐标（具体的坐标位置）</p><p>小写的指令为相对位置（相对于起始坐标点的具体长度）</p></blockquote></blockquote></blockquote></li></ul><h4 id="M和L指令"><a href="#M和L指令" class="headerlink" title="M和L指令"></a>M和L指令</h4><ul><li><code>M</code>指令：<code>moveTo</code>的意思，画笔初始的位置</li><li><code>L</code>指令：<code>lineTo</code>的意思，画笔要画到的位置<ul><li>每两个值是一个<code>x，y</code>坐标，L后面可以一直写<code>x，y</code>坐标</li></ul></li><li>例：<code>&lt;path d=&quot;M 100 100 L 200 100 200 200&quot;&gt;&lt;/path&gt;</code></li></ul><h4 id="H和V指令"><a href="#H和V指令" class="headerlink" title="H和V指令"></a>H和V指令</h4><ul><li><code>H</code>指令：<code>horizontal lineto</code>的意思<ul><li><code>x</code>轴移动到的位置</li><li>绘制水平线</li></ul></li><li><code>V</code>指令：<code>vertical lineto</code>的意思<ul><li><code>y</code>轴移动到的位置</li><li>绘制垂直线</li></ul></li><li>例：<code>&lt;path d=&#39;M 100 100 H 200 V 200&#39;&gt;</code>，把线移动到<code>x</code>轴<code>200</code>的位置，<code>y</code>轴<code>200</code>的位置</li></ul><h4 id="Z指令"><a href="#Z指令" class="headerlink" title="Z指令"></a>Z指令</h4><ul><li><code>z</code>指令：<code>closePath</code>的意思，闭合指令</li><li>不区分大小写</li><li>例：<code>&lt;path d=&#39;M 100 100 H 200 V 200 z&#39;&gt;</code></li></ul><h4 id="A指令"><a href="#A指令" class="headerlink" title="A指令"></a>A指令</h4><ul><li><code>A</code>指令：<code>elliptical Arc</code>的意思，圆弧指令</li><li>参数<ul><li><code>rx，ry</code>圆弧的<code>x</code>轴半径和<code>y</code>轴半径</li><li><code>x-axis-rotation</code>：圆弧相对于x轴的旋转角度，默认是顺时针，可以设置负值</li><li><code>large-arc-flag</code>：表示圆弧路径是大圆弧还是小圆弧，<code>1</code>代表大圆弧，<code>0</code>代表小圆弧</li><li><code>sweep-flag</code>：表示从起点到终点是顺时针还是逆时针，<code>1</code>表示顺时针，<code>0</code>表示逆时针</li><li><code>x，y</code>：表示终点坐标</li></ul></li><li>例：<code>&lt;path d=&#39;M 100 100 A 70 120 90 1 1 150 200&#39;&gt;&lt;/path&gt;</code></li></ul><h4 id="贝塞尔曲线-1"><a href="#贝塞尔曲线-1" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><h5 id="Q和T指令"><a href="#Q和T指令" class="headerlink" title="Q和T指令"></a>Q和T指令</h5><ul><li><strong>二次贝塞尔曲线</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111701232.GIF" alt="二次贝塞尔曲线"></p><ul><li><strong>Q指令</strong><ul><li><code>x1，y1</code>：起始控制点</li><li><code>x，y</code>：终止点</li><li>例：<code>&lt;path d=&quot;M 100 200 Q 200 100 300 300&quot;&gt;&lt;/path&gt;</code></li></ul></li><li><strong>T指令</strong><ul><li>二次贝塞尔曲线的延申</li><li><code>x，y</code>：后面添加的两个终止点</li><li>例：<code>&lt;path M 100 200 Q 200 100 300 300 T 500 400&gt;&lt;/path&gt;</code></li></ul></li></ul><h5 id="C和S指令"><a href="#C和S指令" class="headerlink" title="C和S指令"></a>C和S指令</h5><ul><li><strong>三次贝塞尔曲线</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111701361.GIF" alt="三次贝塞尔曲线"></p><ul><li><p><strong>C指令</strong></p><ul><li><code>x1，y1</code>：起始控制点</li><li><code>x2，y2</code>：过渡控制点</li><li><code>x，y</code>：终止点</li><li>例：<code>&lt;path d=&quot;M 0 200 C 100 100 200 100 300 400&quot;&gt;&lt;/path&gt;</code></li></ul></li><li><p><strong>S指令</strong></p><ul><li>三次贝塞尔曲线的延申</li><li><code>x2，y2</code>：过渡控制点</li><li><code>x，y</code>：终止点</li><li>例：<code>&lt;path d=&quot;M 0 200 C 100 100 200 100 300 400 S 500 500 500 0&quot;&gt;&lt;/path&gt;</code></li></ul></li></ul><h4 id="获取长度和坐标方法"><a href="#获取长度和坐标方法" class="headerlink" title="获取长度和坐标方法"></a>获取长度和坐标方法</h4><ul><li><strong>getTotalLength</strong>：获取路径总长度</li><li>**getPointAtLength(x)**：获取路径上距离起始点距离<code>x</code>长度的点的坐标</li><li>注：严格来说上面两方法只适用于<code>path</code>元素，但各个浏览器实现起来都会有一点区别。例如谷歌浏览器也能获取到<code>line</code>元素的路径长度。</li></ul><h3 id="自动生成路径"><a href="#自动生成路径" class="headerlink" title="自动生成路径"></a>自动生成路径</h3><ul><li>Method Draw：<a href="http://editor.method.ac/">http://editor.method.ac/</a></li></ul><h3 id="svg渐变"><a href="#svg渐变" class="headerlink" title="svg渐变"></a>svg渐变</h3><ul><li><p><code>defs</code>标签，定义以后需要重复使用的图形元素</p></li><li><p>线性渐变</p><ul><li><p><code>linearGradient</code>：线性渐变标签</p><ul><li>属性值</li><li><code>id</code>：代表这个渐变的名字，方便其他标签调用</li><li><code>x1，y1</code>：起始点</li><li><code>x2，y2</code>：终止点，起始点和终止点可以改变渐变方向</li></ul></li><li><p><code>stop</code>：颜色节点，设置几个颜色节点就代表几个颜色</p><ul><li>属性值</li><li><code>offset</code>：颜色节点的位置，定义渐变色开始和结束</li><li><code>stop-color</code>：颜色节点的颜色</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">&quot;bg1&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y2</span> =<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:rgb(255,255,0);&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:rgb(255,0,0);&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:url(#bg1)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>径向渐变</p><ul><li><p><code>radialGradient</code>：径向渐变标签</p><ul><li>属性值</li><li><code>id</code>：代表这个渐变的名字，方便其他标签调用</li><li><code>cx，cy</code>：圆的中心点，此属性定义径向渐变的结束圆的<code>x，y</code>坐标。</li><li><code>r</code>：圆的半径</li><li><code>fx，fy</code>：圆的扩散范围，此属性定义径向渐变的起始圆的<code>x，y</code>坐标。</li></ul></li><li><p><code>stop</code>：颜色节点，设置几个颜色节点就代表几个颜色</p><ul><li>属性值</li><li><code>offset</code>：颜色节点的位置，定义渐变色开始和结束</li><li><code>stop-color</code>：颜色节点的颜色</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">radialGradient</span> <span class="attr">id</span>=<span class="string">&quot;bg2&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">fx</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">fy</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:green;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:red;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">radialGradient</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:url(#bg2)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="svg滤镜"><a href="#svg滤镜" class="headerlink" title="svg滤镜"></a>svg滤镜</h3><ul><li>高斯滤镜</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">id</span>=<span class="string">&quot;Gaussian_Blur&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">feGaussianBlur</span> <span class="attr">in</span>=<span class="string">&quot;SourceGraphic&quot;</span> <span class="attr">stdDeviation</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;yellow&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:url(#Gaussian_Blur)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>其他滤镜</p><ul><li><a href="http://www.w3school.com.cn/svg/svg_filters_intro.asp">http://www.w3school.com.cn/svg/svg_filters_intro.asp</a></li></ul></li></ul><h3 id="svg路径动画"><a href="#svg路径动画" class="headerlink" title="svg路径动画"></a>svg路径动画</h3><ul><li><p><strong>stroke-dasharray：–px</strong></p></li><li><p><strong>stroke-dashoffset：–px;</strong></p></li><li><p>动画实现原理理，通过修改<code>stroke-dashoffse</code>t的值让路路径慢慢地展现出来</p></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">path&#123;</span><br><span class="line">    stroke: orange;</span><br><span class="line">    fill: none;</span><br><span class="line">    stroke-<span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    stroke-dasharray:<span class="number">20px</span>;</span><br><span class="line">    stroke-dashoffset: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">animation</span>:move <span class="number">3s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">    stroke-dashoffset: <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">    stroke-dashoffset: <span class="number">500px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;svg <span class="attribute">width</span>=<span class="number">500</span> <span class="attribute">height</span>=<span class="number">500</span>&gt;</span><br><span class="line">&lt;path d=&quot;M <span class="number">0</span> <span class="number">100</span> L <span class="number">500</span> <span class="number">100</span>&quot;&gt;&lt;/path&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="ViewBox"><a href="#ViewBox" class="headerlink" title="ViewBox"></a>ViewBox</h3><ul><li><p><strong>ViewBox</strong></p><ul><li><p><code>viewBox</code>属性允许指定一个给定的一组图形伸展以适应特定的容器元素。</p></li><li><p><code>viewBox</code>属性的值是一个包含4个参数的列表 <code>min-x</code>, <code>min-y</code>, <code>width</code> and <code>height</code>， 以空格或者逗号分隔开，<code>viewBox</code>的四个参数分别代表：最小X轴数值，最小y轴数值，宽度，高度。</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">400</span> <span class="attr">height</span>=<span class="string">300</span> <span class="attr">viewBox</span>=<span class="string">&quot;0,0,40,30&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">ViewBox后两个参数的意思是，虽然在画布设置的宽有400，高有300，但实际的单位宽只有40个单位宽，高只有30单位高，也就是说设置上ViewBox之后，虽然你设置的宽不管有多大，最后都是要按照ViewBox设置的宽高来决定比例的</span><br></pre></td></tr></table></figure><ul><li><p><strong>preserveAspectRatio</strong>对齐、填充方式</p><ul><li><code>xMin</code>、<code>xMid</code>、<code>xMax</code>：<code>x</code>轴-左中右对齐</li><li><code>YMin</code>、<code>YMid</code>、<code>YMax</code>：<code>y</code>轴-上中下对齐</li><li><code>meet</code>、<code>slice</code>、<code>none</code>：撑开、撑满、形变（设置填充方式）</li><li>例：<code>svg.setAttribute(&quot;preserveAspectRatio&quot;, &quot;xMinYMin slice&quot;)</code></li></ul></li></ul><h3 id="用JS生成svg元素"><a href="#用JS生成svg元素" class="headerlink" title="用JS生成svg元素"></a>用JS生成svg元素</h3><ul><li><p>创建<code>svg</code>元素需要制定命名空间</p></li><li><p><code>svg</code>元素对象一般通过调用<code>setAttribute()</code>方法来设定属性值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> char = <span class="string">&#x27;http://www.w3.org/2000/svg&#x27;</span>, </span><br><span class="line">    <span class="comment">//命名空间的名称，固定好的</span></span><br><span class="line">    svg = <span class="built_in">document</span>.createElementNS(char,<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line"></span><br><span class="line">svg.setAttribute(<span class="string">&#x27;width&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">svg.setAttribute(<span class="string">&#x27;height&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">svg.setAttribute(<span class="string">&#x27;viewBox&#x27;</span>,<span class="string">&#x27;0 0 500 500&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="built_in">document</span>.createElementNS(char,<span class="string">&#x27;rect&#x27;</span>);</span><br><span class="line"></span><br><span class="line">rect.setAttribute(<span class="string">&#x27;x&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">rect.setAttribute(<span class="string">&#x27;y&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">rect.setAttribute(<span class="string">&#x27;width&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">rect.setAttribute(<span class="string">&#x27;height&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">rect.setAttribute(<span class="string">&#x27;fill&#x27;</span>,<span class="string">&#x27;#0fc&#x27;</span>);</span><br><span class="line">svg.appendChild(rect);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(svg);</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输入数字，进度条占用</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    svg &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    path&#123;</span></span><br><span class="line"><span class="css">        fill: none;</span></span><br><span class="line"><span class="css">        stroke-<span class="attribute">width</span>:<span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        stroke-linecap: round;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#path1</span> &#123;</span></span><br><span class="line"><span class="css">        stroke:<span class="number">#ccc</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#path2</span>&#123;</span></span><br><span class="line"><span class="css">        stroke:orange;</span></span><br><span class="line"><span class="css">        stroke-dasharray:<span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">        stroke-dashoffset:<span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">transition</span>:  all <span class="number">1s</span> linear;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">500</span> <span class="attr">height</span>=<span class="string">500</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">&quot;path1&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 200 300 A 100 100 0 1 1 300 300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">&quot;path2&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 200 300 A 100 100 0 1 1 300 300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取path长度</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> len = path2.getTotalLength();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        btn.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> value = <span class="built_in">this</span>.value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> total = len * value / <span class="number">100</span>; <span class="comment">//变成百分比</span></span></span><br><span class="line"><span class="javascript">            path2.classList.add(<span class="string">&#x27;active&#x27;</span>); <span class="comment">//单独设置动画class类名</span></span></span><br><span class="line"><span class="javascript">            path2.style.strokeDashoffset = <span class="number">1000</span> - total + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        btn.onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            path2.classRemove(<span class="string">&#x27;active&#x27;</span>);<span class="comment">//失去焦点之后删除class，立即消失</span></span></span><br><span class="line"><span class="javascript">            path2.style.strokeDashOffset=<span class="string">&#x27;1000px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">loading效果</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    svg &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    circle,path &#123;</span></span><br><span class="line"><span class="css">    fill:transparent;</span></span><br><span class="line"><span class="css">    stroke:<span class="number">#ff6700</span>;</span></span><br><span class="line"><span class="css">    stroke-<span class="attribute">width</span>:<span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    stroke-linecap: round;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    circle &#123;</span></span><br><span class="line"><span class="css">    stroke: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">150</span>,<span class="number">0</span>,.<span class="number">5</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">100</span> <span class="attr">height</span>=<span class="string">100</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">40</span> <span class="attr">cx</span>=<span class="string">50</span> <span class="attr">cy</span>=<span class="string">50</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 10 50 A 40 40 0 0 1 50 10&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animateTransform</span> <span class="attr">attributeName</span>=<span class="string">&quot;transform&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rotate&quot;</span> <span class="attr">from</span>=<span class="string">&#x27;0 50 50&#x27;</span> <span class="attr">to</span>=<span class="string">&#x27;360 50 50&#x27;</span> <span class="attr">dur</span>=<span class="string">&#x27;0.5s&#x27;</span> <span class="attr">repeatCount</span>=<span class="string">&#x27;indefinite&#x27;</span>&gt;</span>/<span class="tag">&lt;/<span class="name">animateTransform</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">叮当猫</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    svg &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.face</span> &#123;</span></span><br><span class="line"><span class="css">    fill: white;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.eye</span>&#123;</span></span><br><span class="line"><span class="css">    fill: white;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.line-black</span> &#123;</span></span><br><span class="line"><span class="css">stroke: black;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.fill-blue</span> &#123;</span></span><br><span class="line"><span class="css">fill:<span class="number">#2E87FD</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.mouth</span> &#123;</span></span><br><span class="line"><span class="css">fill: none;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.nose</span> &#123;</span></span><br><span class="line"><span class="css">fill: <span class="number">#FD0100</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.nose-light</span> &#123;</span></span><br><span class="line"><span class="css">fill: white;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.sling</span> &#123;</span></span><br><span class="line"><span class="css">stroke-<span class="attribute">width</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">stroke: red;</span></span><br><span class="line"><span class="css">stroke-linecap: round;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.bell</span> &#123;</span></span><br><span class="line"><span class="css">fill: <span class="number">#cece1b</span>;</span></span><br><span class="line"><span class="css">fill-<span class="attribute">opacity</span>: .<span class="number">7</span>;;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.body</span> &#123;</span></span><br><span class="line"><span class="css">stroke: black;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.fist</span> &#123;</span></span><br><span class="line"><span class="css">fill: white;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pocket</span> &#123;</span></span><br><span class="line"><span class="css">fill: white;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pocket-line</span> &#123;</span></span><br><span class="line"><span class="css">fill: none;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.foot</span> &#123;</span></span><br><span class="line"><span class="css">stroke: black;</span></span><br><span class="line"><span class="css">fill: white;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.foot-y</span> &#123;</span></span><br><span class="line"><span class="css">fill: white;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&#x27;510&#x27;</span> <span class="attr">height</span>=<span class="string">510</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 头部蓝色背景 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&#x27;line-black fill-blue head-back&#x27;</span> <span class="attr">d</span>=<span class="string">&quot;M 150 300 A 160 160 0 1 1 350 300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 脸部白色背景 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">rx</span>=<span class="string">130</span> <span class="attr">ry</span>=<span class="string">110</span> <span class="attr">cx</span>=<span class="string">250</span> <span class="attr">cy</span>=<span class="string">220</span> <span class="attr">class</span>=<span class="string">&quot;face line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 眼睛-右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">rx</span>=<span class="string">35</span> <span class="attr">ry</span>=<span class="string">45</span> <span class="attr">cx</span>=<span class="string">215</span> <span class="attr">cy</span>=<span class="string">110</span> <span class="attr">class</span>=<span class="string">&quot;eye line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 眼睛-左 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">rx</span>=<span class="string">35</span> <span class="attr">ry</span>=<span class="string">45</span> <span class="attr">cx</span>=<span class="string">285</span> <span class="attr">cy</span>=<span class="string">110</span> <span class="attr">class</span>=<span class="string">&quot;eye line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 眼珠-右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">rx</span>=<span class="string">8</span> <span class="attr">ry</span>=<span class="string">10</span> <span class="attr">cx</span>=<span class="string">225</span> <span class="attr">cy</span>=<span class="string">120</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 眼珠-左 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">rx</span>=<span class="string">8</span> <span class="attr">ry</span>=<span class="string">10</span> <span class="attr">cx</span>=<span class="string">275</span> <span class="attr">cy</span>=<span class="string">120</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 胡须-右 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 150 180 L 210 190&quot;</span> <span class="attr">class</span>=<span class="string">&quot;line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 145 205 L 210 205&quot;</span> <span class="attr">class</span>=<span class="string">&quot;line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 150 230 L 210 220&quot;</span> <span class="attr">class</span>=<span class="string">&quot;line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 胡须-左 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 280 190 L 350 180&quot;</span> <span class="attr">class</span>=<span class="string">&quot;line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 280 205 L 345 205&quot;</span> <span class="attr">class</span>=<span class="string">&quot;line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 280 220 L 350 230&quot;</span> <span class="attr">class</span>=<span class="string">&quot;line-black &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 嘴巴 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">line</span> <span class="attr">class</span>=<span class="string">&quot;mouth line-black &quot;</span> <span class="attr">x1</span>=<span class="string">250</span> <span class="attr">y1</span>=<span class="string">165</span> <span class="attr">x2</span>=<span class="string">250</span> <span class="attr">y2</span>=<span class="string">270</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;mouth line-black &quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 180 240 A 80 50 0 0 0 325 240&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 鼻子 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;nose line-black &quot;</span> <span class="attr">rx</span>=<span class="string">15</span> <span class="attr">ry</span>=<span class="string">15</span> <span class="attr">cx</span>=<span class="string">250</span> <span class="attr">cy</span>=<span class="string">160</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;nose-light line-black &quot;</span> <span class="attr">rx</span>=<span class="string">5</span> <span class="attr">ry</span>=<span class="string">7</span> <span class="attr">cx</span>=<span class="string">257</span> <span class="attr">cy</span>=<span class="string">155</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 身体背景 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rect</span> <span class="attr">class</span>=<span class="string">&quot;body fill-blue&quot;</span> <span class="attr">x</span>=<span class="string">150</span> <span class="attr">y</span>=<span class="string">300</span> <span class="attr">width</span>=<span class="string">200</span> <span class="attr">height</span>=<span class="string">170</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 左胳膊 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;arm fill-blue&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 90 290 L 180 330 170 365 90 330 90 290&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;line-black fist&quot;</span> <span class="attr">rx</span>=<span class="string">22</span> <span class="attr">ry</span>=<span class="string">22</span> <span class="attr">cx</span>=<span class="string">97</span> <span class="attr">cy</span>=<span class="string">312</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 右胳膊 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;arm fill-blue&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 320 330 L 410 305 410 340 320 365 320 360&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;line-black fist&quot;</span> <span class="attr">rx</span>=<span class="string">22</span> <span class="attr">ry</span>=<span class="string">22</span> <span class="attr">cx</span>=<span class="string">410</span> <span class="attr">cy</span>=<span class="string">320</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 口袋 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;pocket&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 180 310 A 80 85 0 1 0 320 310&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;line-black pocket-line&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 200 370 A 40 40 0 1 0 300 370 z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 挂绳 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;sling&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 150 300 L 350 300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 铃铛 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;bell line-black &quot;</span> <span class="attr">rx</span>=<span class="string">20</span> <span class="attr">ry</span>=<span class="string">20</span> <span class="attr">cx</span>=<span class="string">250</span> <span class="attr">cy</span>=<span class="string">315</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">rx</span>=<span class="string">7</span> <span class="attr">ry</span>=<span class="string">7</span> <span class="attr">cx</span>=<span class="string">250</span> <span class="attr">cy</span>=<span class="string">325</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;line-black&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M 250 325 L 250 335&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 脚 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;foot-y&quot;</span> <span class="attr">rx</span>=<span class="string">15</span> <span class="attr">ry</span>=<span class="string">20</span> <span class="attr">cx</span>=<span class="string">255</span> <span class="attr">cy</span>=<span class="string">480</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 左脚 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;foot&quot;</span> <span class="attr">rx</span>=<span class="string">60</span> <span class="attr">ry</span>=<span class="string">20</span> <span class="attr">cx</span>=<span class="string">190</span> <span class="attr">cy</span>=<span class="string">480</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 右脚 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">class</span>=<span class="string">&quot;foot&quot;</span> <span class="attr">rx</span>=<span class="string">60</span> <span class="attr">ry</span>=<span class="string">20</span> <span class="attr">cx</span>=<span class="string">320</span> <span class="attr">cy</span>=<span class="string">480</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h2><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><ul><li><p><strong>localstorage</strong>：永久存储（可以手动删除数据）</p></li><li><p><strong>seesionstorage</strong>：<code>session</code>临时回话，从页面打开到页面关闭的时间段窗口的临时存储，页面关闭，本地存储消失</p></li><li><p>存储数据</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.name = <span class="string">&#x27;aimee&#x27;</span>;</span><br><span class="line"><span class="built_in">localStorage</span>.info = <span class="string">`JSON.stringify(&#123;</span></span><br><span class="line"><span class="string">name:&#x27;aimee&#x27;,</span></span><br><span class="line"><span class="string">company:&#x27;diyi&#x27;</span></span><br><span class="line"><span class="string">&#125;)`</span></span><br></pre></td></tr></table></figure><ul><li>取出数据</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.name</span><br><span class="line"><span class="built_in">localStorage</span>.info</span><br></pre></td></tr></table></figure><ul><li><p>作用域</p><ul><li><code>localStorage</code>：文档源限制、同源策略限制</li><li><code>sessionStorage</code>：文档源限制、同源策略限制、窗口</li></ul></li><li><p>特点：</p><ul><li>存储量限制 ( <code>5M</code> )</li><li>客户端完成，不会请求服务器处理</li><li><code>sessionStorage</code>数据是不共享、 <code>localStorage</code>共享</li></ul></li><li><p><strong>API</strong></p><ul><li><code>setItem(name,val)</code>：设置数据，(<code>key</code>,<code>value</code>)类型，类型都是字符串，可以用获取属性的形式操作</li><li><code>getItem(name)</code>：获取数据，通过<code>key</code>来获取到相应的<code>value</code></li><li><code>removeItem(name)</code>：删除数据，通过key来删除相应的<code>value</code></li><li><code>clear()</code>：删除全部存储的值</li></ul></li><li><p>存储事件</p><ul><li>当数据有修改或者删除的情况下就会触发<code>storage</code>事件</li><li>在对数据进行改变的窗口对象上是不会触发的</li><li><code>Key</code>：修改或删除的<code>key</code>值，如果调用<code>clear(),key()为null</code></li><li><code>newValue</code>  :  新设置的值，如果调用<code>removeStorage()</code>,<code>key</code>为<code>null</code></li><li><code>oldValue</code> :  调用改变前的<code>value</code>值</li><li><code>storageArea</code> : 当前的<code>storage</code>对象</li><li><code>url</code> :  触发该脚本变化的文档的<code>url</code></li><li>注：<code>session</code>同窗口才可以,例子：<code>iframe</code>操作</li></ul></li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li><p>存储信息到用户的设备上，数据量较小，<code>4k</code>左右</p></li><li><p><code>navigator.cookieEnabled</code>：检测是否启用了<code>cookie</code></p></li><li><p>设置<strong>cookie</strong>值</p><ul><li><code>document.cookie = &quot;name=aimee&quot;</code></li><li>每次只能设置一个值，因为浏览器会认为后面的键值对是这个<code>cookie</code>的属性</li></ul></li><li><p>获得<strong>cookie</strong>值</p><ul><li><code>document.cookie</code></li><li>不建议出现分号，逗号，空格的奇怪符号</li></ul></li><li><p>设置<strong>cookie</strong>存储期限</p><ul><li><code>document.cookie = &#39;name=scott;max-age=1000&#39;</code></li></ul></li><li><p><strong>expires</strong>：当前时间加上保存时间</p><ul><li>```js<br>var timestamp = (new Date()).getTime() + 10000;<br>var expires = new Date(timestamp).toGMTString();<br>document.cookie = “name=scott;expires=“+expires;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 删除**cookie**</span><br><span class="line"></span><br><span class="line">  - 需要带上键值对，`max-age=0`</span><br><span class="line">  - `document.cookie = &#x27;name=scott;max-age=0&#x27;`</span><br><span class="line"></span><br><span class="line">- **domain**：跨域，设置相同的域</span><br><span class="line"></span><br><span class="line">- **path**：路径</span><br><span class="line"></span><br><span class="line">- ![](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111702969.png)</span><br><span class="line"></span><br><span class="line">- `encodeURIComponent()`：函数可把字符串作为 `URI` 组件进行编码。</span><br><span class="line"></span><br><span class="line">- `decodeURIComponent()`：函数可对 `encodeURIComponent()` 函数编码的 `URI` 进行解码。</span><br><span class="line"></span><br><span class="line">## 地位位置信息、重力感应、方向感应</span><br><span class="line"></span><br><span class="line">### geolocation（地理位置信息）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&gt; **geolocation**：获取地理位置信息</span><br><span class="line"></span><br><span class="line">- 经度  :   南北极的连接线</span><br><span class="line">- 纬度  :   东西连接的线</span><br><span class="line">- 位置信息从何而来</span><br><span class="line">    - `IP`地址</span><br><span class="line">    - `GPS`全球定位系统</span><br><span class="line">    - `Wi-Fi`无线网络</span><br><span class="line">    - 基站</span><br><span class="line"></span><br><span class="line">- https://dev.w3.org/geo/api/spec-source.html#position_error_interface</span><br><span class="line">- `window.navigator.geolocation`：`navigator`对象下面的属性</span><br><span class="line">  - ![](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111702834.png)</span><br><span class="line"></span><br><span class="line">#### getCurrentPosition</span><br><span class="line"></span><br><span class="line">&gt; getCurrentPosition(success,error,options)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 获取当前的位置信息</span><br><span class="line"></span><br><span class="line">- `success`：获取成功的回调函数（必须）</span><br><span class="line"></span><br><span class="line">- `error`：失败的回调函数</span><br><span class="line"></span><br><span class="line">- `options`：一些参数，来辅助</span><br><span class="line"></span><br><span class="line">  - `enableHighAccuracy`：是否需要高精度位置，默认`false`,`true/false`</span><br><span class="line">  - `timeout`：请求超时的时间，单位`ms`，默认`infinity`</span><br><span class="line">  - `maximumAge`：单位`ms`，`watchPosition`方法不停的取用户的地理位置信息，不停的更新用户的地理位置信息，位置信息过期时间设置为`0`就是无条件获取新的地理位置信息，默认为`0`</span><br><span class="line"></span><br><span class="line">- 需要翻墙才可以使用</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  例：</span><br><span class="line">  //pos就是地理位置信息</span><br><span class="line">  //成功的回调函数</span><br><span class="line">  function suc(pos) &#123;</span><br><span class="line">      console.log(pos);</span><br><span class="line">  &#125;</span><br><span class="line">  //失败的回调函数</span><br><span class="line">  function err(err) &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  //options参数</span><br><span class="line">  var options = &#123;</span><br><span class="line">      enableHighAccuracy: true,</span><br><span class="line">      timeout: 2000,</span><br><span class="line">      maximumAge: 300000 //五分钟</span><br><span class="line">  &#125;</span><br><span class="line">  window.navigator.geolocation.getCurrentPosition(suc,err)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>成功和失败返回回来的值</p><ul><li>成功之后返回回来的地理位置信息(<code>GeolocationPosition</code>)<ul><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111702482.png"></li><li>经度 :  <code>coords.longitude</code></li><li>纬度 :  <code>coords.latitude</code></li><li>准确度 :  <code>coords.accuracy</code></li><li>海拔 : <code> coords.altitude</code></li><li>海拔准确度 :  <code>coords.altitudeAcuracy</code></li><li>行进方向 :  <code>coords.heading</code></li><li>地面速度 :  <code>coords.speed</code></li><li>请求的时间: <code>new Date(position.timestamp)</code></li></ul></li><li>失败之后返回回来的值(<code>PositionError</code>)<ul><li>用户拒绝：<code>code=1</code></li><li>获取不到：<code>code=2</code></li><li>连接超时：<code>code=3</code>，一般测试不出来，可以设置<code>timeout</code></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111702571.png" alt="用户拒绝"></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111702730.png" alt="获取不到"></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111703276.png"></li></ul></li></ul></li></ul><h4 id="watchPosition-clearWatch"><a href="#watchPosition-clearWatch" class="headerlink" title="watchPosition/clearWatch"></a>watchPosition/clearWatch</h4><blockquote><p>watchPosition(fn)</p><p>用于注册监听器，在设备的地理位置发生改变的时候自动被调用</p><blockquote><p>参数与getCurrentPosition相同</p></blockquote></blockquote><ul><li><strong>watchPosition</strong><ul><li><code>success</code>：获取成功的回调函数（必须）</li><li><code>error</code>：失败的回调函数</li><li><code>options</code>：一些参数，来辅助<ul><li><code>enableHighAccuracy</code>：是否需要高精度位置，默认<code>false</code>,<code>true/false</code></li><li><code>timeout</code>：请求超时的时间，单位<code>ms</code>，默认<code>infinity</code></li><li><code>maximumAge</code>：单位<code>ms</code>，<code>watchPosition</code>方法不停的取用户的地理位置信息，不停的更新用户的地理位置信息，位置信息过期时间设置为<code>0</code>就是无条件获取新的地理位置信息，默认为<code>0</code></li></ul></li></ul></li><li>**clearWatch(id)**：清除<code>watchPosition</code>监听</li></ul><ul><li><strong>examp01</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;请求位置信息&lt;/button&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;经度：&quot;</span>+position.coords.longitude + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;纬度：&quot;</span>+position.coords.latitude + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;海拔：&quot;</span>+position.coords.accuracy + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;海拔的准确度：&quot;</span>+position.coords.altitudeAccuracy + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;地面速度&quot;</span>+position.coords.speed + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;行进方向&quot;</span>+position.coords.heading + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;请求时间&quot;</span>+<span class="keyword">new</span> <span class="built_in">Date</span>(position.timestamp) + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">alert(err.code);</span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="attr">enableHighAccuracy</span>:<span class="literal">false</span>,<span class="comment">//精确请求</span></span><br><span class="line"><span class="attr">timeout</span>:<span class="number">5000</span>,<span class="comment">//设置超时</span></span><br><span class="line"><span class="attr">maximumAge</span>:<span class="number">1000</span><span class="comment">//缓存时间</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/poetries/pen/RKPWMg">在线演示</a></p><ul><li>**examp02 **</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">navigator.geolocation.watchPosition(<span class="function"><span class="keyword">function</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;经度：&quot;</span>+position.coords.longitude + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;纬度：&quot;</span>+position.coords.latitude + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;海拔：&quot;</span>+position.coords.accuracy + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;海拔的准确度：&quot;</span>+position.coords.altitudeAccuracy + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;地面速度&quot;</span>+position.coords.speed + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;行进方向&quot;</span>+position.coords.heading + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">box.innerHTML +=<span class="string">&quot;请求时间&quot;</span>+<span class="keyword">new</span> <span class="built_in">Date</span>(position.timestamp) + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">alert(err.code);</span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="attr">enableHighAccuracy</span>:<span class="literal">false</span>,<span class="comment">//精确请求</span></span><br><span class="line"><span class="attr">timeout</span>:<span class="number">5000</span>,<span class="comment">//设置超时</span></span><br><span class="line"><span class="attr">maximumAge</span>:<span class="number">1000</span><span class="comment">//缓存时间</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/poetries/pen/zNGvjY">在线演示</a></p><ul><li><strong>example03 高德地图应用</strong></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">    width:600px; </span><br><span class="line">    height: 300px;</span><br><span class="line">    margin:40px auto;</span><br><span class="line">    border:1px solid red;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">&quot;http://webapi.amap.com/maps?v=1.3&amp;key=278b7b8b4728ba302b7e566fc2a97b36&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">&#x27;container&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/poetries/pen/qRdOKZ">在线演示</a></p><ul><li><strong>examp04  搜索城市</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;<span class="attribute">width</span>:<span class="number">500px</span>; <span class="attribute">height</span>:<span class="number">500px</span>; <span class="attribute">margin</span>:<span class="number">100px</span> auto;&#125;  </span><br><span class="line"><span class="selector-class">.menu</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">margin</span>:auto;</span><br><span class="line"><span class="attribute">background</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line"><span class="attribute">list-style</span>:none;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">30px</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">cursor</span>:pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">40px</span>;</span><br><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">150px</span>;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin-left</span>:-<span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>&#123;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">38px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"><span class="attribute">border</span>:none;</span><br><span class="line"><span class="attribute">outline</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#btn</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;container&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt; </span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;box&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">input</span> type=&quot;text&quot; id=&quot;city&quot; placeholder=&quot;请输入城市...&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">input</span> type=&quot;<span class="selector-tag">button</span>&quot; value=&quot;搜索&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; </span><br><span class="line"><span class="attribute">src</span>=&quot;http://webapi.amap.com/maps?v=<span class="number">1.3</span>&amp;key=<span class="number">278</span>b7b8b4728ba302b7e566fc2a97b36<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var btn = document.getElementById(&quot;</span>btn<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    var city = document.getElementById(&quot;</span>city<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    var map = new AMap.Map(&#x27;container&#x27;);</span></span><br><span class="line"><span class="string">    var toolBar,mouseTool,contextMenu;</span></span><br><span class="line"><span class="string">    //在地图中添加操作toolBar插件、mouseTool插件</span></span><br><span class="line"><span class="string">    map.plugin([&quot;</span>AMap.ToolBar<span class="string">&quot;,&quot;</span>AMap.MouseTool<span class="string">&quot;],function()&#123;</span></span><br><span class="line"><span class="string">        toolBar = new AMap.ToolBar();</span></span><br><span class="line"><span class="string">        map.addControl(toolBar);</span></span><br><span class="line"><span class="string">        mouseTool = new AMap.MouseTool(map);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    var menuContext = document.createElement(&quot;</span>div<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    menuContext.innerHTML = &quot;</span>&lt;div class=menu&gt;&lt;ul&gt;&lt;li onclick=<span class="string">&#x27;zoomMenu(0)&#x27;</span>&gt;缩小&lt;/li&gt;</span><br><span class="line">    &lt;li onclick=<span class="string">&#x27;zoomMenu(1)&#x27;</span>&gt;放大&lt;/li&gt;</span><br><span class="line">    &lt;li onclick=<span class="string">&#x27;distanceMeasureMenu()&#x27;</span>&gt;距离量测&lt;/li&gt;</span><br><span class="line">    &lt;li onclick = <span class="string">&#x27;addMarkerMenu()&#x27;</span>&gt;添加标记&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    //创建一个自定义的右键菜单</span></span><br><span class="line"><span class="string">    contextMenu = new AMap.ContextMenu(&#123;isCustom:true,content:menuContext&#125;);</span></span><br><span class="line"><span class="string">    //给地图绑鼠标右键功能弹出右键菜单</span></span><br><span class="line"><span class="string">    AMap.event.addListener(map,&quot;</span>rightclick<span class="string">&quot;,function(e)&#123;</span></span><br><span class="line"><span class="string">        contextMenu.open(map,e.lnglat);//e.lnglat鼠标点击的经纬度</span></span><br><span class="line"><span class="string">        contextMenuPosition = e.lnglat;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    //右键菜单缩放地图</span></span><br><span class="line"><span class="string">    function zoomMenu(n)&#123;</span></span><br><span class="line"><span class="string">        if(n === 0)&#123;map.zoomOut();&#125;</span></span><br><span class="line"><span class="string">        if(n === 1)&#123;map.zoomIn();&#125;</span></span><br><span class="line"><span class="string">        contextMenu.close();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    contextMenu.close();</span></span><br><span class="line"><span class="string">    //测量距离功能</span></span><br><span class="line"><span class="string">    function distanceMeasureMenu()&#123;</span></span><br><span class="line"><span class="string">        mouseTool.rule();</span></span><br><span class="line"><span class="string">        contextMenu.close();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    //添加标注功能</span></span><br><span class="line"><span class="string">    function addMarkerMenu()&#123;</span></span><br><span class="line"><span class="string">        mouseTool.close();</span></span><br><span class="line"><span class="string">        var marker = new AMap.Marker(&#123;</span></span><br><span class="line"><span class="string">            map: map,</span></span><br><span class="line"><span class="string">            position: contextMenuPosition, //基点位置</span></span><br><span class="line"><span class="string">            offset: &#123;x:-5,y:-10&#125; //相对于基点位置</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        contextMenu.close();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    //搜索城市</span></span><br><span class="line"><span class="string">    btn.onclick = function()&#123;</span></span><br><span class="line"><span class="string">        var val = city.value;</span></span><br><span class="line"><span class="string">        map.setCity(val);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/poetries/pen/xgGwaZ">在线演示</a></p><h3 id="devicemotion（监听加速度变化）"><a href="#devicemotion（监听加速度变化）" class="headerlink" title="devicemotion（监听加速度变化）"></a>devicemotion（监听加速度变化）</h3><blockquote><p><strong>devicemotion</strong>：监听加速度变化，当你的设备疯狂摇摆时，可以监听到是加速还是在减速，需要陀螺仪支持</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;devicemotion&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>包含的属性</p><ul><li><code>accelerationIncludingGravity</code>：包括重心引力，<code>z</code>轴方向加了<code>9.8</code>，再<code>x,y</code>方向上的值两者相同，重力加速度</li><li><code>acceleration</code>：重力加速度（需要陀螺仪支持）</li><li><code>rotationRate(alpha,beta,gamma)</code>：旋转速率</li><li><code>interval</code>：获取的时间间隔</li><li>注意：都是只读属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重力感应</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;devicemotion&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    item.innerHTML = e.accelerationIncludingGravity.x + <span class="string">&#x27;-&#x27;</span> +e.accelerationIncludingGravity.y + <span class="string">&#x27;-&#x27;</span> + e.accelerationIncludingGravity.z;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">微信摇一摇</span><br><span class="line"><span class="keyword">var</span> SHAKE_THRESHOLD = <span class="number">800</span>; <span class="comment">//基准值800</span></span><br><span class="line">        <span class="keyword">var</span> last_update = <span class="number">0</span>; <span class="comment">//上一次更新的时间为0</span></span><br><span class="line"><span class="comment">//当前x,y,z和上一次的x,y,z</span></span><br><span class="line">        <span class="keyword">var</span> x, y, z, last_x=<span class="number">0</span>, last_y=<span class="number">0</span>, last_z=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">deviceMotionHeadler</span>(<span class="params">eventData</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 加速度</span></span><br><span class="line">            <span class="keyword">var</span> acceleration = eventData.accelerationIncludingGravity;</span><br><span class="line">            <span class="comment">//时间戳</span></span><br><span class="line">            <span class="keyword">var</span> curTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            <span class="comment">//300毫秒判断一次，300毫秒执行一次</span></span><br><span class="line">            <span class="keyword">if</span>((curTime - last_update) &gt; <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> diffTime = curTime - last_update;</span><br><span class="line">                last_update = curTime;</span><br><span class="line">                x = acceleration.x;</span><br><span class="line">                y = acceleration.y;</span><br><span class="line">                z = acceleration.z;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">var</span> speed = <span class="built_in">Math</span>.abs(x + y + z - last_x - last_y - last_z) / diffTime * <span class="number">10000</span>;</span><br><span class="line">                <span class="keyword">if</span>(speed &gt; SHAKE_THRESHOLD) &#123;</span><br><span class="line">                    alert(<span class="string">&#x27;shaked~!&#x27;</span>);</span><br><span class="line">                    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">                    div.innerText = <span class="string">&#x27;11&#x27;</span>;</span><br><span class="line">                    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">                &#125;</span><br><span class="line">                last_x = x;</span><br><span class="line">                last_y = y;</span><br><span class="line">                last_z = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//监听加速度的变化，当加速度变化时，执行deviceMotionHeadler函数</span></span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;devicemotion&#x27;</span>, deviceMotionHeadler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="deviceorientation（监听方向变化）"><a href="#deviceorientation（监听方向变化）" class="headerlink" title="deviceorientation（监听方向变化）"></a>deviceorientation（监听方向变化）</h3><blockquote><p>deviceorientation：监听设备在方向上的变化</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(deviceorientation,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>包含的属性</p><ul><li><code>alpha</code>：表示设备沿z轴上的旋转角度，范围为<code>0~360</code></li><li><code>beta</code>表示设备再X轴上的旋转角度，范围为<code>-180~180</code>。它描述的是设备由前向后旋转的情况</li><li><code>gamma</code>表示设备在<code>y</code>轴上的旋转角度，范围为<code>-90~90</code>。它描述的是设备由左向右旋转的情况</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111704446.png"></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>旋转：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;alpha&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>前后：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;beta&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>扭转：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;gamma&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">DeviceOrientationHandler</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> alpha = event.alpha,</span></span><br><span class="line"><span class="javascript">            beta = event.beta,</span></span><br><span class="line"><span class="javascript">            gamma = event.gamma,</span></span><br><span class="line"><span class="javascript">            webkitCompassHeading = event.webkitCompassHeading;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(alpha != <span class="literal">null</span> || beta != <span class="literal">null</span> || gamma != <span class="literal">null</span>)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//判断屏幕方向</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> html = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>( gamma &gt; <span class="number">0</span> )&#123;</span></span><br><span class="line"><span class="javascript">                html = <span class="string">&quot;向右倾斜&quot;</span> + gamma;</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                html = <span class="string">&quot;向左倾斜&quot;</span> + gamma;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;gamma&quot;</span>).innerHTML = html;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>( beta &gt; <span class="number">0</span> )&#123;</span></span><br><span class="line"><span class="javascript">                str = <span class="string">&quot;向前倾斜&quot;</span> + beta;</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                str = <span class="string">&quot;向后倾斜&quot;</span> + beta;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> head = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> headNum = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.round(webkitCompassHeading/<span class="number">45</span>) + <span class="number">7</span>)%<span class="number">8</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (headNum) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">0</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;东北&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">1</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;东&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">2</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;东南&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">3</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;南&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">4</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;西南&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">5</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;西&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">6</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;西北&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">7</span>:</span></span><br><span class="line"><span class="javascript">                    head = <span class="string">&#x27;北&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;beta&quot;</span>).innerHTML = str;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;alpha&quot;</span>).innerHTML = alpha;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;heading&#x27;</span>).innerHTML = head + <span class="string">&#x27;   &#x27;</span> + webkitCompassHeading;</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.innerHTML = <span class="string">&quot;当前浏览器不支持DeviceOrientation&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//判断有没有这个事件，如果有的话才监听</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">window</span>.DeviceOrientationEvent)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;deviceorientation&#x27;</span>,DeviceOrientationHandler, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;您的浏览器不支持DeviceOrientation&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>webkitCompassHeading</code>：与正北方向的角度差值。正北为<code>0</code>度，正东为<code>90</code>度，正南为<code>180</code>度，正西为<code>270</code>度。因为<code>0</code>度是正北，所以叫指北针。</p></li><li><p><code>webkitCompassAccuracy</code>：指北针的精确度，表示偏差为正负多少度。一般是<code>10</code>。</p></li></ul><h2 id="动画函数、历史记录、线程管理"><a href="#动画函数、历史记录、线程管理" class="headerlink" title="动画函数、历史记录、线程管理"></a>动画函数、历史记录、线程管理</h2><h3 id="requestAnimationFrame-动画函数"><a href="#requestAnimationFrame-动画函数" class="headerlink" title="requestAnimationFrame(动画函数)"></a>requestAnimationFrame(动画函数)</h3><blockquote><p>实现动画的API，让浏览器更加流畅的实现动画</p></blockquote><ul><li><p>由于<code>JavaScript</code>是单线程的，所以定时器的实现是在当前任务队列完成后再执行定时器的回调的，假如当前队列任务执行时间大于定时器设置的延迟时间，那么定时器就不是那么可靠了</p></li><li><p>动画是由浏览器按照一定的频率一帧一帧的绘制的，由<code>css</code>实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新<code>UI</code>，给用户一种流畅的体验，而<code>setInterval</code>或<code>setTimeout</code>实现的<code>JavaScript</code>动画就没有这么可靠了，因为浏览器压根就无法保证每一帧渲染的时间间隔，一般情况下，每秒平均刷新次数能够达到60帧，就能够给人流畅的体验，即每过 <code>1000/60</code> 毫秒渲染新一帧即可，这一点单靠定时器是无法保证的。 为此，<code>requestAnimationFrame</code>应运而生，其作用就是让浏览器流畅的执行动画效果。可以将其理解为专门用来实现动画效果的<code>api</code>，通过这个<code>api</code>,可以告诉浏览器某个<code>JavaScript</code>代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。</p></li><li><p>大多数电脑显示器的刷新频率是<code>60Hz</code>，大概相当于每秒钟重绘<code>60</code>次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是<code>1000ms/60</code>，约等于<code>16.7ms</code>，所以屏幕一般<code>16.7ms</code>才会刷新一次</p></li><li><p>特点</p><ul><li><code>requestAnimationFrame</code>会把每一帧中的所有<code>DOM</code>操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，在隐藏或不可见的元素中，<code>requestAnimationFrame</code>将不会进行重绘或回流，这当然就意味着更少的<code>CPU</code>、<code>GPU</code>和内存使用量</li><li><code>requestAnimationFrame</code>是由浏览器专门为动画提供的<code>API</code>，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了<code>CPU</code>开销</li><li><code>requestAnimationFrame</code>会在浏览器每次刷新前执行，因为屏幕刷新率一般是<code>16.7ms</code>，所以一般<code>16.7ms</code>执行一次</li><li><code>requestAnimationFrame</code>的用法与<code>setTimeout</code>很相似，只是不需要设置时间间隔而已。<code>requestAnimationFrame</code>使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。它返回一个整数，表示定时器的编号，这个值可以传递给<code>cancelAnimationFrame</code>用于取消这个函数的执行。</li><li>兼容性存在问题，因为是<code>HTML5</code>新提供的<code>API</code>，只可以在<code>IE10</code>以上的浏览器</li></ul></li><li><p><code>requestAnimationFrame</code>：设置动画</p></li><li><p><code>canvelAnimationFrame</code>：取消动画</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单兼容</span></span><br><span class="line"><span class="comment">//设置AnimationFrame</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame || </span><br><span class="line">        <span class="built_in">window</span>.webkitRequestAnimationFrame || </span><br><span class="line">        <span class="built_in">window</span>.mozRequestAnimationFrame || </span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(callback,<span class="number">1000</span>/<span class="number">60</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消AnimationFrame</span></span><br><span class="line"><span class="built_in">window</span>.cancelAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.cancelAnimationFrame ||</span><br><span class="line">        <span class="built_in">window</span>.webkitCancelAnimationFrame ||</span><br><span class="line">        <span class="built_in">window</span>.mozCancelAnimationFrame ||</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.clearTimeout(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完美兼容</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> vendors = [<span class="string">&#x27;webkit&#x27;</span>, <span class="string">&#x27;moz&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x) &#123;</span><br><span class="line">            <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">&#x27;RequestAnimationFrame&#x27;</span>];</span><br><span class="line">            <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">&#x27;CancelAnimationFrame&#x27;</span>] ||    <span class="comment">// Webkit中此取消方法的名字变了</span></span><br><span class="line">                                          <span class="built_in">window</span>[vendors[x] + <span class="string">&#x27;CancelRequestAnimationFrame&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">window</span>.requestAnimationFrame) &#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16.7</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                callback(currTime + timeToCall);</span><br><span class="line">            &#125;, timeToCall);</span><br><span class="line">            lastTime = currTime + timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(id);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;btn&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//requestAnimationFrame兼容函数</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame || </span><br><span class="line">        <span class="built_in">window</span>.webkitRequestAnimationFrame || </span><br><span class="line">        <span class="built_in">window</span>.mozRequestionAnimationFrame || </span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(callback,<span class="number">1000</span>/<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//cancelAnimationFrame兼容函数</span></span><br><span class="line"><span class="built_in">window</span>.cancelAnimationFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.cancelAnimationFrame ||</span><br><span class="line">        <span class="built_in">window</span>.webkitCancelAnimationFrame || </span><br><span class="line">        <span class="built_in">window</span>.mozCancelAnimationFrame || </span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.clearTimeout(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req; <span class="comment">//标识</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    btn.style.left = btn.offsetLeft + <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(btn.offsetLeft &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="comment">// clearTimeout(timer);</span></span><br><span class="line">        cancelAnimationFrame(req);</span><br><span class="line">        btn.style.left = <span class="string">&#x27;300px&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// req = setTimeout(function() &#123;</span></span><br><span class="line">        <span class="comment">// move();</span></span><br><span class="line">        <span class="comment">// &#125;,10)</span></span><br><span class="line">        req = requestAnimationFrame(move);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">move();</span><br></pre></td></tr></table></figure><h3 id="history-历史记录"><a href="#history-历史记录" class="headerlink" title="history(历史记录)"></a>history(历史记录)</h3><ul><li><p>属性</p><ul><li><code>history.length()</code>：返回浏览器当前标签页历史列表中的 <code>URL</code> 数量</li><li><code>history.back()</code>：加载浏览器当前标签页<code>history</code> 列表中的前一个 <code>URL</code></li><li><code>history.forward()</code>：加载浏览器当前标签页<code>history</code> 列表中的下一个 <code>URL</code></li><li><code>history.go()</code>：加载 history 列表中的某个具体页面,例如 <code>history.go(-2)</code></li></ul></li><li><p>为什么要管理历史记录</p><ul><li>为了给用户更方便的操作，更方便回退</li></ul></li><li><p><code>history api</code>的作用，为了我们更方便管理历史记录，不用非要用户点击操作</p></li><li><p><strong>SPA</strong>：单页面应用</p></li><li><p>修改事件实现历史记录管理</p><ul><li><code>pushState</code><ul><li><code>history.pushState(state,title,url);</code> 添加一条历史记录</li></ul></li><li><code>repalceState</code><ul><li><code>history.replaceState(state,title,url)</code>：替换当前的历史记录</li></ul></li><li>参数：<ul><li><code>state</code>：一个与指定网址相关的状态对象，<code>popstate</code>事件触发时，该对象会传入回调函数中，如果不需要这个对象，可以填<code>null</code></li><li><code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填<code>null</code></li><li><code>url</code>：新的网址，必须与当前页面处在同一个域，浏览器的地址栏将显示在这个网址</li></ul></li></ul></li><li><p>事件</p><ul><li><code>popstate</code>：历史记录发生改变时触发<ul><li>调用<code>history.pushState()或者history.replaceState()不会触发popstate事件</code></li></ul></li><li><code>hashchange</code>：当页面的<code>hash</code>值改变的时候触发，常用于构建单页面应用</li></ul></li></ul><h3 id="worker-线程管理"><a href="#worker-线程管理" class="headerlink" title="worker(线程管理)"></a>worker(线程管理)</h3><ul><li><p>简介</p><ul><li><code>Web Worker</code> (工作线程) 是 <code>HTML5</code> 中提出的概念，分为两种类型，专用线程（<code>Dedicated Web Worker</code>） 和共享线程（<code>Shared Web Worker</code>）。专用线程仅能被创建它的脚本所使用（一个专用线程对应一个主线程），而共享线程能够在不同的脚本中使用（一个共享线程对应多个主线程）。</li><li>专用线程可以看做是默认情况的 <code>Web Worker</code>，其加上修饰词的目的是为了与共享线程进行区分。本文会较为严格地区分两者，可能较为累赘，但个人认为这是必要的。如果单纯以 <code>Web Worker</code> 字样出现的地方指的是两者都会有的情况。</li></ul></li><li><p>用途</p><ul><li><code>Web Worker</code> 的意义在于可以将一些耗时的数据处理操作从主线程中剥离，使主线程更加专注于页面渲染和交互。</li><li>懒加载</li><li>文本分析</li><li>流媒体数据处理</li><li><code>canvas</code> 图形绘制</li><li>图像处理</li><li>…</li></ul></li><li><p>需要注意的点</p><ul><li>有同源限制</li><li>无法访问 <code>DOM</code> 节点</li><li>运行在另一个上下文中，无法使用<code>Window</code>对象</li><li><code>Web Worker</code> 的运行不会影响主线程，但与主线程交互时仍受到主线程单线程的瓶颈制约。换言之，如果 Worker 线程频繁与主线程进行交互，主线程由于需要处理交互，仍有可能使页面发生阻塞</li><li>共享线程可以被多个浏览上下文（<code>Browsing context</code>）调用，但所有这些浏览上下文必须同源（相同的协议，主机和端口号）</li></ul></li><li><p>浏览器支持度</p><ul><li>根据 <code>CanI Use</code> 网站的统计，目前约有 <code>93.05%</code> 的浏览器支持专用线程。</li></ul></li><li><p>线程创建</p><ul><li><p>值得注意的是，因为 <code>Web Worker</code> 有同源策略限制，所以在本地调试的时候也需要通过启动本地服务器的方式访问，使用 <code>file://</code> 协议直接打开的话将会抛出异常。</p></li><li><p>专用线程</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//专用线程由 Worker()方法创建，可以接收两个参数，第一个参数是必填的脚本的位置，第二个参数是可选的配置对象，可以指定 type、credentials、name 三个属性。</span></span><br><span class="line"></span><br><span class="line">专用线程</span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>)<span class="comment">//worker.js是自己的js文件</span></span><br><span class="line"><span class="comment">// var worker = new Worker(&#x27;worker.js&#x27;, &#123; name: &#x27;dedicatedWorker&#x27;&#125;)</span></span><br></pre></td></tr></table></figure><ul><li>共享线程</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共享线程使用 Shared Worker() 方法创建，同样支持两个参数，用法与 Worker() 一致。</span></span><br><span class="line"><span class="keyword">var</span> sharedWorker = <span class="keyword">new</span> SharedWorker(<span class="string">&#x27;shared-worker.js&#x27;</span>)<span class="comment">//shared-worker.js是自己的js文件</span></span><br></pre></td></tr></table></figure><ul><li><p>数据传递</p><ul><li><p><strong>postMessage</strong>()：发送消息事件</p></li><li><p><strong>onmessage</strong>：接收消息事件</p></li><li><p><code>Worker</code> 线程和主线程都通过 <code>postMessage()</code> 方法发送消息，通过 <code>onmessage</code> 事件接收消息。在这个过程中数据并不是被共享的，而是被复制的。值得注意的是 <code>Error</code> 和 <code>Function</code> 对象不能被结构化克隆算法复制，如果尝试这么做的话会导致抛出 <code>DATA_CLONE_ERR</code> 的异常。另外，<code>postMessage()</code> 一次只能发送一个对象， 如果需要发送多个参数可以将参数包装为数组或对象再进行传递。</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="comment">//创建一个worker</span></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>)</span><br><span class="line"><span class="comment">//worker postMessage</span></span><br><span class="line">worker.postMessage(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//给worker绑定message事件</span></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker.js 线程</span></span><br><span class="line"><span class="comment">//绑定onmessage事件</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">    <span class="comment">//向主线程发送数据</span></span><br><span class="line">    postMessage(deal(e.data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deal</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>Worker</code> 线程中，<code>self</code> 和 <code>this</code> 都代表子线程的全局对象。对于监听 message 事件，以下的四种写法是等同的。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法 1</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 2</span></span><br><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 3</span></span><br><span class="line">addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 4</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主线程通过 <code>MessagePort</code> 访问专用线程和共享线程。专用线程的 <code>port</code> 会在线程创建时自动设置，并且不会暴露出来。与专用线程不同的是，共享线程在传递消息之前，端口必须处于打开状态。<code>MDN</code> 上的 <code>MessagePort</code> 关于 <code>start()</code> 方法的描述是：</p><ul><li><blockquote><p>Starts the sending of messages queued on the port (only needed when using EventTarget.addEventListener; it is implied when using MessagePort.onmessage.)</p><p>开始发送在端口上排队的消息（仅在使用EventTarget.addEventListener时需要）；当使用MessagePort.onmessage时，它是隐含的。）</p></blockquote></li><li><p>这句话经过试验，可以理解为 <code>start()</code> 方法是与 <code>addEventListener</code> 配套使用的。如果我们选择 <code>onmessage</code> 进行事件监听，那么将隐含调用 <code>start()</code> 方法。</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> sharedWorker = <span class="keyword">new</span> SharedWorker(<span class="string">&#x27;shared-worker.js&#x27;</span>)</span><br><span class="line">sharedWorker.port.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sharedWorker = <span class="keyword">new</span> SharedWorker(<span class="string">&#x27;shared-worker.js&#x27;</span>)</span><br><span class="line">sharedWorker.port.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">sharedWorker.port.start() <span class="comment">// 需要显式打开</span></span><br></pre></td></tr></table></figure><ul><li>在传递消息时，<code>postMessage()</code> 方法和 <code>onmessage</code> 事件必须通过端口对象调用。另外，在 <code>Worker</code> 线程中，需要使用 <code>onconnect</code> 事件监听端口的变化，并使用端口的消息处理函数进行响应。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">sharedWorker.port.postMessage([<span class="number">10</span>, <span class="number">24</span>])</span><br><span class="line">sharedWorker.port.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">onconnect = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> port = e.ports[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    port.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.data.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            port.postMessage(e.data[<span class="number">1</span>] - e.data[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关闭 <strong>Worker</strong></p><ul><li>**close()**：在<code>worker</code>作用域中调用，自己关闭</li><li>**terminate()**：在<code>worker</code>对象上调用(主进程的<code>worker</code>对象上<code>worker.terminate</code>)，上级关闭<code>worker</code></li><li>可以在主线程中使用 <code>terminate()</code> 方法或在 <code>Worker</code> 线程中使用 <code>close()</code> 方法关闭 <code>worker</code>。这两种方法是等效的，但比较推荐的用法是使用 <code>close()</code>，防止意外关闭正在运行的 <code>Worker</code> 线程。<code>Worker</code> 线程一旦关闭 <code>Worker</code> 后 <code>Worker</code> 将不再响应。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">worker.terminate()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dedicated Worker 线程中</span></span><br><span class="line">self.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shared Worker 线程中</span></span><br><span class="line">self.port.close()</span><br></pre></td></tr></table></figure><ul><li><p>错误处理</p><ul><li>可以通过在主线程或 <code>Worker</code> 线程中设置 <code>onerror</code> 和 <code>onmessageerror</code> 的回调函数对错误进行处理。其中，<code>onerror</code> 在 <code>Worker</code> 的 <code>error</code> 事件触发并冒泡时执行，<code>onmessageerror</code> 在 <code>Worker</code> 收到的消息不能进行反序列化时触发(本人经过尝试没有办法触发 <code>onmessageerror</code> 事件，如果在 <code>worker</code> 线程使用 <code>postMessage</code> 方法传递一个 Error 或 Function 对象会因为无法序列化优先被 <code>onerror</code> 方法捕获，而根本不会进入反序列化的过程)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">worker.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程使用专用线程</span></span><br><span class="line">worker.onmessageerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程使用共享线程</span></span><br><span class="line">worker.port.onmessageerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker 线程</span></span><br><span class="line">onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>加载外部脚本</p><ul><li><p> <code>importScripts()</code> ：能够将外部脚本文件加载到 <code>Worker</code> 中</p></li><li><p><code>worker</code>只是<code>window</code>的子集，只能实现部分功能，不能获取到<code>window</code>，<code>documennt</code>，所以这里不要引入<code>jquery</code>，可以引入一些计算的库</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">&#x27;script1.js&#x27;</span>)</span><br><span class="line">importScripts(<span class="string">&#x27;script2.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法等价于</span></span><br><span class="line">importScripts(<span class="string">&#x27;script1.js&#x27;</span>, <span class="string">&#x27;script2.js&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>子线程</p><ul><li><code>Worker</code> 可以生成子 <code>Worker</code>，但有两点需要注意。</li><li>子 <code>Worker</code> 必须与父网页同源</li><li>子 <code>Worker</code> 中的 <code>URI</code> 相对于父 <code>Worker</code> 所在的位置进行解析</li></ul></li><li><p>嵌入式 <strong>Worker</strong></p><ul><li>目前没有一类标签可以使 <code>Worker</code> 的代码像 <code>&lt;script&gt;</code> 元素一样嵌入网页中，但我们可以通过 <code>Blob()</code> 将页面中的 <code>Worker</code> 代码进行解析。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script id=<span class="string">&quot;worker&quot;</span> type=<span class="string">&quot;javascript/worker&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 这段代码不会被 JS 引擎直接解析，因为类型是 &#x27;javascript/worker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里写 Worker 线程的逻辑</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> workerScript = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#worker&#x27;</span>).textContent</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(workerScript, &#123;<span class="attr">type</span>: <span class="string">&quot;text/javascript&quot;</span>&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="built_in">window</span>.URL.createObjectURL(blob))</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>关于 <strong>postMessage</strong></p><ul><li><p><code>Web Worker</code> 中，<code>Worker</code> 线程和主线程之间使用结构化克隆算法（<code>The structured clone algorithm</code>）进行数据通信。结构化克隆算法是一种通过递归输入对象构建克隆的算法，算法通过保存之前访问过的引用的映射，避免无限遍历循环。这一过程可以理解为，在发送方使用类似 <code>JSON.stringfy()</code> 的方法将参数序列化，在接收方采用类似 <code>JSON.parse()</code> 的方法反序列化。</p></li><li><p>但是，一次数据传输就需要同时经过序列化和反序列化，如果数据量大的话，这个过程本身也可能造成性能问题。因此， <code>Worker</code> 中提出了 <code>Transferable Objects</code> 的概念，当数据量较大时，我们可以选择在将主线程中的数据直接移交给 <code>Worker</code> 线程。值得注意的是，这种转移是彻底的，一旦数据成功转移，主线程将不能访问该数据。这个移交的过程仍然通过 <code>postMessage</code> 进行传递。</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">postMessage(message, transferList)</span><br></pre></td></tr></table></figure><ul><li>例如，传递一个 <code>ArrayBuffer</code> 对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aBuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>)</span><br><span class="line">worker.postMessage(&#123; <span class="attr">data</span>: aBuffer &#125;, [aBuffer])</span><br></pre></td></tr></table></figure><ul><li><p>上下文，作用域</p><ul><li><code>Worker</code> 工作在一个 <code>WorkerGlobalDataScope</code> 的上下文中。每一个 <code>WorkerGlobalDataScope</code> 对象都有不同的 <code>event loop</code>。这个 <code>event loop</code> 没有关联浏览器上下文（<code>browsing context</code>），它的任务队列也只有事件（<code>events</code>）、回调（<code>callbacks</code>）和联网的活动（<code>networking activity</code>）。</li><li>每一个 <code>WorkerGlobalDataScope</code> 都有一个 closing 标志，当这个标志设为 true 时，任务队列将丢弃之后试图加入任务队列的任务，队列中已经存在的任务不受影响（除非另有指定）。同时，定时器将停止工作，所有挂起（<code>pending</code>）的后台任务将会被删除。</li></ul></li><li><p><strong>Worker</strong> 中可以使用的函数和类</p><ul><li>由于 <code>Worker</code> 工作的上下文不同于普通的浏览器上下文，因此不能访问 window 以及 window 相关的 <code>API</code>，也不能直接操作 <code>DOM</code>。<code>Worker</code> 中提供了 <code>WorkerNavigator</code> 和 <code>WorkerLocation</code> 接口，它们分别是 <code>window</code> 中 <code>Navigator</code> 和 <code>Location</code> 的子集。除此之外，<code>Worker</code> 还提供了涉及时间、存储、网络、绘图等多个种类的接口，以下列举了其中的一部分，更多的接口可以参考 <code>MDN</code> 文档。</li></ul></li><li><p>时间相关</p><ul><li><code>clearInterval()</code></li><li><code>clearTimeout()</code></li><li><code>setInterval()</code></li><li><code>setTimeout()</code></li></ul></li><li><p><strong>Worker</strong> 相关</p><ul><li><code>importScripts()</code></li><li><code>close()</code></li><li><code>postMessage()</code></li></ul></li><li><p>存储相关</p><ul><li><code>Cache</code></li><li><code>IndexedDB</code></li></ul></li><li><p>网络相关</p><ul><li><code>Fetch</code></li><li><code>WebSocket</code></li><li><code>XMLHttpRequest</code>：可以发送<code>ajax</code>对象</li></ul></li><li><p>作用域<strong>globalWorkerScope</strong></p><ul><li><code>navigator</code>：可以使用<code>navigator</code>中的一些对象</li><li>可以在<code>worker</code>文件中继续生成<code>worker</code>对象（<code>chrome</code>暂时不支持，浏览器支持情况不好）</li></ul></li></ul><h2 id="拖拽-读取文件-WebSocket"><a href="#拖拽-读取文件-WebSocket" class="headerlink" title="拖拽/ 读取文件 / WebSocket"></a>拖拽/ 读取文件 / WebSocket</h2><h3 id="drag-amp-drop（拖拽）"><a href="#drag-amp-drop（拖拽）" class="headerlink" title="drag &amp; drop（拖拽）"></a>drag &amp; drop（拖拽）</h3><ul><li><p>常用于各种拖动操作中</p></li><li><p>创建可拖动元素</p><ul><li><code>&lt;div&gt; id=&#39;drag&#39; draggable=&#39;true&#39;&gt;&lt;/div&gt;</code></li></ul></li><li><p>相关事件</p><ul><li><code>dragstart</code>：被拖拽元素，开始被拖拽时触发</li><li><code>dragend</code>：被拖拽元素，拖拽完成时触发</li><li><code>dragenter</code>：目标元素，拖拽元素进入目标元素触发</li><li><code>dragover</code>：目标元素，拖拽元素在目标元素上移动触发</li><li><code>drop</code>：目标元素，被拖拽的元素在目标元素上同时鼠标放开触发</li><li>注意：需要阻止<code>dragover</code>的默认行为才会触发<code>drop</code>事件</li></ul></li><li><p><strong>DragEvent</strong>事件对象</p><ul><li>传值<ul><li><code>e.dataTransfer.setData(&quot;data&quot;,e.target.id)</code></li></ul></li><li>取值<ul><li><code>e.dataTransfer.getData(&quot;data&quot;)</code></li></ul></li></ul></li><li><p>案例1：把元素拖入到目标元素</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#item1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#item2</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>:green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#wrapper</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>:<span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: orange;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;item1&quot;</span> <span class="attr">draggable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;item2&quot;</span> <span class="attr">draggable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//被拖拽对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oItem1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item1&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oItem2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item2&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//目标对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oWrapper = <span class="built_in">document</span>.getElementById(<span class="string">&quot;wrapper&quot;</span>);</span></span><br><span class="line"><span class="javascript">    oItem1.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        e.dataTransfer.setData(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.id);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    oItem2.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        e.dataTransfer.setData(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.id);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//阻止dragover的默认行为</span></span></span><br><span class="line"><span class="javascript">    oWrapper.addEventListener(<span class="string">&#x27;dragover&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        e.preventDefault();</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    oWrapper.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//调用PreventDefault()来避免浏览器对数据的默认处理（drop事件的默认行为是以链接形式打开）</span></span></span><br><span class="line"><span class="javascript">        e.preventDefault();</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取得到的对象，插入到目标对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = e.dataTransfer.getData(<span class="string">&#x27;data&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        oWrapper.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>案例2：拖拽插入、<a href=""><strong>删除元素</strong></a></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    *&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">ul</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">35px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>:<span class="number">#ccc</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">draggable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">draggable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">draggable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">draggable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">draggable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>),</span></span><br><span class="line"><span class="javascript">        oUl = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>],</span></span><br><span class="line"><span class="javascript">        len = oLi.length,</span></span><br><span class="line"><span class="javascript">        oWrapper = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;wrapper&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">bindLiEvent</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; len;i ++)&#123;</span></span><br><span class="line"><span class="javascript">            oLi[i].addEventListener(<span class="string">&#x27;dragstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//根据当前dom元素的顺序重新获取i值</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> index = getIndex(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//添加参数</span></span></span><br><span class="line"><span class="javascript">                e.dataTransfer.setData(<span class="string">&#x27;data&#x27;</span>,index);</span></span><br><span class="line"><span class="javascript">            &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            oLi[i].addEventListener(<span class="string">&#x27;dragover&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//取消dragover默认事件，让drop生效</span></span></span><br><span class="line"><span class="javascript">                e.preventDefault();</span></span><br><span class="line"><span class="javascript">            &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            oLi[i].addEventListener(<span class="string">&#x27;drop&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//取出参数i,把第i个元素插入到目标元素的前面</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> i = e.dataTransfer.getData(<span class="string">&#x27;data&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(i);</span></span><br><span class="line"><span class="javascript">                oUl.insertBefore(oLi[i], <span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">            &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        &#125;  </span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//查找当前这个元素拖拽的索引值</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getIndex</span>(<span class="params">dom</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(oLi[i] == dom)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> i;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    bindLiEvent();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//删除元素</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">removeLi</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        oWrapper.addEventListener(<span class="string">&#x27;dragover&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            e.preventDefault();</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        oWrapper.addEventListener(<span class="string">&#x27;drop&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> index = e.dataTransfer.getData(<span class="string">&#x27;data&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            oLi[index].remove();</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    removeLi();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>案例3，拖拽上传文件</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;wrapper&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">ele.addEventListener(<span class="string">&#x27;dragover&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">ele.addEventListener(<span class="string">&#x27;drop&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="keyword">var</span> dt = e.dataTransfer;</span><br><span class="line">    <span class="keyword">var</span> files = dt.files;</span><br><span class="line">    <span class="built_in">console</span>.log(files);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/poetries/pen/XpbEOW">在线演示</a></p><h3 id="FileReader（读取文件）"><a href="#FileReader（读取文件）" class="headerlink" title="FileReader（读取文件）"></a>FileReader（读取文件）</h3><blockquote><p>用于读取文件</p></blockquote><ul><li><p>方法：</p><ul><li><code>abort()</code>：终止读取</li><li><code>readAsBinaryString(file)</code>：将文件读取为二进制编码</li><li><code>readAsDataURL(file)</code>：将文件读取为二进制编码</li><li><code>readAsText(file,[encoding])</code>：将文件读取为文本</li><li><code>readAsArrayBuffer(file)</code>：将文件读取为<code>arraybuffer</code></li></ul></li><li><p>事件：</p><ul><li><code>loadstart</code>：读取开始时触发</li><li><code>progress</code>：读取中</li><li><code>loadend</code>： 读取中完成触发，无论成功或失败</li><li><code>load</code>：文件读取成功完成时触发</li><li><code>abort</code>：中断时触发</li><li><code>error</code>：出错时触发</li></ul></li><li><p>获取读取的结果</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h3><blockquote><p><em>WebSocket</em>对象提供了一组<em>API</em>，用于创建和管理<em>WebSocket</em>连接，以及通过连接发送和接收数据。</p><p><em>WebSocket</em>其实是一个新协议，跟<em>HTTP</em>协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，借用了<em>HTTP</em>的协议来完成握手</p><blockquote><p> <img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111704365.png"></p></blockquote></blockquote><ul><li><p>产生原因</p><ul><li>在<code>HTTP/1.0</code>中，大多实现为每个请求/响应交换使用新的连接</li><li>在<code>HTTP/1.1</code>中，一个连接可用于一次或多次请求/响应交换</li><li><code>HTTP</code>协议中，服务端不能主动联系客户端，只能有客户端发起</li><li><code>WebSocket</code>服务器和客户端均可主动发送数据</li></ul></li><li><p>建立连接的握手</p><ul><li>当<code>Web</code>应用程序调用<code>new WebSocket(url)</code>接口时，<code>Browser</code>就开始了与地址为<code>url</code>的<code>WebServer</code>建立握手链接的过程</li><li>1.<code>Browser</code>与<code>WebSocket</code>服务器通过<code>TCP</code>握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，<code>Web</code>应用程序将收到错误消息通知</li><li>2.在<code>TCP</code>建立连接成功后，<code>Browser</code>通过<code>http</code>协议传送<code>WebSocket</code>支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器</li><li>3.<code>WebSocket</code>服务器收到<code>Browser</code>发送来的请求后，如果数据包数据和格式正确，客户端和服务器端协议版本号匹配等等，就接受本次握手链接，并给出相应的数据回复，同样回复的数据也是采用<code>http</code>协议传输</li><li>4.<code>Browser</code>收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发<code>onopen</code>消息，此时<code>Web</code>开发者就可以在此时通过<code>send</code>接口向服务器发送数据。否则，握手连接失败，<code>Web</code>应用程序会受到<code>onerror</code>消息，并且能知道连接失败的原因</li></ul></li><li><p>三次握手</p><ul><li>第一次握手：建立连接时，客户端<code>A</code>发送<code>SYN</code>包<code>（SYN=j）</code>到服务器<code>B</code>，并进入<code>SYN_SEND</code>状态，等待服务器<code>B</code>确认。</li><li>第二次握手：服务器<code>B</code>收到<code>SYN</code>包，必须确认客户<code>A</code>的<code>SYN（ACK=j+1）</code>，同时自己也发送一个<code>SYN</code>包<code>（SYN=k）</code>，即<code>SYN+ACK</code>包，此时服务器B进入<code>SYN_RECV</code>状态。</li><li>第三次握手：客户端<code>A</code>收到服务器<code>B</code>的<code>SYN＋ACK</code>包，向服务器<code>B</code>发送确认包<code>ACK（ACK=k+1）</code>，此包发送完毕，客户端<code>A</code>和服务器<code>B</code>进入<code>ESTABLISHED</code>状态，完成三次握手。</li><li>完成三次握手，客户端与服务器开始传送数据</li><li><code>WebSocket</code>请求头/响应头<ul><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111704765.png" alt="请求头"></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111704159.png" alt="响应头"></li></ul></li><li><code>HTTP</code>请求头/响应头<ul><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111705946.png" alt="请求头"></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111705105.png" alt="响应头"></li></ul></li></ul></li><li><p>创建<strong>WebSocket</strong></p><ul><li><code>var Socket = new WebSocket(url);</code></li></ul></li><li><p>方法</p><ul><li><table><thead><tr><th>方法</th><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Socket.send()</code></td><td><code>send(data)</code></td><td>使用连接传输数据</td></tr><tr><td><code>Socket.close()</code></td><td><code>close()</code></td><td>用于终止任何现有连接</td></tr></tbody></table></li></ul></li><li><p>事件</p><ul><li><table><thead><tr><th>事件</th><th>事件处理程序</th><th>描述</th></tr></thead><tbody><tr><td><code>open</code></td><td><code>Socket.onopen</code></td><td>建立socket连接时触发这个事件</td></tr><tr><td><code>message</code></td><td><code>Socket.onmessage</code></td><td>客户端从服务器接收数据时触发</td></tr><tr><td><code>error</code></td><td><code>Socket.onerror</code></td><td>连接发生错误时触发</td></tr><tr><td><code>close</code></td><td><code>Socket.onclose</code></td><td>连接被关闭时触发</td></tr></tbody></table></li></ul></li><li><p><strong>WebSocket</strong>的优点</p><ul><li>客户端与服务器都可以主动传送数据给对方</li><li>不用频率创建<code>TCP</code>请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源</li></ul></li><li><p>注:<code>WebSocket.org</code>提供了一个专门用来测试<code>WebSocket</code>的服务器<code>ws://echo.websocket.org</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ws://echo.websocket.org是一个测试websocket的服务器接口，就是你发送什么，它返回什么</span></span><br><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://echo.websocket.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">Socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Socket.send(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;message&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">    Socket.close(); <span class="comment">//发送完之后需要关闭连接，否则会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;close&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML5新增JS方法"><a href="#HTML5新增JS方法" class="headerlink" title="HTML5新增JS方法"></a>HTML5新增JS方法</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111705422.png" alt="H5在JavaScript中新增的方法一览"></p><ul><li><p><strong>新增选择器</strong></p><ul><li><code>document.querySelector() </code> 选择单个元素</li><li><code>document.querySelectorAll() </code> 选择所有的</li><li><code>document.getElementsByClassName()</code> 通过类名选择</li></ul></li><li><p><strong>延迟加载JS</strong></p><ul><li><code>JS</code>的加载会影响后面的内容加载<ul><li>很多浏览器都采用了并行加载JS，但还是会影响其他内容</li></ul></li><li><code>Html5</code>的<code>defer</code>和<code>async</code><ul><li><code>defer=“defer ”</code>: 延迟加载，会按顺序执行，在<code>onload</code>执行前被触发</li><li><code>async =“async”</code>: 异步加载，加载完就触发，有顺序问题</li></ul></li><li>浏览器兼容性：<code>Labjs</code>库</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态加载script文件 （推荐方法） 只需请求一次 可加载多个JavaScript文件，减少请求次数以及页面的加载阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.type = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(script.readyState)&#123;<span class="comment">//IE</span></span><br><span class="line">script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(script.readyState == <span class="string">&quot;loaded&quot;</span> || script.readyState == <span class="string">&quot;complete&quot;</span>)&#123;</span><br><span class="line">onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">callback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">callback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">script.src = url;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&quot;js/defer.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;加载成功&quot;</span>);</span><br><span class="line">      <span class="comment">//  加载成功回调</span></span><br><span class="line">&#125;);</span><br><span class="line">loadScript(<span class="string">&quot;js/async.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;加载成功&quot;</span>);</span><br><span class="line">   <span class="comment">//  加载成功回调</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><strong>获取<code>class</code>列表属性</strong></p><ul><li><code>classList</code><ul><li><code>length</code> :  <code>class</code>的长度</li><li><code>add() </code> :  添加<code>class</code>方法</li><li><code>remove()</code>  :  删除<code>class</code>方法</li><li><code>toggle()</code> :  切换<code>class</code>方法 </li><li><code>contains()</code> : 判断类名是否存在返回<code>bool</code>值</li></ul></li></ul></li><li><p><strong><code>JSON</code>的新方法</strong></p><ul><li><p><code>parse()</code> : 把字符串转成<code>json</code></p><ul><li>字符串中的属性要严格的加上引号</li></ul></li><li><p><code>stringify()</code> : 把<code>json</code>转化成字符串</p><ul><li>会自动的把双引号加上</li></ul></li><li><p>与<code>eval</code>的区别</p><ul><li><code>eval()</code>：对任何的字符串进行解析变成js</li><li><code>parse()</code>：字符串中的属性要严格的加上引号</li></ul></li><li><p>其他浏览器兼容</p><ul><li><a href="http://www.json.org/">去下载json2.js</a></li></ul></li></ul></li><li><p><strong>历史管理</strong></p><ul><li><code>onhashchange</code> ：改变<code>hash</code>值来管理</li></ul></li></ul><h2 id="跨文档操作"><a href="#跨文档操作" class="headerlink" title="跨文档操作"></a>跨文档操作</h2><hr><ul><li><p><strong>跨文档请求</strong></p></li><li><p>同域跨文档</p><ul><li><code>iframe</code>内页：<ul><li>父页面操作子页面：<code>contentWindow</code></li><li>子页面操作父页面：<code>window.top</code>(找到最顶级的父页面)/<code>parent</code>(第一父页面)</li><li>新窗口页：<ul><li>父页面操作子页面：<code>window.open</code></li><li>子页面操作父页面：<code>window.opener</code></li></ul></li></ul></li></ul></li><li><p><strong>不同域跨文档</strong></p><ul><li><code>postMessage（“发送的数据”,”接收的域”）</code><ul><li><code>message</code>事件监听</li><li><code>ev.origin </code>发送数据来源的域</li><li><code>ev.data </code> 发送的数据</li></ul></li><li>通过判断发送的数据来执行相应的需求</li></ul></li><li><p><strong>ajax跨域</strong></p><ul><li><p><code>XMLHttpRequest</code> 新增功能</p><ul><li>跨域请求：修改服务端头信息<ul><li>I<code>E</code>兼容：<code>XDomaiRequest</code></li></ul></li></ul></li><li><p>进度事件：</p><ul><li><code>upload.onprogress(ev) </code> 上传进度(实现文件上传进度条)<ul><li><code>ev.total</code>  发送文件的总量</li><li><code>ev.loaded</code> 已发送的量</li></ul></li><li><code>FormData</code>  构建提交二进制数据</li></ul></li></ul></li><li><p>拓展阅读</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzI0ODA2ODU2NQ==&mid=2651130595&idx=2&sn=3d0f546f1867992729b3ace5d03766fc&chksm=f257ca59c520434f08e215b3bdcec3764712f73301b738c18163359e5aa5e949ff019616ffca&mpshare=1&scene=23&srcid=11289XUSBAQzrCp3Io55aoS1#rd">HTML5 API 大盘点</a><h2 id="附录二-HTML5速查表"><a href="#附录二-HTML5速查表" class="headerlink" title="附录二　HTML5速查表"></a>附录二　HTML5速查表</h2></li></ul></li></ul><hr><ul><li><a href="http://caniuse.com/#search=canvas">可以查阅支持H5+CSS3的属性</a></li><li><a href="http://www.html5star.com/manual/html5label-meaning/">HTML5 标签含义之元素周期表</a></li><li><a href="https://raw.sevencdn.com/Luckiiest/Note/master/Web/H5C3/15.png">HTML5标签速查表</a></li><li><a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=http%3A%2F%2Fjonibologna.com%2Fcontent%2Fimages%2Fflexboxsheet.pdf">展示 flexbox 属性的作用–推荐</a></li><li><a href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/">Flexbox 视觉指南–更好更容易地理解 Flexbox 某个属性的作用</a></li></ul><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p><code>CSS3</code>发展史简介</p><ul><li><code>HTML</code>的诞生 20世纪90年代初</li><li><code>1996</code>年底，    <code>CSS</code>第一版诞生</li><li><code>1998</code>年<code>5</code>月     <code>CSS2</code>正式发布</li><li><code>2004</code>年     <code>CSS2.1</code>发布</li><li><code>CSS3</code>的发布    <code>2002 </code> <code>2003</code>  <code>2004</code> <code>2005</code>  <code>2007</code> <code>2009</code> <code>2010</code></li></ul></li><li><p><strong>what is CSS3？</strong></p><ul><li>CSS3是CSS2的升级版本，3只是版本号，它在CSS2.1的基础上增加了很多强大的新功能。目前主流浏览器chrome、safari、firefox、opera、甚至360、QQ浏览器都已经支持了CSS3的大部分功能了，IE10以后也开始全面支持CSS3了。</li><li>标准写法：</li></ul><table><thead><tr><th>前缀</th><th>浏览器</th></tr></thead><tbody><tr><td>-webkit-</td><td>chrome / safari</td></tr><tr><td>-moz-</td><td>firefox</td></tr><tr><td>-ms-</td><td>IE</td></tr><tr><td>-o-</td><td>opera-</td></tr></tbody></table></li></ul><ul><li><strong>CSS的功能</strong></li><li>提供了更加强大且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状、角度等，可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等等……<ul><li>但是css3的兼容性的问题同样也显得格外重要，并不是所有的css3属性都通过了w3c标准，所以……我们需要全面性的查阅兼容性手册<ul><li><a href="http://www.runoob.com/cssref/css3-browsersupport.html">http://www.runoob.com/cssref/css3-browsersupport.html</a></li><li><a href="https://caniuse.com/">https://caniuse.com/</a></li></ul></li></ul></li><li><strong>模块化开发</strong></li><li><code>CSS1</code> 中定义了网页的基本属性：<ul><li>字体、颜色、基本选择器等</li><li><code>CSS2</code>中在<code>CSS1</code>的基础上添加了高级功能<ul><li>浮动和定位、高级选择器等(子选择器、相邻选择器、通用选择器)</li></ul></li><li><code>CSS3</code>遵循的是模块化开发。发布时间并不是一个时间点，而是一个时间段</li></ul></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li><strong>伪元素选择器：</strong><ul><li><code>::first-line</code> ：匹配文本块的首行</li><li><code>::first-letter</code> ：选择文本块的首字母</li><li><code>::selection </code>：鼠标光标选择元素内容</li><li><code>::user-selection:none</code>：不让用户选中</li></ul></li></ul><ul><li><p><strong>CSS3结构选择器</strong></p><ul><li><code>nth-child(n)</code>：父元素下的第n个子元素</li><li><code>nth-child(odd)</code>：奇数子元素同<code>nth-child(2n-1)</code></li><li><code>nth-child(even)</code>：偶数子元素同<code>nth-child(2n)</code></li><li><code>nth-child(an+b)</code>：公式</li><li><code>nth-last-child(n)</code>：倒数第n个子元素</li><li><code>first-of-type</code>：父元素下指定类型的第一个元素</li><li><code>last-of-type</code>：父元素下指定类型的最后一个元素</li><li><code>nth-of-type(n)</code>：父元素下的指定类型的元素的第n个元素</li><li><code>nth-last-of-type</code>：父元素下的倒数第几个指定类型的子元素</li><li><code>first-child</code>：父元素下的第一个子元素、</li><li><code>last-child</code>：父元素下的最后一个子元素</li><li><code>only-child</code>：父元素下的唯一的子元素</li><li><code>only-of-type</code>：选择父元素下指定类型的唯一子元素</li><li><code>E &gt; F</code> E的第一代子元素中是F的</li><li><code>E + F</code>E后面紧挨着的F兄弟节点</li><li><code>E ~ F</code>E后面所有的兄弟节点</li></ul></li></ul><ul><li><p><strong><code>Css3</code> 属性选择器</strong></p><ul><li><code>E[attr]</code>：属性名，不确定具体值</li><li><code>E[attr=&#39;value&#39;]</code>：指定属性名，并指定对应属性值</li><li><code>E[attr~=&quot;value&quot;]</code>：指定属性名，其具有多个属性值空格隔开，并包含<code>value</code>值，意思就是在<code>class</code>属性中任意一个位置有<code>value</code>就可以，不必要第一个</li><li><code>E[attr^=&quot;value&quot;]</code>：指定属性名，属性值以<code>value</code>值开头</li><li><code>E[attr$=&quot;value&quot;]</code>：指定属性名，属性值以<code>value</code>值结束</li><li><code>E[attr*=&quot;value&quot;]</code>：指定了属性名，属性值中包含了<code>value</code></li><li><code>E[attr|=&quot;value&quot;]</code>：指定属性名，属性值以<code>value</code>开头</li></ul></li></ul><ul><li><strong><code>CSS3</code>伪类选择器</strong></li><li><code>:before</code>,<code>:after</code>在元素内容前面、后面添加内容(相当于行内元素)<ul><li><strong>UI状态伪类选择器：</strong></li><li><code>:enabled </code>选择启用状态元素<ul><li><code>:disabled</code> 选择禁用状态元素</li><li><code>:checked </code>选择被选中的<code>input</code>元素（单选按钮或复选框）</li><li><code>:default</code> 选择默认元素</li><li><code>:valid</code>、<code>invalid</code> 根据输入验证选择有效或无效的<code>input</code>元素</li><li><code>:in-range</code>、<code>out-of-range</code>选择指定范围之内或者之外受限的元素</li><li><code>:required</code>、<code>optional </code>根据是否允许:<code>required</code>属性选择<code>input</code>元素</li><li><code>:read-only</code>选择只读的元素</li><li><code>read-write</code>选择非只读的元素</li><li><strong>动态伪类选择器：</strong></li><li><code>:link </code>选择链接元素<ul><li><code>:visited</code> 选择用户以访问的元素</li><li><code>:hover</code> 鼠标悬停其上的元素</li><li><code>:active </code>鼠标点击时触发的事件</li><li><code>:focus</code> 当前获取焦点的元素</li></ul></li><li><strong>其他伪类选择器</strong>：<ul><li><code>root</code>：选择文档的根目录、返回<code>html</code></li><li><code>:not(&lt;选择器&gt;) </code>对括号内选择器的选择取反</li><li><code>:lang(&lt;目标语言&gt;)</code> 基于<code>lang</code>全局属性的元素</li><li><code>:target</code> <code>url</code>片段标识符指向的元素</li><li><code>:empty</code>选择内容为空的元素</li></ul></li></ul></li></ul></li></ul><h2 id="文本-1"><a href="#文本-1" class="headerlink" title="文本"></a>文本</h2><hr><ul><li><p><strong>CSS文本属性复习</strong></p><ul><li><p><strong>white-space</strong>：对象内空格的处理方式</p><ul><li><p><code>nowrap</code> 控制文本不换行</p></li><li><p><code>pre</code> 空白会被浏览器保留</p></li><li><p><code>pre-line</code> 合并空白  保留换行符</p></li><li><p><code>pre-wrap</code> 保留空白  正常换行</p></li></ul></li><li><p><strong>direction</strong>：文本流的方向</p><ul><li><code>ltr</code> 文本从左向右</li><li><code>rtl</code>  文本从右往左</li></ul></li><li><p><strong>unicode-bidi</strong>：用于同一个页面里存在从不同方向读进的文本显示。与<code>direction</code>属性一起使用</p></li></ul></li><li><p><strong>CSS3新增文本属性</strong></p><ul><li><code>color:rgba()</code>;</li><li><code>text-overflow</code>:是否使用一个省略标记（…）标示对象内文本的溢出</li><li><code>text-align</code>:文本的对齐方式</li><li><code>text-transform</code>:文字的大小写</li><li><code>text-decoration</code>:文本的装饰线，复合属性</li><li><code>text-shadow</code>:文本阴影</li><li><code>text-fill-color</code>:文字填充颜色</li><li><code>text-stroke</code>:复合属性。设置文字的描边</li><li><code>tab-size</code>:制表符的长度</li><li><code>word-wrap</code>:当前行超过指定容器的边界时是否断开转行</li><li><code>word-break</code>:规定自动换行的处理方法</li><li><code>font-face</code></li></ul></li></ul><ul><li><p><strong>text-overflow</strong>：是否使用一个省略标记（<code>...</code>）标示对象内文本的溢出</p><ul><li><code>clip</code>： 默认值 无省略号</li><li><code>ellipsis</code>：当对象内文本溢出时显示省略标记（<code>...</code>）。</li></ul></li><li><p><strong>注意</strong>：该属性需配合<code>over-flow:hidden</code>属性(超出处理)还有 <code>white-space:nowrap</code>(禁止换行)配合使用，否则无法看到效果</p></li><li><p><strong>text-align</strong>：文本的对齐方式</p><ul><li><code>left</code>:默认值 左对齐</li><li><code>right</code>:右对齐</li><li><code>center</code>:居中</li><li><code>justify</code>： 内容两端对齐。</li><li><code>start</code>:开始边界对齐</li><li><code>end</code>:结束边界对齐</li></ul></li><li><p><strong>text-transform</strong>：文字的大小写</p><ul><li><strong><code>css1</code></strong><ul><li><code>none</code>：    默认值 无转换 </li><li><code>capitalize</code>：     将每个单词的第一个字母转换成大写 </li><li><code>uppercase</code>：    转换成大写 </li><li><code>lowercase</code>：    转换成小写</li></ul></li><li><strong><code>css3</code></strong><ul><li><code>full-width</code>：    将左右字符设为全角形式。不支持</li><li><code>full-size-kana</code>：将所有小假名字符转换为普通假名。不支持</li><li>例如：土耳其语</li></ul></li></ul></li><li><p><strong>text-decoration</strong>：文本的装饰线，复合属性(只火狐支持)</p><ul><li><code>text-decoration-line </code>：<ul><li>指定文本装饰的种类。相当于<code>CSS1</code>时的<code>text-decoration</code>属性</li></ul></li><li><code>text-decoration-style</code> ：<ul><li>`指定文本装饰的样式。</li></ul></li><li><code>text-decoration-color</code>：<ul><li>`指定文本装饰的颜色。</li></ul></li><li><code>blink</code>： 指定文字的装饰是闪烁。  <code>opera</code>和<code>firefox</code></li></ul></li><li><p><code>text-decoration</code> : <code>#F00 double overline</code>   <code>CSS3</code>实例</p></li><li><p><strong>text-shadow</strong>：文本阴影</p><ul><li>取值：<code>x </code> <code>y</code>   <code>blur</code> <code>color</code>,……<ul><li><code>x  </code>      横向偏移</li><li><code>y </code>       纵向偏移</li><li><code>blur </code>     模糊距离(灰度)</li></ul></li><li><code>color</code>    阴影颜色</li></ul></li><li><p><strong>text-fill-color</strong>：文字填充颜色</p></li><li><p><strong>text-stroke</strong>：复合属性。设置文字的描边</p><ul><li><code>text-stroke-width</code>:文字的描边厚度 </li><li><code>text-stroke-color</code>:文字的描边颜色 </li></ul></li><li><p><strong>tab-size</strong>：制表符的长度   </p><ul><li>默认值为<code>8</code>(一个<code>tab</code>键的空格字节长度)，在    <code>pre</code>标签之内才会有显示</li></ul></li><li><p><strong>word-wrap</strong>：当前行超过指定容器的边界时是否断开转行</p><ul><li><code>normal</code>： 默认值</li><li><code>break-word</code>：在长单词或 URL 地址内部进行换行。</li><li>允许内容顶开或溢出指定的容器边界。 </li></ul></li><li><p><strong>break-word</strong>：内容将在边界内换行。如果需要，单词内部允许断行</p><ul><li><code>normal</code>： 使用浏览器默认的换行规则</li><li><code>break-all</code>：允许在单词内换行</li><li><code>keep-all</code>：只能在半角空格或连字符处换行</li></ul></li><li><p><strong>font-face</strong></p></li></ul><pre><code>- 自定义字体- ```css    @font-face &#123;        font-family:&#39;myFirstFamily&#39;; // 字体名字        src: url(&#39;./Christmas Day Personal Use.ttf&#39;); // 字体路径    &#125;        兼容    @font-face &#123;        font-family: &#39;diyfont&#39;;        src: url(&#39;diyfont.eot&#39;); /* IE9+ */        src: url(&#39;diyfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */             url(&#39;diyfont.woff&#39;) format(&#39;woff&#39;), /* chrome、firefox */             url(&#39;diyfont.ttf&#39;) format(&#39;truetype&#39;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/             url(&#39;diyfont.svg#fontname&#39;) format(&#39;svg&#39;); /* iOS 4.1- */    &#125;        http://www.w3cplus.com/content/css3-font-face    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    - `format`: 此值指的是你自定义的字体的格式，主要用来帮助浏览器识别浏览器对`@font-face`的兼容问题，这里涉及到一个字体`format`的问题，因为不同的浏览器对字体格式支持是不一致的，浏览器自身也无法通过路径后缀来判断字体</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 背景</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">- **CSS背景属性复习**</span><br><span class="line"></span><br><span class="line">  - `background`:</span><br><span class="line">    - `background-color`:背景颜色</span><br><span class="line">    - `background-image`:背景图片</span><br><span class="line">    - `background-repeat`:背景重复</span><br><span class="line">    - `background-position`:背景定位</span><br><span class="line">  - `background-attachment`:背景固定(`scroll/fixed)`</span><br><span class="line"></span><br><span class="line">- **CSS3新增背景属性**</span><br><span class="line"></span><br><span class="line">- **bakground-size**：背景尺寸</span><br><span class="line"></span><br><span class="line">  - 设置背景图片的大小，以长度值或百分值或百分比显示，还可以通过`cover`和`contain`来对图片进行伸缩</span><br><span class="line">  - 语法：</span><br><span class="line">    - **background-size**:` auto `| `&lt;长度值&gt;` | `&lt;百分比&gt; `| `cover` | `contain`</span><br><span class="line">- 属性：</span><br><span class="line">    - `auto`：默认值，不改变背景图片的原始高度和宽度</span><br><span class="line">      - `&lt;长度值&gt;`: 成对出现如`200px` `50px`，将背景图片宽高一次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放</span><br><span class="line">      - `&lt;百分比&gt;`: `0%~100%`之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；</span><br><span class="line">      - `cover`: 用一张图片铺满整个背景，如果比例不符，则截断图片</span><br><span class="line">      - `contain`: 尽量让背景内，存在一整张图片</span><br><span class="line"></span><br><span class="line">- 多背景</span><br><span class="line"></span><br><span class="line">  - `background-image:url(1.jpg),url(2.jpg)`;</span><br><span class="line"></span><br><span class="line">- **background-origin** ：背景区域定位</span><br><span class="line"></span><br><span class="line">  - 背景图片的起始位置</span><br><span class="line">  - 原来的背景图片是从`padding`区域开始引入的，可以使用这个属性来更改引入区域</span><br><span class="line">  - `border-box`： 从`border`区域开始显示背景。 </span><br><span class="line">  - `padding-box`： 从`padding`区域开始显示背景。 </span><br><span class="line">  - `content-box`： 从`content`内容区域开始显示背景。</span><br><span class="line"></span><br><span class="line">- **background-clip** ：背景绘制区域</span><br><span class="line"></span><br><span class="line">  - 裁剪背景</span><br><span class="line"></span><br><span class="line">    - `border-box`： 从`border`区域向外裁剪背景。 </span><br><span class="line">    - `padding-box`： 从`padding`区域向外裁剪背景。 </span><br><span class="line">    - `content-box`： 从`content`区域向外裁剪背景。 </span><br><span class="line">    - 分别表示从边框、内边距和内容区域往外裁剪背景，`no-clip`表示不裁切和参数`border-box`显示同样的效果。`background-clip`默认值为`border-box`</span><br><span class="line"></span><br><span class="line">  - `text`:背景填充文本</span><br><span class="line"></span><br><span class="line">    - `background-clip: text`;</span><br><span class="line"></span><br><span class="line">    - 从前景内容的形状作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果</span><br><span class="line"></span><br><span class="line">    - 注意它是-webkit-独有的属性，且必须配合`-text-fill-color-`属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">-webkit-background-clip: text;</span><br><span class="line">-webkit-text-fill-color: transparent;</span><br><span class="line">text-fill-color: -webkit-background-clip;</span><br></pre></td></tr></table></figure></code></pre><ul><li><strong>颜色渐变</strong><ul><li><strong>线性渐变</strong>：<code>linear-gradient</code>(起点/角度 半径，颜色 位置，…,)<ul><li>起点：<code>left/top/right/bottom/left top...... </code>默认<code>top</code></li><li>角度：逆时针方向 <code>0-360deg</code>（度），起点和角度一样</li><li>半径：可以控制渐变圆的大小</li><li>颜色 位置：<code>red 50%</code>, <code>blue 100%</code>(红色从50%渐变到100%为蓝色)</li><li><code>repeating-linear-gradient</code>  线性渐变重复平铺</li><li><code>IE</code>低版本渐变(滤镜)：</li><li><code>filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;,endColorstr=&#39;#ff0000&#39;,GradientType=&#39;1&#39;);</code></li></ul></li><li><strong>径向渐变</strong>：<code>radial-gradient</code>(起点(圆心位置) at 形状/半径/大小,  颜色1,  颜色2)<ul><li>起点：<code>left/top/right/bottom</code>或具体值/百分比</li><li>形状：<code>ellipse</code>(椭圆)、<code>circle</code>(正圆)</li><li>形状\半径\大小：具体数值或百分比，也可以是关键字（<code>closest-side</code>(最近端), <code>closest-corner</code>最近角), <code>farthest-side</code>(最远端), f<code>arthest-corner</code>(最远角), <code>contain</code>(包含) ,<code>cover</code>(覆盖)）;</li><li>颜色 位置：<code>red 50%</code>, <code>blue 100%</code>(红色从50%渐变到100%为蓝色)</li></ul></li></ul></li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><hr><ul><li><strong>CSS颜色属性复习</strong><ul><li><code>color name </code>    颜色英文名称命名</li><li><code>HEX</code>方式         十六进制方式</li><li><code>rgb</code>方式           三原色配色方式</li></ul></li></ul><h3 id="rgba-颜色"><a href="#rgba-颜色" class="headerlink" title="rgba()颜色"></a>rgba()颜色</h3><ul><li><p><code>RGB</code>是一种色彩标准，是由红<code>(R)</code>、绿<code>(G)</code>、蓝<code>(B)</code>的变化以及相互叠加来得到各式各样的颜色。<code>RGBA</code>是在<code>RGB</code>的基础上增加了控制<code>alpha</code>透明度的参数。</p></li><li><p>语法：<code>color: rgba(R, G, B, A)</code></p><ul><li>以上<code>R</code>、<code>G</code>、<code>B</code>三个参数，正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限。并非所有浏览器都支持使用百分数值。<code>A</code>为透明度参数，取值在0~1之间，不可为负值。</li></ul></li><li><table><thead><tr><th>名称</th><th>颜色</th><th>颜色</th><th>取值</th></tr></thead><tbody><tr><td>r</td><td>red</td><td>红色</td><td>0-255</td></tr><tr><td>g</td><td>green</td><td>绿色</td><td>0-255</td></tr><tr><td>b</td><td>blue</td><td>蓝色</td><td>0-255</td></tr><tr><td>a</td><td>alpha</td><td>透明</td><td>0-1</td></tr></tbody></table></li></ul><h3 id="HSL模式-HSLA-模式"><a href="#HSL模式-HSLA-模式" class="headerlink" title="HSL模式  HSLA 模式"></a>HSL模式  HSLA 模式</h3><ul><li><p><code>H</code>： <code>Hue</code>(色调)。</p><ul><li>0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：<code>0 - 360</code> </li></ul></li><li><p><code>S</code>：<code> Saturation</code>(饱和度)。取值为：0.0% - 100.0% </p></li><li><p><code>L</code>： <code>Lightness</code>(亮度)。取值为：0.0% - 100.0%</p></li><li><p><code>A</code>:    <code>alpha  </code>   透明度   0~1之间</p></li><li><p>语法:<code>HSLA(H,S,L,A)</code></p></li><li><p>HSL色轮</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111706388.png" alt="HSL色轮"></li></ul></li></ul><ul><li><p><strong>透明颜色：<code>transparent</code></strong></p><ul><li>实例：<code>border</code>实现三角箭头、风车等</li></ul></li><li><p><strong>透明度：</strong></p><ul><li><code>opacity</code></li><li>取值：<code>0-1</code>之间</li><li>注：低版本的<code>IE</code>浏览器不兼容,需用IE浏览器的滤镜实现相同效果，<code>filter:alpha(opacity=50)</code></li><li>对于低版本的火狐浏览器需添加内核前缀，<code>-moz-opacity</code></li></ul></li></ul><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><hr><h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><hr><ul><li>边框圆角<ul><li>在<code>CSS2</code>中添加圆角矩形需要技巧。我们必须为每个圆角使用不同的图片</li><li>在 <code>CSS3 </code>中，创建圆角是非常容易的</li><li>在<code>CSS3</code>中，<code>border-radius </code>属性用于创建圆角</li></ul></li><li><strong>border-radius</strong>：边框圆角写法<ul><li><code>border-radius: 2em 1em 4em / 0.5em 3em;</code></li><li>等价于<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">2em</span> <span class="number">0.5em</span>;</span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">1em</span> <span class="number">3em</span>;</span><br><span class="line"><span class="attribute">border-bottom-right-radius</span>: <span class="number">4em</span> <span class="number">0.5em</span>;</span><br><span class="line"><span class="attribute">border-bottom-left-radius</span>: <span class="number">1em</span> <span class="number">3em</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="边框系列-图片"><a href="#边框系列-图片" class="headerlink" title="边框系列-图片"></a>边框系列-图片</h3><hr><ul><li><strong>border-image</strong>：语法</li></ul><table><thead><tr><th>属性</th><th>版本</th><th>简介</th></tr></thead><tbody><tr><td><code>border-image</code></td><td>CSS3</td><td>设置或检索对象的边框使用图像来填充</td></tr><tr><td><code>border-image-source</code></td><td>CSS3</td><td>设置或检索对象的边框是否用图像定义样式或图像来源路径</td></tr><tr><td><code>border-image-slice</code></td><td>CSS3</td><td>设置或检索对象的边框背景图的分割方式</td></tr><tr><td><code>border-image-width</code></td><td>CSS3</td><td>设置或检索对象的边框厚度</td></tr><tr><td><code>border-image-outset</code></td><td>CSS3</td><td>设置或检索对象的边框背景图的扩展</td></tr><tr><td><code>border-image-repeat</code></td><td>CSS3</td><td>设置或检索对象的边框图像的平铺方式</td></tr></tbody></table><ul><li><strong><code>border-image-slice</code></strong><ul><li>设置或检索对象的边框背景图的分割方式</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111706283.png" alt="Paste_Image.png"></p><ul><li><strong><code>border-image-repeat</code></strong><ul><li>用于指定边框背景图的重复方式</li><li>取值：<ul><li><code>stretch</code>： 指定用拉伸方式来填充边框背景图。 *默认的</li><li><code>repeat</code>： 指定用平铺方式来填充边框背景图。当图片碰到边界时，如果超过则被截断。 </li><li><code>round</code>： 指定用平铺方式来填充边框背景图。图片会根据边框的尺寸动态调整图片的大小    直至正好可以铺满整个边框。写本文档时仅Firefox能看到该效果 </li></ul></li></ul></li></ul><h2 id="布局-盒模型"><a href="#布局-盒模型" class="headerlink" title="布局/盒模型"></a>布局/盒模型</h2><hr><h3 id="columns"><a href="#columns" class="headerlink" title="columns"></a>columns</h3><ul><li><p>多列布局</p></li><li><p>为了能在<code>Web</code>页面中方便实现类似报纸、杂志那种多列排列的布局，<code>W3C</code>特意给<code>CSS3</code>增加了一个多列布局模块（<code>CSS Multi Column Layout Module</code>）。它主要应用在文本的多列布局方面，这种布局在报纸和杂志上都使用了几十年了，但要在Web页面上实现这样的效果还有有相当大的难度，庆幸的是，CSS3的多列布局可以轻松实现</p></li><li><p>语法</p><ul><li><p><strong>columns:</strong></p><ul><li><p><code>columns</code> ：宽度 列数; 混合属性</p><ul><li>例如：<code>columns:200px 3</code></li></ul></li><li><p><code>column-width</code>： 指的是每一列的宽度，根据容器宽度自适应</p></li><li><p><code>column-count</code> ：指定规定的列数，唯一精准的是列数</p><ul><li><em>column-width和column-count两个不要一起使用，会混乱</em></li></ul></li><li><p><strong>column-gap</strong>：列宽</p><ul><li>设置列与列之间的宽度，直接用数值表示即可</li><li>用来设置列与列的间距，如果没有显示设置column-gap值时，其值大小会根据浏览器默认的font-size来决定</li><li><code>column-width </code>= <code>(width - (n - 1) * font - size) / n</code><ul><li><code>n</code>是几列</li></ul></li></ul></li><li><p><strong>column-rule</strong>：列的边框 </p><ul><li><p><code>column-rule</code>: 宽度  线的类型  颜色</p><ul><li>例：<code>column-rule:1px solid #ccc</code></li></ul></li><li><p>不占用任何空间位置，在列与列之间改变其宽度不会改变任何列的位置。</p></li><li><p><code>column-rule-width </code></p><ul><li>用来定义列边框的宽度，其默认值为<code>medium</code></li><li>接收浮点数，但是不接受负值</li><li>属性值：<code>medium</code>、<code>thick</code>、<code>thin</code></li></ul></li><li><p><code>column-rule-style</code></p><ul><li>样式</li><li>定义列边框样式，其默认值为“none”</li><li><code>column-rule-style</code>：属性值与<code>border-style</code>属性值相同</li><li>属性值：<code>none</code>、<code>hidden</code>、<code>dotted</code>、<code>dashed</code>、<code>solid</code>、<code>double</code>、<code>groove</code>、<code>ridge</code>、<code>inset</code>、<code>outset</code></li></ul></li><li><p><code>column-rule-color</code> 颜色</p></li></ul></li><li><p><strong>column-span</strong>：<code>1</code> / <code>all</code></p><ul><li>只可以跨<code>1</code>列或者所有列</li><li>设置多列布局元素内的子元素，可以跨列，类似标题效果。即一个新闻标题要横跨所有内容列。</li><li>注：此属性要在子元素上设置</li></ul></li></ul></li></ul></li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><ul><li><p>在<code>CSS</code>中盒模型分为两种，第一种是W3C的标准盒模型，另一种是IE6混杂模式的传统模型。他们都是对元素计算尺寸的模型。但他们的不同是计算的方式不同。</p></li><li><p><strong>W3C标准盒模型</strong></p><ul><li><p><code>element</code>空间高度（盒子）= <code>width </code>+ <code>padding</code> + <code>border</code></p></li><li><p><code>width</code>为内容高度。即<code>width</code>不包括<code>padding</code>和<code>border</code></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111707818.jpg" alt="标准盒子模型"></p></li></ul></li><li><p><strong>IE6混杂模式盒模型</strong></p><ul><li>内容高度（盒子） = <code>width</code> - <code>padding</code> - <code>border</code></li><li><code>width</code>的数值就是<code>element</code>盒子的空间高度，<code>width</code>包括了<code>padding</code>和<code>border</code></li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111707578.jpg" alt="IE盒子模型"></li></ul></li><li><p><strong>box-shadow</strong>:<code>inset</code> <code>x</code> <code>y</code> <code>blur</code> <code>spread</code> <code>color</code></p><ul><li><code>inset</code>：投影方式</li><li><code>inset</code>：内投影</li><li><code>outset</code>：外投影 默认(不能设置)</li><li><code>x</code>、<code>y</code>：阴影偏移</li><li><code>blur</code>：模糊半径（灰度）</li><li><code>spread</code>：扩展阴影半径</li><li>先扩展原有形状，再开始画阴影</li><li><code>color</code></li></ul></li><li><p><strong>box-reflect</strong>：倒影</p><ul><li>方向 <code> above | below | left | right;</code></li><li>距离<ul><li>渐变（可选）</li></ul></li></ul></li></ul><h3 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h3><ul><li>有主轴<code>（x）</code>侧轴 / 交叉轴<code>（y）</code></li><li>给父级设置的<code>diaplay:flex</code>叫<code>flex</code>盒子，它里面的盒子叫做<code>flex</code>项目</li><li><code>display: flex</code>：给父级设置盒子属性</li><li><code>flex</code> 是一个复合属性，且必须配合父元素<code>display: flex</code>使用</li><li><strong>以下六个属性是设置在项目（子元素）上的：</strong><ul><li><strong>flex-grow</strong> ：放大比例<ul><li>进行比例的分配，定义项目的放大比例，默认为0，即如果存在剩余空间，也放大</li><li>根据所设置的比例分配盒子剩余的空间</li></ul></li><li><strong>flex-shrink</strong>：缩小比例<ul><li>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</li><li>设置元素的收缩比例——多出盒子的部分，按照比例的大小砍掉相应的大小，即比例越大，被砍得越大，默认值<code>1</code></li><li>缩减的宽度 = <code>(flex-shrink1 * width1) / (flex-shrink2 * width1 + flex-shrink2 * width2) * moveWidth</code></li></ul></li><li><strong>flex-basis</strong>：伸缩基准值<ul><li>伸缩基准值，项目占据主轴空间</li><li>定义了在分配多余空间之前，项目占据的主轴空间（<code>main size</code>），浏览器根据这个属性，计算主轴是否有多余空间，他的默认值为<code>auto</code>，即项目本来大小</li><li>该属性设置元素的宽度或高度，当然<code>width</code>也可以用来设置元素宽度，如果元素上同时出现了<code>width</code>和<code>flex-basis</code>那么<code>flex-basis</code>会覆盖width的值</li><li>子元素宽度尽可能按照<code>basis</code>来如果基准值相加大于容器宽度那么下面由下面公式分配宽度给子元素</li><li><code>（flex-basis / (flex - basis 相加） * 容器的宽度)</code></li></ul></li><li><strong>flex</strong>：是<code>flex-frow</code>，<code>flex-shrink</code>，<code>flex-basis</code>的简写<ul><li>默认值为：<code>flex:0 1 auto</code></li><li>常用简化写法<ul><li><code>flex:1</code>;  ——  <code>flex:1 1 0%</code>;</li><li><code>flex:3</code>;  ——  <code>flex:3 1 0%</code>;</li><li><code>flex:auto</code>; —— <code>flex: 1 1 auto</code>;</li><li><code>flex:none</code>; —— <code>flex: 0 0 auto</code>;</li></ul></li><li><code>flexbox</code>布局和原来的布局是两个概念，部分<code>css</code>属性在<code>flexbox</code>盒子里面不起作用，<code>float</code>，<code>clear</code>，<code>column</code>，<code>vertical-align</code>等等</li><li>建议使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</li><li>真实情况<ul><li><code>son1</code> = (<code>flex-shrink</code>) * <code>flex-basis</code></li><li><code>son2</code> = (<code>flex-shrink</code>) * <code>flex-basis</code></li><li><code>sonN</code> = (<code>flex-shrink</code>) * <code>flex-basis</code></li><li>加权值 = <code>son1</code> + <code>son2</code> + …… + <code>sonN</code></li><li>压缩的宽度 <code>w</code> = (子元素<code>flex</code> - <code>basis</code>值  * （<code>flex-shrink</code>) / 加权值) * 溢出值</li><li>缩减值1：(<code>flex-basis1 * 1</code> / 加权值) * 溢出值</li><li>缩减值2：(<code>flex-basis2 * 2</code> / 加权值) * 溢出值</li><li>缩减值3：(<code>flex-basis3 * 3</code> / 加权值) * 溢出值</li><li>最后<code>son1</code>、<code>son2</code>、<code>son3</code>的实际宽度为：<ul><li><code>flex-basis</code> - 缩减值 <code>n</code> = <code>son n</code> 真实宽度</li></ul></li></ul></li></ul></li><li><strong>order</strong>：排列顺序<ul><li><code>number</code>定义项目的排列顺序。数值越小，排列越靠前，默认为<code>0</code></li></ul></li><li><strong>align-self</strong> ：单个项目对齐方式<ul><li><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性，默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></li><li><code>auto</code>：自动排序</li><li><code>flex-start</code>：最开始的位置排序</li><li><code>flex-end</code>：最后的位置排序</li><li><code>center</code>：中间排序</li><li><code>baseline</code>：以第一行文字的基准线对齐</li><li><code>stretch</code>：如果项目未设置高度或设置为<code>auto</code>，将占满整个父级容器的高度</li></ul></li></ul></li><li><strong>以下六个属性设置在容器上</strong><ul><li><strong>flex-direction</strong>：决定主轴方向<ul><li>决定主轴的方向，即项目的排列方向</li><li><code>row</code>：（默认值）主轴为水平方向，起点在左端</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端</li><li><code>column</code>：主轴为垂直方向，起点在上沿</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿</li></ul></li><li><strong>flex-wrap</strong> 是否换行<ul><li>默认情况下，项目都排在一条线（又称“轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</li><li><code>nowrap</code>：（默认）：不换行</li><li><code>wrap</code>：换行，第一行在上方</li><li><code>wrap-reverse</code>：换行，第一行在下方</li></ul></li><li><strong>flex-flow</strong>  <ul><li><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row</code> <code>nowrap</code></li></ul></li><li><strong>justify-content</strong><ul><li>定义了项目在主轴上的对齐方式</li><li><code>flex-start</code>：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>：居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></li><li><strong>align-items</strong><ul><li>定义项目在侧轴上的对齐方式</li><li><code>flex-start</code>：交叉轴的起点对齐</li><li><code>flex-end</code>：交叉轴的中点对齐</li><li><code>center</code>：交叉轴的中点对齐</li><li><code>baseline</code>：项目的第一行文字的基线对齐</li><li><code>stretch</code>：（默认值）：如果项目未设置高度或设置为<code>auto</code>，将占满整个容器的高度</li></ul></li><li><strong>align-content</strong><ul><li>定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用</li><li><code>flex-start</code>：与交叉轴的起点对齐</li><li><code>flex-end</code>：与交叉轴的终点对齐</li><li><code>center</code>：与交叉轴的中点对齐</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍</li><li><code>stretch</code>：（默认值）：轴线沾满整个交叉轴</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111708239.png" alt="flex布局语法篇小结"></p><ul><li>拓展阅读<ul><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">flex布局语法篇</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">flex布局实例篇</a></li></ul></li></ul><h2 id="运动体系"><a href="#运动体系" class="headerlink" title="运动体系"></a>运动体系</h2><hr><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><hr><ul><li>过渡：给改变添加过程<ul><li>什么是过渡</li><li>过渡效果由哪几部分组成</li><li>过渡可以干些什么</li></ul></li><li><strong>transition</strong>： 过渡属性<ul><li><code>transition: property duration timing-function delay</code>;</li><li><strong>transition-property</strong>：过渡属性的名称</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- `none `  没有过渡属性</span><br><span class="line">- `all  `      所有属性都过渡(默认值)</span><br><span class="line">- `property `   具体属性名称(`property1`,`property2`...)</span><br></pre></td></tr></table></figure><ul><li><p><strong>transition-duration</strong>：过渡属性花费的时间</p><ul><li><code>time </code>  秒或毫秒</li></ul></li><li><p><strong>transition-delay</strong>：过渡效果延迟时间</p></li><li><p><strong>transition-timing-function</strong>：过渡效果速度曲线</p><ul><li><code>time </code>  秒或毫秒</li><li><code>linear</code>:规定以相同速度开始至结束的过渡效果（等于 <code>cubic-bezier(0,0,1,1)</code>）。</li><li><code>ease</code>:规定慢速开始，然后变快，然后慢速结束的过渡效果（<code>cubic-bezier(0.25,0.1,0.25,1)</code>）。</li></ul></li><li><p><code>ease-in</code>:规定以慢速开始的过渡效果（等于 <code>cubic-bezier(0.42,0,1,1)</code>）。</p><ul><li><code>ease-out</code>    :规定以慢速结束的过渡效果（等于 <code>cubic-bezier(0,0,0.58,1)</code>）。</li><li><code>ease-in-out</code> :规定以慢速开始和结束的过渡效果（等于 <code>cubic-bezier(0.42,0,0.58,1)</code>）。</li><li><code>cubic-bezier(n,n,n,n)</code>:在 <code>cubic-bezier</code> 函数中定义自己的值。可能的值是 <code>0 </code>至 <code>1</code> 之间的数值。</li></ul></li><li><p>过渡完成事件   </p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111708489.png" alt="过渡完成事件"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- `Webkit`内核： </span><br><span class="line">```javascript</span><br><span class="line">obj.addEventListener(&#x27;webkitTransitionEnd&#x27;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>标准: </p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.addEventListener(<span class="string">&#x27;transitionend&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 动画</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">- 什么是`CSS3` 动画？</span><br><span class="line">  - 通过 `CSS3`，我们能够创建动画，这可以在许多网页中取代动画图片、`Flash` 动画以及 `JavaScript`</span><br><span class="line">- `animation` 动画会按照`keyframes`关键帧里面指定的帧状态而过渡执行。0% —— 100% 代表动画的时间过渡</span><br><span class="line">  </span><br><span class="line">- **动画接口**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|属性  | 描述 |</span><br><span class="line">|---|---|</span><br><span class="line">| @keyframes|规定动画。|</span><br><span class="line">| animation|所有动画属性的简写属性，除了 animation-play-state 属性。|</span><br><span class="line">| animation-name|规定 @keyframes 动画的名称。|</span><br><span class="line">| animation-duration|规定动画完成一个周期所花费的秒或毫秒。|</span><br><span class="line">| animation-timing-function| 规定动画的速度曲线（速率）。 |</span><br><span class="line">| animation-delay|规定动画延迟时间|</span><br><span class="line">| animation-iteration-count|规定动画被播放的次数。 infinite（无限次）number（有限次）|</span><br><span class="line">| animation-direction|规定动画的方向。|</span><br><span class="line">| animation-play-state| 规定动画是否正在运行或暂停。running（播放）paused（暂停） |</span><br><span class="line">| animation-fill-mode|规定对象动画时间之外的状态。|</span><br><span class="line"></span><br><span class="line">- **animation-direction**:  方向</span><br><span class="line">  - `normal`：0%-100%）</span><br><span class="line">  - `reverse`：（100%-0%）</span><br><span class="line">  - `alternate`：（奇数次正向，偶数次反向）</span><br><span class="line">  - `alternate-reverse`：（奇数次反向，偶数次正向） </span><br><span class="line"></span><br><span class="line">- **animation-timing-function速度曲线**</span><br><span class="line"></span><br><span class="line">  - |值 | 描述 |</span><br><span class="line">  |---|---|</span><br><span class="line">  |linear |动画从头到尾的速度是相同的。|</span><br><span class="line">  |ease |默认。动画以低速开始，然后加快，在结束前变慢。|</span><br><span class="line">  |ease-in |动画以低速开始。 |</span><br><span class="line">  |ease-out |动画以低速结束。 |</span><br><span class="line">  |ease-in-out |动画以低速开始和结束。 |</span><br><span class="line">  |cubic-bezier(n,n,n,n) |在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 |</span><br><span class="line"></span><br><span class="line">- **animation-fill-mide**:  定义在动画开始之前和结束之后发生的操作</span><br><span class="line">  - `forwards`：动画在结束后停留在最后的关键帧的位置</span><br><span class="line">  - `backwards`：会在向元素应用动画样式时迅速应用动画的初始帧，意思是是否立即使用关键帧（结合延迟1s来看）</span><br><span class="line">  - `both`：元素动画同时拥有`forwards`和`backwards`效果</span><br><span class="line">  - `none`：默认值，表示动画按照预期进行，完成最后一帧时，反转到初始处</span><br><span class="line">- 在谷歌浏览器里面需要加上`-webkit-`</span><br><span class="line">`IE6,7,8,9`不支持`css3`运动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### transform 2D转换</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">- **`Css3`平面转换方法**</span><br><span class="line">  - `translate() `：移动</span><br><span class="line">  - `rotate`：旋转</span><br><span class="line">  - `scale()`：缩放</span><br><span class="line">  - `skew()`：翻转</span><br><span class="line">  - `matrix()`：矩阵</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **transform:**</span><br><span class="line">- **rotate()**  旋转函数/方法 (deg)</span><br><span class="line">    - 以x/y/z轴进行旋转，默认为z轴</span><br><span class="line">     - `deg`  度数</span><br><span class="line">    - 用于旋转元素角度</span><br><span class="line">    - 例：`rotate(30deg) ` 把元素顺时针旋转 30 度</span><br><span class="line">  - `rotatex()`，`rotatey()`，`rotatez()` ，`rotate3d(x, y, z, angle)`</span><br><span class="line">    - `angle`是旋转角度</span><br><span class="line">  - **skew(X,Y)** 倾斜函数 / 翻转方法 (deg) </span><br><span class="line">     - `skewX()`</span><br><span class="line">    - `skewY()`</span><br><span class="line">    - 通过 `skew() `方法，元素翻转给定的角度</span><br><span class="line">     - 例：`transform: skew(30deg,20deg);`</span><br><span class="line">          - 把元素围绕 `X `轴把元素翻转` 30` 度，围绕 `Y` 轴翻转 `20 `度</span><br><span class="line">  - **scale(X,Y)**：缩放函数 / 尺寸方法 (正数、负数和小数)</span><br><span class="line">       - `scaleX()`</span><br><span class="line">    - `scaleY()`</span><br><span class="line">    - 方法用于改变元素尺寸</span><br><span class="line">    - 例：`scale(2,4)` </span><br><span class="line">         - 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍</span><br><span class="line">    - `scalex()`, `scaley()`, `scalez()`值是数字表示倍数，不加任何单位</span><br><span class="line">    - `scale3d()` --&gt; `scale3d(x, y, z)`</span><br><span class="line">  - **translate(X,Y)** 位移函数 / 位置方法(px)</span><br><span class="line">       - `translateX()`</span><br><span class="line">    - `translateY()`</span><br><span class="line">    - 用于移动元素位置</span><br><span class="line">      - 例：`translate(50px,100px)`</span><br><span class="line">    - 把元素从左侧移动 50 像素，从顶端移动 100 像素。</span><br><span class="line">    - 其实有些类似于我们的相对定位</span><br><span class="line">    - `translatex()`,` translatey()`, `translatez()`, `translate3d(x, y, z)`</span><br><span class="line">  - **transform-origin**</span><br><span class="line">    - 变换原点</span><br><span class="line">    - 任何一个元素都有一个中心点，默认情况下，其中心点是居于元素x轴和y轴的50%处</span><br><span class="line">    - 取值</span><br><span class="line">      - 也可以使用像素值</span><br><span class="line">      - `top` = `top` `center` = `center top` = `50% 0`</span><br><span class="line">      - `right` = `right center` = `center right` = `100% | 100% 50%`</span><br><span class="line">      - `bottom` = `bottom center` = `center bottom = 50% 100%`</span><br><span class="line">      - `left` = `left center` = `center left = 0 | 0 50%`</span><br><span class="line">      - `center` = `center center` = `50% | 50% 50%`</span><br><span class="line">      - `top left` = `left top` = `0 0`</span><br><span class="line">      - `right top` = `top right` = `100% 0`</span><br><span class="line">      - `bottom right` = `right bottom` = `100% 100%`</span><br><span class="line">      - `bottom left` = `left bottom` = `0 100%`</span><br><span class="line"></span><br><span class="line">### transform 3D转换</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">- **`Css3`立体转换**</span><br><span class="line">- **transform-style：**</span><br><span class="line">    - *transform-style属性需要设置在父元素中，高于任何嵌套的变形元素，设置了transform-style的元素，就不能防止子元素溢出设置overflow:hidden，否则会导致preserve-3d失效*</span><br><span class="line">    - **flat**：默认，子元素将不保留其`3D`位置</span><br><span class="line">    - **preserve-3d**：子元素保留其`3D`位置</span><br><span class="line">       - 建立`3D`空间（指定元素的子元素展示的场景是在`3D`场景还是平面(投影)场景）</span><br><span class="line">       - `perspective` 视角（指定观察者与z=0平面的距离，从而让元素及子元素看起来有3D透视位置效果</span><br><span class="line">         值：集体的带单位数值）</span><br><span class="line">       - `Perspective- origin` 视角基点 / 视觉中心点</span><br><span class="line">          - 值：取值类似于变换基准</span><br><span class="line">          - 默认值为50% 50%</span><br><span class="line">- **backface-visibility：**</span><br><span class="line">    - 在元素运动的过程中，能否展示元素的背面</span><br><span class="line">    - `visible`：可见</span><br><span class="line">    - `hidden`：隐藏</span><br><span class="line"></span><br><span class="line">## 媒体查询</span><br><span class="line"></span><br><span class="line">### 简介</span><br><span class="line"></span><br><span class="line">- **模拟移动端meta**</span><br><span class="line">- *&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,use-scalable=no&quot;&gt;*</span><br><span class="line">  - `name=&#x27;viewport&#x27;`：视口大小</span><br><span class="line">  - `content=&quot;width=device-width&quot;` ：`width`视口宽度等于设备的宽度</span><br><span class="line">  - `initial-scale=1.0`：占的比例大小，1.0就是不放不缩</span><br><span class="line">  - `minimum-scale = 1.0`：代表最小能缩到1.0</span><br><span class="line">  - `maximum-scale = 1.0`：代表最大能缩到1.0</span><br><span class="line">  - `use-scalable=no`：不允许用户进行缩放</span><br><span class="line">- **为什么有媒体查询**</span><br><span class="line"></span><br><span class="line">  - 移动端的快速普及完全颠覆了`Web`涉及领域</span><br><span class="line">  - 用户不再仅在传统桌面系统上查看`Web`内容，他们越来越多地使用具有各种尺寸的智能电话、平板电脑和其他设备</span><br><span class="line">  - `Web`设计人员的挑战是确保他们的网站不仅是在大屏幕上看起来不错，在小型的电话以及介于它们之间的各种设备上看起来不错</span><br><span class="line">- **什么是媒体查询**</span><br><span class="line"></span><br><span class="line">  - 媒体查询是向不同设备提供不同样式的一种方式，它为每种类型的用户提供了最佳的体验</span><br><span class="line">  - `CSS2`：`media type`</span><br><span class="line">    - `media type`（媒体类型）是`css2`中一个非常有用的属性，通过`media type`我们可以对不同的设备指定特定的样式，从而实现更丰富的界面</span><br><span class="line">  - `CSS3`：`media query`</span><br><span class="line">    - `media query`是`CSS3`对`media type`的增强，事实上我们可以将media query看成是`media type+css`属性（媒体特征`Media features`）判断</span><br><span class="line"></span><br><span class="line">### **如何使用媒体查询**</span><br><span class="line"></span><br><span class="line">- 媒体查询的引用方法</span><br><span class="line"></span><br><span class="line">  - **link**标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">&lt;link rel=&#x27;stylesheet&#x27; media=&#x27;screen and (max-width:800px)&#x27; href=&#x27;index.css&#x27;&gt; </span><br><span class="line"></span><br><span class="line">媒体类型（Media Type）：all（全部）、screen（屏幕）、print（页面打印或打印预览模式）</span><br><span class="line"></span><br><span class="line">媒体特性（Media features）：width（渲染区宽度）、device-width（设备宽度）</span><br></pre></td></tr></table></figure></li><li><p><code>Media Query</code>是<code>CSS3</code>对<code>Media Type</code>的增强版，其实可以将<code>Media Query</code>堪称<code>Media Type</code>（判断条件）+ <code>CSS</code>（符合条件的样式规则）</p></li><li><p><strong>@import</strong></p><ul><li><p><strong>@media</strong></p><ul><li><code>@media screen and (max-width:800px) and (min-width:600px) &#123;&#125;</code></li></ul></li></ul></li></ul><h3 id="媒体类型（Media-Type）"><a href="#媒体类型（Media-Type）" class="headerlink" title="媒体类型（Media Type）"></a><strong>媒体类型（Media Type）</strong></h3><table><thead><tr><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>braille</td><td>盲文</td></tr><tr><td>embossed</td><td>盲文打印</td></tr><tr><td>handheld</td><td>手持设备</td></tr><tr><td>print</td><td>文档打印或打印预览模式</td></tr><tr><td>projection</td><td>项目演示，比如幻灯</td></tr><tr><td>screen</td><td>彩色电脑屏幕</td></tr><tr><td>speech</td><td>演讲</td></tr><tr><td>tty</td><td>固定字母间距的网络媒体，比如电传打字机</td></tr><tr><td>tv</td><td>电视</td></tr></tbody></table><h3 id="媒体特性（Media-features）"><a href="#媒体特性（Media-features）" class="headerlink" title="媒体特性（Media features）"></a><strong>媒体特性（Media features）</strong></h3><table><thead><tr><th>属性</th><th>值</th><th>Min/Max</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>整数</td><td>yes</td><td>每种色彩的字节数</td></tr><tr><td>color-index</td><td>整数</td><td>yes</td><td>色彩表中的色彩数</td></tr><tr><td>device-aspect-ratio</td><td>整数/整数</td><td>yes</td><td>宽高比例</td></tr><tr><td>device-height</td><td>length</td><td>yes</td><td>设备屏幕的输出高度</td></tr><tr><td>device-width</td><td>length</td><td>yes</td><td>设备屏幕的输出宽度</td></tr><tr><td>grid</td><td>整数</td><td>no</td><td>是否基于格栅的设备</td></tr><tr><td>height</td><td>length</td><td>yes</td><td>渲染界面的高度</td></tr><tr><td>monochrome</td><td>整数</td><td>yes</td><td>单色帧缓冲器中每像素字节</td></tr><tr><td>resolution</td><td>分辨率（dpi/dpcm）</td><td>yes</td><td>分辨率</td></tr><tr><td>scan</td><td>Progresslve interlaced</td><td>no</td><td>tv媒体类型的扫描方式</td></tr><tr><td>width</td><td>length</td><td>yes</td><td>渲染界面的宽度</td></tr><tr><td>orientation</td><td>Portrait/landscape</td><td>no</td><td>横屏或竖屏</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p><strong>逻辑操作符</strong></p><ul><li>合并多个媒体属性 <code>and</code></li><li><code>@media screen and (min-width:600px) and (max-width:1000px)</code></li><li>合并多个媒体属性或合并媒体属性与媒体类型，一个基本的媒体查询，即一个媒体属性与默认指定的screen媒体类型</li></ul></li><li><p><strong>指定备用功能</strong></p><ul><li>逗号 ,</li><li><code>@media screen and (min-width:769px), print and (min-width:6in)</code></li><li>没有<code>or</code>关键字可用于指定备用的媒体功能。相反，可以将备用功能以逗号分隔列表的形式列出这才会将样式应用到宽度超过769像素的屏幕或使用至少6英寸宽的纸张的打印设备</li></ul></li><li><p><strong>指定否定条件</strong></p><ul><li><code>not</code></li><li><code>@media not screen and (monochrome)</code></li><li>要指定否定条件，可以在媒体声明中添加关键字not，不能再单个条件前使用not。该关键字必须位于声明的开头，而且它会否定整个声明。所以，上面的示例会应用于除单色屏幕外的所有设备</li></ul></li><li><p><strong>向早期浏览器隐藏媒体查询</strong></p><ul><li><code>only</code></li><li><code>media=&#39;only screen and (min-width:401px) and (max-width:600px)&#39;</code></li><li>媒体查询规范还提供了关键字<code>only</code>，它用于向早期浏览器隐藏媒体查询。类似于<code>not</code>，该关键字必须位于声明的开头</li><li>早期浏览器应该将以下语句<code>media=‘screen and (min-width:40px) and (max-width:600px)’ </code>解释为<code>media=&#39;screen&#39;;</code>换句话说，他应该将样式规则应用于所有屏幕设备，即使他不知道媒体查询的含义</li><li>无法识别媒体查询的浏览器要求获得逗号分隔的媒体类型列表，规范要求，它们应该在第一个不是连字符的非数字字母字符之前截断每个值。所以，早期浏览器应该将上面的实例解释为：<code>media=&#39;only&#39;</code></li><li>因为没有<code>only</code>这样的媒体类型，所以样式表被忽略</li></ul></li><li><p><strong>易混淆的宽度</strong></p><ul><li><code>device-width</code>/<code>heighta</code>    <code>width</code>/<code>height</code></li><li><code>device-width</code>/<code>height</code>是设备的宽度（比如电脑手机的宽度，不是浏览器的宽度）</li><li><code>width/height是documentElement.clinetWidth</code>/<code>Height</code>即<code>viewport</code>的值</li></ul></li><li><p><strong>尺寸单位</strong></p><ul><li><p><strong>px</strong></p><ul><li>相对长度单位，相对于显示器屏幕分辨率而言的</li><li>特点<ul><li>IE无法调整那些使用px作为单位的字体大小</li><li>国外的大部分网站能够调整的原因在于其使用了<code>em</code>或<code>rem</code>作为字体单位</li><li>firefox能够调整<code>px</code>和<code>em</code>，<code>rem</code></li></ul></li></ul></li><li><p><strong>em</strong></p><ul><li><p><code>em</code>的值并不是固定的</p></li><li><p><code>em</code>会继承父级元素的字体大小</p></li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=<span class="number">0.</span>75em,10px=<span class="number">0.</span>625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=<span class="number">62.5</span>%，这就使em值变为 16px*<span class="number">62.5</span>%=10px, 这样12px=<span class="number">1.</span>2em, 10px=1em, 也就是说只需要将你的原来的px数值除以<span class="number">10</span>，然后换上em作为单位就行了。</span><br><span class="line"></span><br><span class="line">所以我们在写CSS的时候，需要注意两点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> body选择器中声明Font-size=<span class="number">62.5</span>%；</span><br><span class="line"><span class="number">2.</span> 将你的原来的px数值除以<span class="number">10</span>，然后换上em作为单位；</span><br><span class="line"><span class="number">3.</span> 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。</span><br><span class="line"></span><br><span class="line">也就是避免<span class="number">1.2</span> * <span class="number">1.2</span>= <span class="number">1.44</span>的现象。比如说你在#content中声明了字体大小为<span class="number">1.</span>2em，那么在声明p的字体大小时就只能是1em，而不是<span class="number">1.</span>2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。      </span><br></pre></td></tr></table></figure><ul><li><p><code>1em</code> = <code>1 * font-size</code> = <code>1 * 16px</code></p></li><li><p><code>font-size</code>默认的是<code>16</code>像素</p></li><li><p><strong>rem</strong></p><ul><li><p>相对单位，相对的只是<code>HTML</code>根元素的字体大小</p></li><li><p><code>font size of the root element </code>（根元素的字体大小)</p></li><li><p><code>rem</code>是一种相对长度单位。相对于根元素(即<code>html</code>元素)<code>font-size</code>计算值的倍数。</p></li><li><p>和<code>em</code>不同的是<code>rem</code>总是相对于根元素(如:<code>root</code>{})，而不像em一样使用级联的方式来计算尺寸。这种相对单位使用起来更简单。</p></li><li><p><code>rem</code>支持<code>IE9</code>及以上，意思是相对于根元素<code>html</code>（网页），不会像<code>em</code>那样，依赖于父元素的字体大小，而造成混乱。使用起来安全了很多。</p></li><li><p><strong>注意：</strong> <em>选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</em></p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">font-size: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.wrap &#123;</span><br><span class="line">font-size: <span class="number">1.</span>5rem;</span><br><span class="line"><span class="comment">// 这个时候，.wrap这个元素里面的字体大小就是1.5 * 10px，也就是1.5rem了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录一-像素单位"><a href="#附录一-像素单位" class="headerlink" title="附录一 像素单位"></a>附录一 像素单位</h2><ul><li><p><strong>物理像素和设备独立像素</strong></p><ul><li><p>一个物理像素是显示器（手机屏幕）上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值</p></li><li><p>设备独立像素（也叫目睹无关像素），可以认为是计算机坐标系统的一个点，这个点代表一个可以由程序使用的虚拟像素（<code>css</code>像素），然后由相关系统转换为物理像素</p></li><li><p>设备像素比（<code>device pixel ratio</code>）设备像素比（简称<code>dpr</code>）定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式得到 <em>设备像素值 = 物理像素 / 设备独立像素</em> <code>js</code>中可以通过<code>window.devicePixelRatio</code></p></li><li><p><code>dpr</code>在一些屏幕上是2：1的比例，所以像素值在不同屏幕上的占比是不同的</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.设备宽高为375*667，可以理解为设备独立像素（或css像素）</span><br><span class="line">2.dpr为2，根据上面的计算公式，其物理像素就应该 2 ，为750*1334.</span><br><span class="line"></span><br><span class="line">1css像素在PC端显示器需要用（1*1）个栅格点表示 在iPhone6中则需要4（2*2）个</span><br><span class="line"></span><br><span class="line">也就是在不同的屏幕上（普通屏幕 vs retina屏幕），css像素所呈现的大小（物理尺寸）是一致的，不同的是一个css像素所对象的物理像素个数是不一致</span><br><span class="line"></span><br><span class="line">在普通的屏幕下，1个css像素对应的1个物理像素 为1:1 。在retina屏幕下，1个css像素对应4个物理像素 1:4</span><br></pre></td></tr></table></figure><ul><li><p><strong>位图像素</strong></p></li><li><p>1个位图像素是栅格图像（如：<code>png</code>，<code>jpg</code>，<code>gif</code>等）最小的数据单元，每一个位图像素都包括着一些资深的现实信息（如：显示位置，颜色值，透明度等）</p></li><li><p>在普通屏幕下是没有问题的，但是在<code>retina</code>屏幕下就会出现位图像素点不够，从而导致图片模糊的情况</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于dpr=2的，1个位图像素对应4个物理像素，由于单个位图像素不以再进一步分割，所以只能就近取色，从而导致图片模糊</span><br><span class="line"></span><br><span class="line">解决办法，使用分辨率大两倍的图片，如200*300 img 标签，就需要提供400*600的图片.由此一来位图像素点的个数是原来的4倍，在retina屏幕下，位图像素点个数就可以物理像素点个数形成1:1 的比例，图片自然就清晰了。</span><br><span class="line"></span><br><span class="line">如果普通屏幕下，也用了两倍的图片，会怎么样，很明显，在普通屏幕下，200*300(css pixel)img标签，所对应的物理像素个数就是200*300个，而两倍图片的位图像素个数则是200*300*4，所以就出现了一个像物理像素点对应4个为图像素点，所以它的取色也只能通过——定的算法（显示结果就是一张只有原图像素总数四分之一，我们称这个过程叫做downsampling），肉眼看上去这个图片不会模糊，但是会觉得图片缺少一些锐利度，或者是有点色差（还是可以接受的）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录二-浏览器渲染原理"><a href="#附录二-浏览器渲染原理" class="headerlink" title="附录二 浏览器渲染原理"></a>附录二 浏览器渲染原理</h2><ol><li>处理<code>HTML</code> 生成<code>DOM</code>树</li><li>处理<code>CSS </code>生成<code>CSSDOM</code>树</li><li>将两个数合并成<code>render</code>树</li><li>对<code>render</code>树进行布局计算</li><li>将<code>render</code>树中的每一个节点绘制在屏幕上</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">细化分析：</span><br><span class="line">1.浏览器把获取到的html代码解析成1个Dom树，html中的每个tag都是Dom树中的1个节点，根节点就是我们常用的document对象(&lt;html&gt; tag)，当然这里包含用js动态创建的dom节点</span><br><span class="line"></span><br><span class="line">2浏览器把所有样式(主要包括css和浏览器的默认样式设置)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，生成CSSDOM树</span><br><span class="line"></span><br><span class="line">3.DOM tree和CSSDOM tree 合并成 render tree，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有无样式head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。</span><br><span class="line"></span><br><span class="line">4.render tree构建完毕之后根据样式计算布局，布局阶段的输出结果称为 “盒模型”（box model）。盒模型精确表达了窗口中每个元素的位置和大小，而且所有的相对的度量单位都被转化成了屏幕上的绝对像素位置 (根据css2的标准，render tree中的每个节点都称为box(Box dimensions----盒子模型)，box所有属性：width,height,margin,padding,left,top,border等。)</span><br><span class="line"></span><br><span class="line">5.将这些信息渲染为屏幕上每个真实的像素点了。这个阶段称为“绘制”，或者“栅格化”（rasterizing）。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111709570.png"></p><ul><li><p>重绘、重排</p><ul><li><p>重排，我们在计算它们在当前设备中准确的位置和尺寸。这正是布局阶段要做的工作，该阶段在英语中也成为“回流”（<code>reflow</code>），当<code>render tree</code>中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。也会回流（其实我觉得叫重新布局更简单明了一些）。每个页面至少需要一次回流，就是在页面第一次加载的时候</p></li><li><p>重绘（<code>repaints</code>）当<code>render tree</code>中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如<code>background-color</code>,则就叫重绘</p></li><li><p>重绘，重排会影响性能</p><ul><li>在<code>chrome</code>中有一个<code>Performance</code>面板，它可以计算从开始到绘制完成花费了多少时间</li><li>蓝色：网络通信和<code>HTML</code>解析</li><li>黄色：<code>JavaScript</code>执行</li><li>紫色：样式计算和布局，即重排</li><li>绿色：重绘</li></ul></li><li><p>触发重排的方法：</p><ul><li><p>以下这些属性和方法需要返回最新的布局信息，重新计算渲染树，就会造成回流，触发重排以返回正确的值，建议将她们合并到一起操作，可以减少回流次数，这些属性包括：</p></li><li><p><code>offsetTop</code>/<code>Left</code>、<code>offsetWidth</code>/<code>Height</code>、<code>scrollTop</code>/<code>Left</code>/<code>Width</code>/<code>Height</code>、<code>clientTop</code>/<code>Left</code>/<code>Width</code>/<code>Height</code>、<code>getComputedStyle()</code>、<code>currentStyle</code></p></li><li><p>提高网页性能，就是要降低“重排”和重绘的频率和成本，尽量少触发重新渲染。DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染</p></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.style.color=<span class="string">&#x27;red&#x27;</span></span><br><span class="line">div.style.background=<span class="string">&quot;yellow&quot;</span></span><br><span class="line">div.style.left=<span class="string">&#x27;10px&#x27;</span></span><br><span class="line">div.style.width=<span class="string">&#x27;20px&#x27;</span></span><br><span class="line"></span><br><span class="line">浏览器最低触发一次重排和重绘</span><br><span class="line"></span><br><span class="line">一般来说，样式的写操作之后，如果有上面那些属性的读操作，都会引发浏览器立即重排，这种重排，不会形成之前队列优化</span><br><span class="line"></span><br><span class="line">div.style.color = ‘red’;</span><br><span class="line"><span class="keyword">var</span> height = div.offseHeight;</span><br><span class="line">div.style.height = height + ‘px’;</span><br><span class="line"></span><br><span class="line">Bad：</span><br><span class="line">div.style.left = div.offsetLeft + ‘px’;</span><br><span class="line">div.style.top = div.offsetTop + ‘px’;</span><br><span class="line">重排重绘两次</span><br><span class="line"><span class="attr">Good</span>:</span><br><span class="line">Var left = div.offsetLeft + ‘px’;</span><br><span class="line">Var top = div.offsetTop + ‘px’;</span><br><span class="line"></span><br><span class="line">div.style.left = left;</span><br><span class="line">div.style.top = top;</span><br><span class="line">放到队列，一起执行重排重绘一次</span><br><span class="line"></span><br><span class="line">我们来测试一下js动态添加<span class="number">10000</span>个li 不同颜色而且设置宽度 所耗费render painting 的时间吧</span><br></pre></td></tr></table></figure><ul><li><p>理论上的结局优化方法</p><ul><li>说到的<code>DOM</code>的多个读写操作，应该放在一起，不要两个读操作之间，加入一个写操作</li><li>离线操作<code>DOM</code>如使用隐藏元素 <code>document.createDocumentFragment()</code>/ <code>cloneNode() </code></li><li>修改样式的时候添加类名，或一次性添加到<code>dom.style.cssText</code>上等</li><li>以上都是理论上的加速方法</li></ul></li></ul><h2 id="附录三-css3响应式布局"><a href="#附录三-css3响应式布局" class="headerlink" title="附录三 css3响应式布局"></a>附录三 css3响应式布局</h2><hr><ul><li><p>媒体类型</p><ul><li> <code>*all</code> 所有媒体</li><li> <code>braille</code> 盲文触觉设备</li><li> <code>embossed</code> 盲文打印机</li><li> <code>*print</code> 手持设备 </li><li> <code>projection</code> 打印预览</li><li> <code>*screen</code> 彩屏设备</li><li> <code>speech</code> ‘听觉’类似的媒体类型</li><li> <code>tty </code>不适用像素的设备</li><li> <code>tv </code> 电视</li></ul></li><li><p>关键字</p><ul><li> <code>and </code></li><li> <code>not  </code>    <code>not</code>关键字是用来排除某种制定的媒体类型</li><li> <code>only</code>     <code>only</code>用来定某种特定的媒体类型</li></ul></li><li><p>媒体特性</p><ul><li> <code>(max-width:600px) </code></li><li> <code>(max-device-width: 480px) </code>     设备输出宽度</li><li> <code>(orientation:portrait)</code>          竖屏</li><li> <code>(orientation:landscape)</code>        横屏</li><li> <code>(-webkit-min-device-pixel-ratio: 2)</code> 像素比</li><li> <code>devicePixelRatio</code>             设备像素比 </li><li> <code>window.devicePixelRatio = 物理像素 / dips</code></li></ul></li><li><p>样式引入</p></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index<span class="selector-class">.css</span>&quot; media=&quot;print&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;css/demo.css&quot;</span>) screen;</span><br><span class="line"><span class="keyword">@media</span> screen&#123;    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=”stylesheet” media=”all and</span><br><span class="line"> (orientation:portrait)” href=”portrait.css”&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=”stylesheet” media=”all</span><br><span class="line"> and (orientation:landscape)”href=”landscape.css”&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">360px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">500px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; </span><br><span class="line">href=&quot;indexA<span class="selector-class">.css</span>&quot;  media=&quot;screen and (<span class="attribute">min-width</span>: <span class="number">800px</span>)<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; </span><br><span class="line">href=&quot;indexB<span class="selector-class">.css</span>&quot; media=&quot;screen and (<span class="attribute">min-width</span>: <span class="number">600px</span>) and (max-width: <span class="number">800px</span>)<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; </span><br><span class="line">href=&quot;indexC<span class="selector-class">.css</span>&quot;    media=&quot;screen and (<span class="attribute">max-width</span>: <span class="number">600px</span>)<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTML5&quot;&gt;&lt;a href=&quot;#HTML5&quot; class=&quot;headerlink&quot; title=&quot;HTML5&quot;&gt;&lt;/a&gt;HTML5&lt;/h1&gt;&lt;h2 id=&quot;HTML5结构&quot;&gt;&lt;a href=&quot;#HTML5结构&quot; class=&quot;headerlink&quot; title=&quot;HTML5结构&quot;&gt;&lt;/a&gt;HTML5结构&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HTML5&lt;/code&gt; 是新一代的 &lt;code&gt;HTML&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DTD&lt;/code&gt;声明改变    &lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;新的结构标签            &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--文档申明 文档类型申明，html代表html5的文档类型--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE &lt;span class=&quot;meta-keyword&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--字符编码，charset=&amp;#x27;utf-8&amp;#x27;--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf-8&amp;#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	版本兼容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;		1.省略引号，当属性值（&amp;lt;、&amp;gt;、=、单引号、双引号、空字符串）时，属性两边的引号可以省略，如&amp;lt;input type=text&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;		2.省略属性值，具有布尔值的属性，比如disabled，readonly，致谢属性值代表true，如：&amp;lt;input type=checkbox checked&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="HTML and CSS" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/HTML-and-CSS/"/>
    
    
    <category term="HTML and CSS" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/HTML-and-CSS/"/>
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/webpack/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/webpack/</id>
    <published>2021-11-08T07:35:53.000Z</published>
    <updated>2022-05-17T01:12:47.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="模块化简介"><a href="#模块化简介" class="headerlink" title="模块化简介"></a>模块化简介</h4><ul><li>具有相同属性和行为的事物的集合。在前端中，将一些属性比较类似和行为比较类似的内容放在同一个<code>js</code>文件里面，把这个<code>js</code>文件称为模块，为了每个<code>js</code>文件只关注与自身有关的事情，让每个<code>js</code>文件各行其职。</li><li>模块要有几个特点： 独立、完整、依赖关系</li><li>在最开始的阶段，<code>Js</code>并没有这些模块机制，各种<code>Js</code>到处飞，也就是你们现在的野生代码，得不到有效妥善的管理。后来前端圈开始制定规范，最耳熟能详的是<code>CommonJs</code>和<code>AMD</code>。</li></ul><span id="more"></span><h4 id="模块化的代码实现"><a href="#模块化的代码实现" class="headerlink" title="模块化的代码实现"></a>模块化的代码实现</h4><ul><li>函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.函数，缺点：大型功能无法实现</span></span><br><span class="line"><span class="comment">//功能1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//功能2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.对象写法，缺点：外面可访问并改变ppt对象中变量</span></span><br><span class="line"><span class="keyword">var</span> ppt = &#123;</span><br><span class="line">    <span class="attr">len</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">init</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">crateDom</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名函数、返回对象</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名函数，返回对象</span></span><br><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">add</span>:add</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="built_in">console</span>.log(obj.add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><ul><li>依赖传入实参</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    md.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module || &#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>以上缺点依赖关系不好处理，需要按顺序加载，会阻塞页面</li></ul><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ul><li><p>根<code>CommonJs</code>规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。</p></li><li><p>该规范最初是用在服务器端的node的，前端的<code>webpack</code>也是对<code>CommonJS</code>原生支持的。</p></li><li><p><code>CommonJS</code>的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 <code>module.exports</code> 来导出需要暴露的接口</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111729006.png"></p></li><li><p>浏览器不兼容<code>CommonJs</code>，原因是浏览器缺少<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>四个环境变量。如要使用需要工具转换</p></li><li><p><code>CommonJS</code>采用同步加载不同模块文件，适用于服务器端的。因为模块文件都存放在服务器的各个硬盘上，读取加载时间快，适合服务器端，不适应浏览器。</p></li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ul><li><p><code>CommonJs</code>为服务器端而生，采用的同步加载方式。因此不适用浏览器。因为浏览器需要到服务器加载文件，请求时间远大于本机读取的时间，倘若文件较多，网络迟缓就会导致页面瘫痪，所以浏览器更希望能够时间异步加载的方式。</p></li><li><p><code>AMD</code>规范则是异步加载模块，允许指定回调函数。等模块异步加载完成后即可调用回调函数。<code>AMD</code>得意的产出就是<code>require.js</code></p></li><li><p>AMD的核心思想就是通过<code>define</code>来定义一个模块，然后使用require来加载一个模块。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111730270.png"></p></li><li><p>使用<code>require.js</code>，提前加载所有依赖，方可使用</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111730026.png"></p></li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><ul><li><code>CMD</code>异步加载，跟<code>AMD</code>的主要区别在于，<code>AMD</code>依赖前置，提前加载依赖。而<code>CMD</code>就近加载，按需加载。</li><li>产物<code>seaJs</code>，跟<code>requireJs</code>使用有些相似。</li><li><code>CMD</code>的核心思想就是通过<code>define</code>来定义一个模块，然后使用<code>require</code>来加载一个模块。</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111730812.png"></li></ul><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul><li><code>ES6</code>自带模块化，可以使用 <code>import</code> 关键字引入模块，通过 <code>export</code> 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于<code>ES6</code>目前无法在浏览器中执行，所以，我们只能通过<code>babel</code>将不被支持的<code>import</code>编译为当前受到广泛支持的 <code>require</code>。</li><li>使用 <code>import</code> 关键字引入模块，通过 <code>export</code> 关键字导出模块</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111730242.png"></li></ul><h4 id="模块化详细介绍"><a href="#模块化详细介绍" class="headerlink" title="模块化详细介绍"></a>模块化详细介绍</h4><p>本门课需要的前置知识：<code>ES6</code>、模块化、包管理器、<code>git</code></p><p>本门课的讲解特点：</p><ol><li>合适的深度：<code>webpack</code>使用层面很简单，但原理层面非常复杂</li><li>合适的广度：<code>webpack</code>生态圈极其繁荣，有海量的第三方库可以融入到<code>webpack</code></li></ol><h5 id="浏览器端的模块化"><a href="#浏览器端的模块化" class="headerlink" title="浏览器端的模块化"></a>浏览器端的模块化</h5><p>问题：</p><ul><li>效率问题：精细的模块划分带来了更多的<code>JS</code>文件，更多的<code>JS</code>文件带来了更多的请求，降低了页面访问效率</li><li>兼容性问题：浏览器目前仅支持<code>ES6</code>的模块化标准，并且还存在兼容性问题</li><li>工具问题：浏览器不支持<code>npm</code>下载的第三方包</li></ul><p>这些仅仅是前端工程化的一个缩影</p><p>当开发一个具有规模的程序，你将遇到非常多的非业务问题，这些问题包括：执行效率、兼容性、代码的可维护性可扩展性、团队协作、测试等等等等，我们将这些问题称之为工程问题。工程问题与业务无关，但它深刻的影响到开发进度，如果没有一个好的工具解决这些问题，将使得开发进度变得极其缓慢，同时也让开发者陷入技术的泥潭。</p><h5 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h5><p>思考：上面提到的问题，为什么在<code>node</code>端没有那么明显，反而到了浏览器端变得如此严重呢？</p><p>答：在node端，运行的JS文件在本地，因此可以本地读取文件，它的效率比浏览器远程传输文件高的多</p><p><strong>根本原因</strong>：在浏览器端，开发时态（<code>devtime</code>）和运行时态（runtime）的侧重点不一样</p><p><strong>开发时态，devtime：</strong></p><ol><li>模块划分越细越好</li><li>支持多种模块化标准</li><li>支持<code>npm</code>或其他包管理器下载的模块</li><li>能够解决其他工程化的问题</li></ol><p><strong>运行时态，runtime：</strong></p><ol><li>文件越少越好</li><li>文件体积越小越好</li><li>代码内容越乱越好</li><li>所有浏览器都要兼容</li><li>能够解决其他运行时的问题，主要是执行效率问题</li></ol><p>这种差异在小项目中表现的并不明显，可是一旦项目形成规模，就越来越明显，如果不解决这些问题，前端项目形成规模只能是空谈</p><h5 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h5><p>既然开发时态和运行时态面临的局面有巨大的差异，因此，我们需要有一个工具，这个工具能够让开发者专心的在开发时态写代码，然后利用这个工具将开发时态编写的代码转换为运行时态需要的东西。</p><p>说到构建工具，我往往会在前面加「自动化」三个字，因为构建工具就是用来让我们不再做机械重复的事情，解放我们的双手的。</p><p>要完成前端工程化，少不了工程化工具，<code>requireJS</code>与<code>grunt</code>的出现，改变了业界前端代码的编写习惯，同时他们也是推动前端工程化的一个基础。</p><p><code>requireJS</code>是一伟大的模块加载器，他的出现让<code>javascript</code>制作多人维护的大型项目变成了事实；<code>grunt</code>是一款<code>javascript</code>构建工具，主要完成编译、压缩、合并等一系列工作，后续又出了<code>yeoman</code>、<code>Gulp</code>、<code>webpack</code>等构建工具。</p><p><code>Webpack</code>具有<code>Grunt</code>、<code>Gulp</code>对于静态资源自动化构建的能力，但更重要的是，<code>Webpack</code>弥补了<code>requireJS</code>在模块化方面的缺陷，同时兼容<code>AMD</code>与<code>CMD</code>的模块加载规范，具有更强大的JS模块化的功能。</p><p>这样的工具，叫做<strong>构建工具</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111731192.png"></p><p>这样一来，开发者就可以专注于开发时态的代码结构，而不用担心运行时态遇到的问题了。</p><h6 id="自动化构建工具的两种模式"><a href="#自动化构建工具的两种模式" class="headerlink" title="自动化构建工具的两种模式"></a>自动化构建工具的两种模式</h6><ul><li><p>开发模式</p><ul><li>开发模式比较简单，主要就是监听文件变化，自动进行打包、合并的操作。</li></ul></li><li><p>生产模式</p><ul><li>参考我们的技术栈与需求，我们的静态文件都要发布到<code>cdn</code>上，而且必须有<code>md5</code>版本号，方便快速发布(<code>cdn</code>更新极其缓慢，所以更新必须使用新的文件名)</li><li>生产模式主要增加了文件压缩、文件<code>md5</code>名修改、替换<code>html</code>等操作，这样的好处就是上线非常方便，一个命令即可更新线上，而且不存在缓存问题。</li></ul></li></ul><h6 id="常见的构建工具"><a href="#常见的构建工具" class="headerlink" title="常见的构建工具"></a>常见的构建工具</h6><ul><li><strong>webpack</strong></li><li><strong>grunt</strong></li><li><strong>gulp</strong></li><li><strong>browserify</strong></li><li><strong>fis</strong></li><li><strong>其他</strong></li></ul><h5 id="cdn"><a href="#cdn" class="headerlink" title="cdn"></a>cdn</h5><ul><li><code>CDN</code>是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。<code>CDN</code>的关键技术主要有内容存储和分发技术。</li><li><code>CDN</code>的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</li><li><code>CDN</code>网络是在用户和服务器之间增加<code>Cache</code>层，如何将用户的请求引导到<code>Cache</code>上获得源服务器的数据，主要是通过接管<code>DNS</code>实现，这就是<code>CDN</code>的最基本的原理</li><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111731009.png"></li><li>1.用户向浏览器输入<code>www.web.com</code>这个域名，浏览器第一次发现本地没有<code>dns</code>缓存，则向网站的<code>DNS</code>服务器请求；</li><li>2.网站的<code>DNS</code>域名解析器设置了<code>CNAME</code>，指向了<code>www.web.51cdn.com</code>,请求指向了<code>CDN</code>网络中的智能<code>DNS</code>负载均衡系统；</li><li>3.智能<code>DNS</code>负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；</li><li>4.用户向该<code>IP</code>节点（<code>CDN</code>服务器）发出请求；</li><li>5.由于是第一次访问，<code>CDN</code>服务器会向原<code>web</code>站点请求，并缓存内容；</li><li>6.请求结果发给用户</li></ul><h4 id="模块化兼容性"><a href="#模块化兼容性" class="headerlink" title="模块化兼容性"></a>模块化兼容性</h4><p>由于<code>webpack</code>同时支持<code>CommonJS</code>和<code>ES6 module</code>，因此需要理解它们互操作时<code>webpack</code>是如何处理的</p><h5 id="同模块化标准"><a href="#同模块化标准" class="headerlink" title="同模块化标准"></a>同模块化标准</h5><p>如果导出和导入使用的是同一种模块化标准，打包后的效果和之前学习的模块化没有任何差异</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111731465.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111731489.png"></p><h5 id="不同模块化标准"><a href="#不同模块化标准" class="headerlink" title="不同模块化标准"></a>不同模块化标准</h5><p>不同的模块化标准，<code>webpack</code>按照如下的方式处理</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111733508.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111733185.png"></p><h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h5><p>代码编写最忌讳的是精神分裂，选择一个合适的模块化标准，然后贯彻整个开发阶段。</p><h3 id="为什么要用webpack"><a href="#为什么要用webpack" class="headerlink" title="为什么要用webpack"></a>为什么要用webpack</h3><ul><li><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111733729.png"></li></ul><p>前端需要模块化：<code>JS</code>模块化不仅仅为了提高代码复用性，多人协作开发项目，更是为了让资源文件更合理地进行缓存.</p><p>大家可以回头看下<code>Webpack</code>官方实例图，有一点不知道大家是否注意到：<code>Webpack</code>处理后，输出的静态文件只剩下<code>js</code>与<code>png</code>，而<code>css</code>、<code>less</code>、<code>jade</code>其他的文件都合并到了<code>js</code>中。</p><p>在<code>Webpack</code>当中，所有资源的都是模块，模块都需要通过<code>AMD</code>或者<code>CMD</code>规范加载，就像<code>css</code>样式文件，不再在<code>HTML</code>中以<code>&lt;link&gt;</code>标签加载。</p><ul><li>功能/特性<ul><li>支持<code>CommonJs</code>和<code>AMD</code>模块，意思也就是我们基本可以无痛迁移旧项目。</li><li>支持模块加载器和插件机制，可对模块灵活定制。特别是我最爱的<code>babel-loader</code>，有效支持<code>ES6</code>。</li><li>可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。</li><li>将样式文件和图片等静态资源也可视为模块进行打包。配合<code>loader</code>加载器，可以支持<code>less</code>等<code>CSS</code>预处理器。</li><li>内置有<code>source map</code>，即使打包在一起依旧方便调试</li></ul></li><li>总结：<ul><li>任何静态资源都可以视作模块，然后模块之间也可以相互依赖，通过<code>webpack</code>对模块进行处理后，可以打包成我们想要的静态资源。</li></ul></li></ul><h3 id="初探webpack"><a href="#初探webpack" class="headerlink" title="初探webpack"></a>初探webpack</h3><blockquote><p>webpack官网：<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a></p></blockquote><h4 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h4><p><code>webpack</code>是基于模块化的打包（构建）工具，它把一切视为模块</p><p>它通过一个开发时态的入口模块为起点，分析出所有的依赖关系，然后经过一系列的过程（压缩、合并），最终生成运行时态的文件。</p><p><code>webpack</code>的特点：</p><ul><li><strong>为前端工程化而生</strong>：<code>webpack</code>致力于解决前端工程化，特别是浏览器端工程化中遇到的问题，让开发者集中注意力编写业务代码，而把工程化过程中的问题全部交给<code>webpack</code>来处理</li><li><strong>简单易用</strong>：支持零配置，可以不用写任何一行额外的代码就使用<code>webpack</code></li><li><strong>强大的生态</strong>：<code>webpack</code>是非常灵活、可以扩展的，<code>webpack</code>本身的功能并不多，但它提供了一些可以扩展其功能的机制，使得一些第三方库可以融于到<code>webpack</code>中</li><li><strong>基于nodejs</strong>：由于<code>webpack</code>在构建的过程中需要读取文件，因此它是运行在<code>node</code>环境中的</li><li><strong>基于模块化</strong>：<code>webpack</code>在构建过程中要分析依赖关系，方式是通过模块化导入语句进行分析的，它支持各种模块化标准，包括但不限于<code>CommonJS</code>、<code>ES6</code>、<code>Module</code></li></ul><h4 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h4><p><code>webpack</code>通过<code>npm</code>安装，它提供了两个包：</p><ul><li><p><code>webpack</code>：核心包，包含了<code>webpack</code>构建过程中要用到的所有api</p></li><li><p><code>webpack-cli</code>：提供一个简单的<code>cli</code>命令，它调用了<code>webpack</code>核心包的<code>api</code>，来完成构建过程</p></li><li><p><strong>安装方式</strong>：</p><ul><li><strong>全局安装</strong>：可以全局使用<code>webpack</code>命令，但是无法为不同项目对应不同的<code>webpack</code>版本<ul><li><code>npm install webpack -global</code></li><li><code>npm install -global webpack-cli</code></li></ul></li><li><strong>本地安装</strong>：推荐，每个项目都使用自己的<code>webpack</code>版本进行构建<ul><li><code>npm install --save-dev webpack</code></li><li><code>npm install webpack webpack-cli --save-dev</code></li></ul></li></ul></li><li><p>初始化</p><ul><li>在<code>cmd</code>命令窗口进入项目文件夹</li><li>输入<code>npm init</code>，一路回车</li></ul></li><li></li></ul><h3 id="webpack-编译过程"><a href="#webpack-编译过程" class="headerlink" title="webpack 编译过程"></a>webpack 编译过程</h3><p><code>webpack</code> 的作用是将源代码编译（构建、打包）成最终代码</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111734811.png"></p><p>整个过程大致分为三个步骤</p><ol><li>初始化</li><li>编译</li><li>输出</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111734083.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>此阶段，<code>webpack</code>会将<strong>CLI参数</strong>、<strong>配置文件</strong>、<strong>默认配置</strong>进行融合，形成一个最终的配置对象。</p><p>对配置的处理过程是依托一个第三方库<code>yargs</code>完成的</p><p>此阶段相对比较简单，主要是为接下来的编译阶段做必要的准备</p><p>目前，可以简单的理解为，初始化阶段主要用于产生一个最终的配置</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ol><li><strong>创建chunk</strong></li></ol><p><code>chunk</code>是<code>webpack</code>在内部构建过程中的一个概念，译为块，它表示通过某个入口找到的所有依赖的统称。</p><p>根据入口模块（默认为<code>https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js</code>）创建一个chunk</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111734800.png"></p><p>每个<code>chunk</code>都有至少两个属性：</p><ul><li><code>name</code>：默认为<code>main</code></li><li><code>id</code>：唯一编号，开发环境和name相同，生产环境是一个数字，从<code>0</code>开始</li></ul><ol start="2"><li><strong>构建所有依赖模块</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111741933.png"></p><blockquote><p>AST在线测试工具：<a href="https://astexplorer.net/">https://astexplorer.net/</a></p></blockquote><p>简图</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111741536.png"></p><ol start="3"><li><strong>产生chunk assets</strong></li></ol><p>在第二步完成后，<code>chunk</code>中会产生一个模块列表，列表中包含了<strong>模块id</strong>和<strong>模块转换后的代码</strong></p><p>接下来，<code>webpack</code>会根据配置为<code>chunk</code>生成一个资源列表，即<code>chunk assets</code>，资源列表可以理解为是生成到最终文件的文件名和文件内容</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111741429.png"></p><blockquote><p>chunk hash是根据所有chunk assets的内容生成的一个hash字符串<br>hash：一种算法，具体有很多分类，特点是将一个任意长度的字符串转换为一个固定长度的字符串，而且可以保证原始内容不变，产生的hash字符串就不变</p></blockquote><p>简图</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742646.png"></p><ol start="4"><li><strong>合并chunk assets</strong></li></ol><p>将多个<code>chunk</code>的<code>assets</code>合并到一起，并产生一个总的<code>hash</code></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742987.png"></p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>此步骤非常简单，<code>webpack</code>将利用<code>node</code>中的<code>fs</code>模块（文件处理模块），根据编译产生的总的<code>assets</code>，生成相应的文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742982.png"></p><h4 id="总过程"><a href="#总过程" class="headerlink" title="总过程"></a>总过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742793.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742718.png"></p><p><strong>涉及术语</strong></p><ol><li><code>module</code>：模块，分割的代码单元，<code>webpack</code>中的模块可以是任何内容的文件，不仅限于<code>JS</code></li><li><code>chunk</code>：<code>webpack</code>内部构建模块的块，一个<code>chunk</code>中包含多个模块，这些模块是从入口模块通过依赖分析得来的</li><li><code>bundle</code>：<code>chunk</code>构建好模块后会生成<code>chunk</code>的资源清单，清单中的每一项就是一个<code>bundle</code>，可以认为<code>bundle</code>就是最终生成的文件</li><li><code>hash</code>：最终的资源清单所有内容联合生成的<code>hash</code>值</li><li><code>chunkhash</code>：<code>chunk</code>生成的资源清单内容联合生成的<code>hash</code>值</li><li><code>chunkname</code>：<code>chunk</code>的名称，如果没有配置则使用<code>main</code></li><li><code>id</code>：通常指<code>chunk</code>的唯一编号，如果在开发环境下构建，和<code>chunkname</code>相同；如果是生产环境下构建，则使用一个从<code>0</code>开始的数字进行编号</li></ol><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><h4 id="入口和出口是什么"><a href="#入口和出口是什么" class="headerlink" title="入口和出口是什么"></a>入口和出口是什么</h4><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742520.png"></p><blockquote><p>node内置模块 - path: <a href="https://nodejs.org/dist/latest-v12.x/docs/api/path.html">https://nodejs.org/dist/latest-v12.x/docs/api/path.html</a></p></blockquote><p><strong>出口</strong></p><p>这里的出口是针对资源列表的文件名或路径的配置</p><p>出口通过<code>output</code>进行配置</p><p><strong>入口</strong></p><p><strong>入口真正配置的是chunk</strong></p><p>入口通过entry进行配置</p><p>规则：</p><ul><li><code>name</code>：<code>chunkname</code></li><li><code>hash</code>: 总的资源<code>hash</code>，通常用于解决缓存问题</li><li><code>chunkhash</code>: 使用<code>chunkhash</code></li><li><code>id</code>: 使用<code>chunkid</code>，不推荐</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    <span class="comment">//入口</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="comment">//属性名：chunk的名称， 属性值：入口模块（启动模块）</span></span><br><span class="line">        <span class="attr">main</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>, </span><br><span class="line">        <span class="comment">//启动模块有两个</span></span><br><span class="line">        <span class="attr">a</span>: [<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/a.js&quot;</span>, <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>] </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//出口</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//必须配置一个绝对路径，表示资源放置的文件夹，默认是dist</span></span><br><span class="line">        <span class="comment">//_dirname: 所有情况下，都表示当前运行的js文件所在的目录，它是一个绝对路径</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;target&quot;</span>), </span><br><span class="line">        <span class="comment">//配置的合并的js文件的规则</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[id].[chunkhash:5].js&quot;</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入口和出口的最佳实践"><a href="#入口和出口的最佳实践" class="headerlink" title="入口和出口的最佳实践"></a>入口和出口的最佳实践</h4><p>具体情况具体分析</p><p>下面是一些经典场景</p><h5 id="一个页面一个JS"><a href="#一个页面一个JS" class="headerlink" title="一个页面一个JS"></a>一个页面一个JS</h5><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742334.png"></p><p>源码结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|—— src</span><br><span class="line">    |—— pageA   页面A的代码目录</span><br><span class="line">        |—— index.js 页面A的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— pageB   页面B的代码目录</span><br><span class="line">        |—— index.js 页面B的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— pageC   页面C的代码目录</span><br><span class="line">        |—— main1.js 页面C的启动模块1 例如：主功能</span><br><span class="line">        |—— main2.js 页面C的启动模块2 例如：实现访问统计的额外功能</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— common  公共代码目录</span><br><span class="line">        |—— ...</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code>配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>:&#123;</span><br><span class="line">        <span class="attr">pageA</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/pageA/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">pageB</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/pageB/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">pageC</span>: [<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/pageC/main1.js&quot;</span>, <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/pageC/main2.js&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&quot;[name].[chunkhash:5].js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式适用于页面之间的功能差异巨大、公共代码较少的情况，这种情况下打包出来的最终代码不会有太多重复</p><h5 id="一个页面多个JS"><a href="#一个页面多个JS" class="headerlink" title="一个页面多个JS"></a>一个页面多个JS</h5><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742598.png"></p><p>源码结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|—— src</span><br><span class="line">    |—— pageA   页面A的代码目录</span><br><span class="line">        |—— index.js 页面A的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— pageB   页面B的代码目录</span><br><span class="line">        |—— index.js 页面B的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— statistics   用于统计访问人数功能目录</span><br><span class="line">        |—— index.js 启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— common  公共代码目录</span><br><span class="line">        |—— ...</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code>配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>:&#123;</span><br><span class="line">        <span class="attr">pageA</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/pageA/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">pageB</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/pageB/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">statistics</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/statistics/index.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&quot;[name].[chunkhash:5].js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式适用于页面之间有一些<strong>独立</strong>、相同的功能，专门使用一个chunk抽离这部分JS有利于浏览器更好的缓存这部分内容。</p><blockquote><p>思考：为什么不使用多启动模块的方式？</p></blockquote><h5 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h5><p>所谓单页应用，是指整个网站（或网站的某一个功能块）只有一个页面，页面中的内容全部靠JS创建和控制。 <code>vue</code>和<code>react</code>都是实现单页应用的利器。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742157.png"></p><p>源码结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|—— src</span><br><span class="line">    |—— subFunc   子功能目录</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— subFunc   子功能目录</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— common  公共代码目录</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— index.js</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code>配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&quot;index.[hash:5].js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件-打包项目"><a href="#配置文件-打包项目" class="headerlink" title="配置文件/打包项目"></a>配置文件/打包项目</h4><ul><li><p>默认情况下，<code>webpack</code>会以<code>https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js</code>作为入口文件分析依赖关系，打包到<code>https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/dist/main.js</code>文件中</p></li><li><p><code>webpack</code>提供的<code>cli</code>支持很多的参数，例如<code>--mode</code>，但更多的时候，我们会使用更加灵活的配置文件来控制<code>webpack</code>的行为</p></li><li><p>默认情况下，<code>webpack</code>会读取<code>webpack.config.js</code>文件作为配置文件，但也可以通过<code>CLI</code>参数<code>--config</code>来指定某个配置文件</p></li><li><p>配置文件中通过<code>CommonJS</code>模块导出一个对象，对象中的各种属性对应不同的<code>webpack</code>配置</p></li><li><p><code>mode</code>：编译模式，字符串，取值为<code>development</code>或<code>production</code>，指定编译结果代码运行的环境，会影响<code>webpack</code>对编译结果代码格式的处理</p><ul><li>通过<code>--mode</code>选项可以控制<code>webpack</code>的打包结果的运行环境<ul><li>在<code>package.json</code>文件的<code>scripts</code>中添加</li><li><code>&quot;dev&quot;: &quot;webpack --mode development&quot;</code>：开发模式</li><li><code>&quot;build&quot;: &quot;webpack --mode production&quot;</code>：生产模式</li><li>或</li><li>在<code>webpack.config.js</code>中添加</li><li><code>mode:&quot;development&quot;</code>：开发模式</li><li><code>mode:&quot;production&quot;</code>：生产模式</li></ul></li></ul></li><li><p><strong>基本配置：</strong></p></li></ul><ol><li><p>准备好项目文件夹</p></li><li><p>在<code>cmd</code>中进行项目初始化</p><ol><li><code>npm init</code></li></ol></li><li><p>准备好各种项目文件，新建<code>webpack.config.js</code>，进行配置</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    <span class="comment">//入口</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="comment">//属性名：chunk的名称， 属性值：入口模块（启动模块）</span></span><br><span class="line">        <span class="attr">main</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>, </span><br><span class="line">        <span class="comment">//启动模块有两个</span></span><br><span class="line">        <span class="attr">a</span>: [<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/a.js&quot;</span>, <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>] </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//出口</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//必须配置一个绝对路径，表示资源放置的文件夹，默认是dist</span></span><br><span class="line">        <span class="comment">//_dirname: 所有情况下，都表示当前运行的js文件所在的目录，它是一个绝对路径</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;target&quot;</span>), </span><br><span class="line">        <span class="comment">//配置的合并的js文件的规则</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[id].[chunkhash:5].js&quot;</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>配置完成后打包项目，在<code>cmd</code>文件夹路径上进行打包</p><ol><li>全局<ol><li>如：<code>D:\Desktop\webpack1 webpack</code></li><li>使用<code>webpack</code>命令进行打包，打包完成后，在<code>html</code>文件中引入打包好的文件名称</li></ol></li><li>本地<ol><li>如：<code>D:\Desktop\webpack1 npx webpack --config webpack.config.js</code></li><li>使用<code>webpack</code>命令进行打包，打包完成后，在<code>html</code>文件中引入打包好的文件名称</li></ol></li></ol></li></ol><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><blockquote><p>webpack做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>更多的功能需要借助webpack loaders和webpack plugins完成。</p></blockquote><ul><li><code>loader</code>意义：<ul><li>这些加载器主要做一些预处理的工作：比如<code>less</code>，<code>sass</code>等</li></ul></li></ul><h4 id="loader是什么"><a href="#loader是什么" class="headerlink" title="loader是什么"></a>loader是什么</h4><p><code>webpack loader</code>： <code>loader</code>本质上是一个函数，它的作用是将某个源码字符串转换成另一个源码字符串返回。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111742693.png"></p><p><code>loader</code>函数的将在模块解析的过程中被调用，以得到最终的源码。</p><p><strong>全流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111743998.png"></p><p><strong>chunk中解析模块的流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111743185.png"></p><p><strong>chunk中解析模块的更详细流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111743967.png"></p><p><strong>处理loaders流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111743796.png"></p><h4 id="安装loader"><a href="#安装loader" class="headerlink" title="安装loader"></a>安装<code>loader</code></h4><ul><li>我们第一步就是先要安装好各个必须的<code>loader</code>，我们直接看看需要通过<code>npm</code>安装什么。</li><li>安装常用loader的包<ul><li><code>npm install babel-loader babel/runtime @babel/core css-loader style-loader url-loader file-loader less-loader less --save -dev</code> </li></ul></li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><p>我们主要看看<code>module</code>的<code>rules</code>。<code>rules</code>是一个数组，里面的每一个对象都用正则表达式，对应着一种配对方案。比如匹配到<code>js</code>后缀名就用<code>babel-loader</code>，匹配到<code>less</code>后缀名的就先用<code>less</code>，再用<code>css</code>，最后用<code>style</code>处理；不同的处理器<code>user</code>处理，<code>use: [&#39;style-loader&#39;,&#39;css-loader&#39;]</code>。</p></li><li><p><strong>完整配置</strong></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123; <span class="comment">//针对模块的配置，目前版本只有两个配置，rules、noParse</span></span><br><span class="line">        <span class="attr">rules</span>: [ <span class="comment">//模块匹配规则，可以存在多个规则</span></span><br><span class="line">            &#123; <span class="comment">//每个规则是一个对象</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="comment">//匹配的模块正则</span></span><br><span class="line">                use: [ <span class="comment">//匹配到后应用的规则模块</span></span><br><span class="line">                    &#123;  <span class="comment">//其中一个规则</span></span><br><span class="line">                        <span class="comment">//loader模块的路径，该字符串会被放置到require中</span></span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&quot;模块路径&quot;</span>,  <span class="comment">//如css-loader,url-loader...</span></span><br><span class="line">                        <span class="comment">//向对应loader传递的额外参数</span></span><br><span class="line">                        <span class="attr">options</span>: &#123; </span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>简化配置</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123; <span class="comment">//针对模块的配置，目前版本只有两个配置，rules、noParse</span></span><br><span class="line">        <span class="attr">rules</span>: [ <span class="comment">//模块匹配规则，可以存在多个规则</span></span><br><span class="line">            &#123; <span class="comment">//每个规则是一个对象</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="comment">//匹配的模块正则</span></span><br><span class="line">                use: [<span class="string">&quot;模块路径1&quot;</span>, <span class="string">&quot;模块路径2&quot;</span>]<span class="comment">//loader模块的路径，该字符串会被放置到require中，如css-loader,url-loader...</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理样式"><a href="#处理样式" class="headerlink" title="处理样式"></a>处理样式</h4><ul><li><p>安装样式的<code>loader</code></p><ul><li><code>npm install css-loader style-loader</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [&#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/loaders/style-loader&quot;</span>] <span class="comment">//loader的路径</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h4><ul><li><p>我们之前也说，<code>webpack</code>对与静态资源来说，也是看作模块来加载的。<code>CSS</code>我们是已经看过了，那图片是怎么作为模块打包加载进来呢？这里我们可以想到，图片我们是用<code>url-loader</code>加载的。我们在<code>css</code>文件里的<code>url</code>属性，其实就是一种封装处理过<code>require</code>操作。当然我们还有一种方式就是直接对元素的<code>src</code>属性进行<code>require</code>赋值。</p></li><li><p>安装图片相关的<code>loader</code></p><ul><li><code>npm install url-loader file-loader</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;entry.js</span><br><span class="line"><span class="keyword">var</span> oImg = <span class="keyword">new</span> Image();</span><br><span class="line">oImg.src = <span class="built_in">require</span>(<span class="string">&#x27;.https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/img/2.png&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(oImg);</span><br><span class="line"></span><br><span class="line">&gt;webpack.config.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">//开发者模式</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>, </span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png)|(jpg)|(gif)$/</span>, use: [&#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/loaders/img-loader.js&quot;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">limit</span>: <span class="number">3000</span>, </span><br><span class="line">                        <span class="comment">//3000字节以上使用图片，3000字节以内使用base64</span></span><br><span class="line">                        <span class="attr">filename</span>: <span class="string">&quot;img-[contenthash:5].[ext]&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>publicPath</strong></p><ul><li>是像图片这种静态资源 打包后的根路径，当浏览器需要引用输入静态资源文件时， 这个配置项指定输入文件的公共<code>URL</code>地址。在<code>loader</code>中它被嵌入到<code>script</code> 或者 <code>link</code> 标签或者对静态资源的引用里。当文件的<code>href</code> 或者 <code>url()</code>与它在磁盘 上的路径 不一致时就应当用<code>publicPath</code> (像<code>path</code>一样指定) ，这在你想定义把一些或者所有文件放在不同的主机或<code>CDN</code>上时会非常有用</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;index.js&#x27;</span>, <span class="comment">//输出文件名称</span></span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/out/&#x27;</span>,<span class="comment">//当前文件夹的绝对路径</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/out&#x27;</span> <span class="comment">//公共资源地址</span></span><br><span class="line">&#125;,<span class="comment">// 输出文件</span></span><br></pre></td></tr></table></figure><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p><code>loader</code>的功能定位是转换代码，而一些其他的操作难以使用<code>loader</code>完成，比如：</p><ul><li>当<code>webpack</code>生成文件时，顺便多生成一个说明描述文件</li><li>当<code>webpack</code>编译启动时，控制台输出一句话表示<code>webpack</code>启动了</li><li>当<code>xxxx</code>时，<code>xxxx</code></li></ul><p>这种类似的功能需要把功能嵌入到<code>webpack</code>的编译流程中，而这种事情的实现是依托于<code>plugin</code>的</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111743188.png"></p><p>plugin<code>的**本质**是一个带有</code>apply`方法的对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plugin = &#123;</span><br><span class="line">    <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，习惯上，我们会将该对象写成构造函数的模式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin = <span class="keyword">new</span> MyPlugin();</span><br></pre></td></tr></table></figure><p>要将插件应用到<code>webpack</code>，需要把插件对象配置到<code>webpack</code>的<code>plugins</code>数组中，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="keyword">new</span> MyPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apply</code>函数会在初始化阶段，创建好<code>Compiler</code>对象后运行。</p><p><code>compiler</code>对象是在初始化阶段构建的，整个<code>webpack</code>打包期间只有一个<code>compiler</code>对象，后续完成打包工作的是compiler对象内部创建的<code>compilation</code></p><p><code>apply</code>方法会在<strong>创建好compiler对象后调用</strong>，并向方法传入一个<code>compiler</code>对象</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111743591.png"></p><p><code>compiler</code>对象提供了大量的钩子函数（<code>hooks</code>，可以理解为事件），<code>plugin</code>的开发者可以注册这些钩子函数，参与<code>webpack</code>编译和生成。</p><p>你可以在<code>apply</code>方法中使用下面的代码注册钩子函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//在这里注册事件，类似于window.onload  $(function()&#123;&#125;)</span></span><br><span class="line">        compiler.hooks.事件名称.事件类型(name, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//事件处理函数</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事件名称</strong></p><p>即要监听的事件名，即钩子名，所有的钩子：<a href="https://www.webpackjs.com/api/compiler-hooks">https://www.webpackjs.com/api/compiler-hooks</a></p><p><strong>事件类型</strong></p><p>这一部分使用的是 <code>Tapable API</code>，这个小型的库是一个专门用于钩子函数监听的库。</p><p>它提供了一些事件类型：</p><ul><li><code>tap</code>：注册一个同步的钩子函数，函数运行完毕则表示事件处理结束</li><li><code>tapAsync</code>：注册一个基于回调的异步的钩子函数，函数通过调用一个回调表示事件处理结束</li><li><code>tapPromise</code>：注册一个基于<code>Promise</code>的异步的钩子函数，函数通过返回的<code>Promise</code>进入已决状态表示事件处理结束</li></ul><p><strong>处理函数</strong></p><p>处理函数有一个事件参数<code>compilation</code></p><h3 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h3><p>有些时候，我们需要针对生产环境和开发环境分别书写<code>webpack</code>配置</p><p>为了更好的适应这种要求，<code>webpack</code>允许配置不仅可以是一个对象，还可以是一个<strong>函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.base.js，入口/出口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;scripts/[name]-[hash:5].js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//webpack.dev.js，开发者环境配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//webpack.pro.js，生产者环境配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//webpack.config.js，主文件</span></span><br><span class="line"><span class="keyword">var</span> baseConfig = <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/webpack.base&quot;</span>) <span class="comment">//引入入口和出口</span></span><br><span class="line"><span class="keyword">var</span> devConfig = <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/webpack.dev&quot;</span>) <span class="comment">//引入两个环境配置文件</span></span><br><span class="line"><span class="keyword">var</span> proConfig = <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/webpack.pro&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果环境是production，就。。。</span></span><br><span class="line">    <span class="keyword">if</span> (env &amp;&amp; env.prod) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...baseConfig,</span><br><span class="line">            ...proConfig</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则。。。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...baseConfig,</span><br><span class="line">            ...devConfig</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始构建时，<code>webpack</code>如果发现配置是一个函数，会调用该函数，将函数返回的对象作为配置内容，因此，开发者可以根据不同的环境返回不同的对象</p><p>在调用<code>webpack</code>函数时，<code>webpack</code>会向函数传入一个参数<code>env</code>，该参数的值来自于<code>webpack</code>命令中给<code>env</code>指定的值，例如</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx webpack --env abc # env: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">npx webpack --env.abc # env: &#123;abc:true&#125;</span><br><span class="line">npx webpack --env.abc=1  # env： &#123;abc:1&#125;</span><br><span class="line">npx webpack --env.abc=1 --env.bcd=2 # env: &#123;abc:1, bcd:2&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们就可以在命令中指定环境，在代码中进行判断，根据环境返回不同的配置结果。</p><h3 id="其他细节配置"><a href="#其他细节配置" class="headerlink" title="其他细节配置"></a>其他细节配置</h3><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context: path.resolve(__dirname, <span class="string">&quot;app&quot;</span>)</span><br></pre></td></tr></table></figure><p>该配置会影响入口和<code>loaders</code>的解析，入口和loaders的相对路径会以context的配置作为基准路径，这样，你的配置会独立于<code>CWD</code>（<code>current working directory</code> 当前执行路径）</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><h5 id="library"><a href="#library" class="headerlink" title="library"></a>library</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">library: <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>这样一来，打包后的结果中，会将自执行函数的执行结果暴露给abc </p><h5 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">libraryTarget: <span class="string">&quot;var&quot;</span></span><br></pre></td></tr></table></figure><p>该配置可以更加精细的控制如何暴露入口包的导出结果</p><p>其他可用的值有：</p><ul><li><code>var</code>：默认值，暴露给一个普通变量</li><li><code>window</code>：暴露给window对象的一个属性</li><li><code>this</code>：暴露给this的一个属性</li><li><code>global</code>：暴露给global的一个属性</li><li><code>commonjs</code>：暴露给exports的一个属性</li><li>其他：<a href="https://www.webpackjs.com/configuration/output/#output-librarytarget">https://www.webpackjs.com/configuration/output/#output-librarytarget</a></li></ul><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target:<span class="string">&quot;web&quot;</span> <span class="comment">//默认值</span></span><br></pre></td></tr></table></figure><p>设置打包结果最终要运行的环境，常用值有</p><ul><li><code>web</code>: 打包后的代码运行在web环境中</li><li><code>node</code>：打包后的代码运行在node环境中</li><li>其他：<a href="https://www.webpackjs.com/configuration/target/">https://www.webpackjs.com/configuration/target/</a></li></ul><h4 id="module-noParse"><a href="#module-noParse" class="headerlink" title="module.noParse"></a>module.noParse</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">noParse: <span class="regexp">/jquery/</span></span><br></pre></td></tr></table></figure><p>不解析正则表达式匹配的模块，通常用它来忽略那些大型的单模块库，以提高<strong>构建性能</strong></p><h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p><code>resolve</code>的相关配置主要用于控制模块解析过程</p><h5 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">modules: [<span class="string">&quot;node_modules&quot;</span>]  <span class="comment">//默认值</span></span><br></pre></td></tr></table></figure><p>当解析模块时，如果遇到导入语句，<code>require(&quot;test&quot;)</code>，webpack会从下面的位置寻找依赖的模块</p><ol><li>当前目录下的<code>node_modules</code>目录</li><li>上级目录下的<code>node_modules</code>目录</li><li>…</li></ol><h5 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>]  <span class="comment">//默认值</span></span><br></pre></td></tr></table></figure><p>当解析模块时，遇到无具体后缀的导入语句，例如<code>require(&quot;test&quot;)</code>，会依次测试它的后缀名</p><ul><li><code>test.js</code></li><li><code>test.json</code></li></ul><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">&quot;@&quot;</span>: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">  <span class="string">&quot;_&quot;</span>: __dirname</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<code>alias</code>（别名）后，导入语句中可以加入配置的键名，例如<code>require(&quot;@/abc.js&quot;)</code>，<code>webpack</code>会将其看作是<code>require(src的绝对路径+&quot;/abc.js&quot;)</code>。</p><p>在大型系统中，源码结构往往比较深和复杂，别名配置可以让我们更加方便的导入依赖</p><h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">externals: &#123;    <span class="attr">jquery</span>: <span class="string">&quot;$&quot;</span>,    <span class="attr">lodash</span>: <span class="string">&quot;_&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>从最终的<code>bundle</code>中排除掉配置的配置的源码，例如，入口模块是</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.jsrequire(&quot;jquery&quot;)require(&quot;lodash&quot;)</span></span><br></pre></td></tr></table></figure><p>生成的<code>bundle</code>是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    ...&#125;)(&#123;    <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>)</span>&#123;        __webpack_require__(<span class="string">&quot;jquery&quot;</span>)        __webpack_require__(<span class="string">&quot;lodash&quot;</span>)    &#125;,    <span class="string">&quot;jquery&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>)</span>&#123;        <span class="comment">//jquery的大量源码    &#125;,    &quot;lodash&quot;: function(module, exports)&#123;        //lodash的大量源码    &#125;,&#125;)</span></span><br></pre></td></tr></table></figure><p>但有了上面的配置后，则变成了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">    <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>)</span>&#123;</span><br><span class="line">        __webpack_require__(<span class="string">&quot;jquery&quot;</span>)</span><br><span class="line">        __webpack_require__(<span class="string">&quot;lodash&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = $;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;lodash&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = _;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这比较适用于一些第三方库来自于外部<code>CDN</code>的情况，这样一来，即可以在页面中使用<code>CDN</code>，又让<code>bundle</code>的体积变得更小，还不影响源码的编写</p><h4 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h4><p><code>stats</code>控制的是构建过程中控制台的输出内容</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stats: &#123;</span><br><span class="line">    <span class="attr">colors</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">modules</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">hash</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">builtAt</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="devtool-配置"><a href="#devtool-配置" class="headerlink" title="devtool 配置"></a>devtool 配置</h3><h4 id="source-map-源码地图"><a href="#source-map-源码地图" class="headerlink" title="source map 源码地图"></a>source map 源码地图</h4><blockquote><p>本小节的知识与 webpack 无关</p></blockquote><p>前端发展到现阶段，很多时候都不会直接运行源代码，可能需要对源代码进行合并、压缩、转换等操作，真正运行的是转换后的代码</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744410.png"></p><p>这就给调试带来了困难，因为当运行发生错误的时候，我们更加希望能看到源代码中的错误，而不是转换后代码的错误</p><blockquote><p>jquery压缩后的代码：<a href="https://code.jquery.com/jquery-3.4.1.min.js">https://code.jquery.com/jquery-3.4.1.min.js</a></p></blockquote><p>为了解决这一问题，chrome浏览器率先支持了source map，其他浏览器纷纷效仿，目前，几乎所有新版浏览器都支持了<code>source map</code></p><p><code>source map</code>实际上是一个配置，配置中不仅记录了所有源码内容，还记录了和转换后的代码的对应关系</p><p>下面是浏览器处理<code>source map</code>的原理</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744946.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744402.png"></p><p><strong>最佳实践</strong>：</p><ol><li><code>source map</code> 应在开发环境中使用，作为一种调试手段</li><li><code>source map</code> 不应该在生产环境中使用，<code>source map</code>的文件一般较大，不仅会导致额外的网络传输，还容易暴露原始代码。即便要在生产环境中使用<code>source map</code>，用于调试真实的代码运行问题，也要做出一些处理规避网络传输和代码暴露的问题。</li></ol><h4 id="webpack中的source-map"><a href="#webpack中的source-map" class="headerlink" title="webpack中的source map"></a>webpack中的source map</h4><p>使用 <code>webpack</code> 编译后的代码难以调试，可以通过 <code>devtool</code> 配置来<strong>优化调试体验</strong></p><p>具体的配置见文档：<a href="https://www.webpackjs.com/configuration/devtool/">https://www.webpackjs.com/configuration/devtool/</a></p><h2 id="常用拓展-plugin"><a href="#常用拓展-plugin" class="headerlink" title="常用拓展(plugin)"></a>常用拓展(plugin)</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><h4 id="清除目录"><a href="#清除目录" class="headerlink" title="清除目录"></a>清除目录</h4><ul><li>安装：</li><li><code>npm install clean-webpack-plugin --save-dev</code></li></ul><h4 id="自动生成页面"><a href="#自动生成页面" class="headerlink" title="自动生成页面"></a>自动生成页面</h4><ul><li>该插件将为你生成一个 <code>HTML5</code> 文件， 其中包括使用 <code>script</code> 标签的 <code>body</code> 中的所有 <code>webpack</code> 包。 </li><li>安装：</li><li><code>npm install --svae-dev html-webpack-plugin</code></li></ul><h4 id="复制静态文件"><a href="#复制静态文件" class="headerlink" title="复制静态文件"></a>复制静态文件</h4><ul><li>安装</li><li><code>npm install --save-dev copy-webpack-plugin</code></li></ul><h4 id="打包文件分析工具"><a href="#打包文件分析工具" class="headerlink" title="打包文件分析工具"></a>打包文件分析工具</h4><ul><li>安装</li><li><code>npm install --save-dev webpack-bundle-analyzer</code></li></ul><h4 id="案例使用："><a href="#案例使用：" class="headerlink" title="案例使用："></a>案例使用：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ClearWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clear-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> WebpackBundleAnalyzer = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>)</span><br><span class="line">  .BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;scripts/[name].[chunkhash:5].js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">//清除目录</span></span><br><span class="line">        <span class="keyword">new</span> ClearWebpackPlugn(),</span><br><span class="line">        <span class="comment">//生成页面</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/public/index.html&#x27;</span>, <span class="comment">//模板配置文件路径</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span> <span class="comment">//新建的文件名称</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">//复制静态文件</span></span><br><span class="line">        <span class="keyword">new</span> CopyPlugin([</span><br><span class="line">            &#123;<span class="attr">from</span>: <span class="string">&#x27;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/public&#x27;</span>, <span class="attr">to</span>:<span class="string">&#x27;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/&#x27;</span>&#125;<span class="comment">//从哪里复制到哪里</span></span><br><span class="line">        ]),</span><br><span class="line">        <span class="comment">//打包文件分析工具</span></span><br><span class="line">        <span class="keyword">new</span> WebpackBundleAnalyzer(&#123;</span><br><span class="line">            <span class="attr">analyzerMode</span>: <span class="string">&#x27;server&#x27;</span>,</span><br><span class="line">            <span class="comment">//  将在“服务器”模式下使用的主机启动HTTP服务器。</span></span><br><span class="line">            <span class="attr">analyzerHost</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">            <span class="comment">//  将在“服务器”模式下使用的端口启动HTTP服务器。</span></span><br><span class="line">            <span class="attr">analyzerPort</span>: <span class="number">8888</span>, </span><br><span class="line">            <span class="comment">//  路径捆绑，将在`static`模式下生成的报告文件。</span></span><br><span class="line">            <span class="comment">//  相对于捆绑输出目录。</span></span><br><span class="line">            <span class="attr">logLevel</span>: <span class="string">&#x27;info&#x27;</span> </span><br><span class="line">            <span class="comment">// 日志级别。可以是&#x27;信息&#x27;，&#x27;警告&#x27;，&#x27;错误&#x27;或&#x27;沉默&#x27;。</span></span><br><span class="line">        &#125;);</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浏览器打开127.0.0.1:8888地址可以看到打包文件分析效果图：</span></span><br></pre></td></tr></table></figure><h3 id="开发服务器"><a href="#开发服务器" class="headerlink" title="开发服务器"></a>开发服务器</h3><p>在<strong>开发阶段</strong>，目前遇到的问题是打包、运行、调试过程过于繁琐，回顾一下我们的操作流程：</p><ol><li>编写代码</li><li>控制台运行命令完成打包</li><li>打开页面查看效果</li><li>继续编写代码，回到步骤2</li></ol><p>并且，我们往往希望把最终生成的代码和页面部署到服务器上，来模拟真实环境</p><p>为了解决这些问题，<code>webpack</code>官方制作了一个单独的库：<strong>webpack-dev-server</strong></p><p>它<strong>既不是plugin也不是loader</strong></p><p>先来看看它怎么用</p><ol><li><p>安装</p><ol><li><code>npm install --save-dev webpack-dev-server</code></li></ol></li><li><p>在<code>webpack.config.js</code>中添加<code>devServer</code></p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&#x27;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/dist&#x27;</span>, <span class="comment">//静态资源目录</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">openPage</span>: <span class="string">&#x27;html/index.html&#x27;</span>, <span class="comment">//打开的主页面</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol><li>执行<code>npm webpack server</code>命令</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个命令是专门为开发阶段服务的，真正部署的时候还是得使用`webpack`命令</span><br><span class="line"></span><br><span class="line">当我们执行```webpack-dev-server```命令后，它做了以下操作：</span><br><span class="line"></span><br><span class="line">1. 内部执行`webpack`命令，传递命令参数</span><br><span class="line">2. 开启`watch`</span><br><span class="line">3. 注册`hooks`：类似于`plugin`，`webpack-dev-server`会向`webpack`中注册一些钩子函数，主要功能如下：</span><br><span class="line">   1. 将资源列表（`aseets`）保存起来</span><br><span class="line">   2. 禁止`webpack`输出文件</span><br><span class="line">4. 用`express`开启一个服务器，监听某个端口，当请求到达后，根据请求的路径，给予相应的资源内容</span><br><span class="line"></span><br><span class="line">**配置**</span><br><span class="line"></span><br><span class="line">针对`webpack-dev-server`的配置，参考：https://www.webpackjs.com/configuration/dev-server/</span><br><span class="line"></span><br><span class="line">常见配置有：</span><br><span class="line"></span><br><span class="line">- `port`：配置监听端口</span><br><span class="line">- `proxy`：配置代理，常用于跨域访问</span><br><span class="line">- `stats`：配置控制台输出内容</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &#x27;development&#x27;,</span><br><span class="line">    devtools: &#x27;source-map&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#x27;scripts/[name].[chunkhash:5].js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    //开发服务器</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        //配置监听端口</span><br><span class="line">        port: 8000,</span><br><span class="line">        //配置代理，常用于跨域访问</span><br><span class="line">        open: true,</span><br><span class="line">        proxy: &#123; //代理规则</span><br><span class="line">        &quot;/api&quot;: &#123;</span><br><span class="line">                target: &#x27;http://open.duyiedu.com&#x27;,</span><br><span class="line">                changeOrigin: true //更改请求头中的host和origin</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决路径问题"><a href="#解决路径问题" class="headerlink" title="解决路径问题"></a>解决路径问题</h3><p>在使用<code>file-loader</code>或<code>url-loader</code>时，可能会遇到一个非常有趣的问题</p><p>比如，通过<code>webpack</code>打包的目录结构如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">dist</span></span><br><span class="line">    <span class="string">|——</span> <span class="string">img</span></span><br><span class="line">        <span class="string">|——</span> <span class="string">a.png</span>  <span class="comment">#file-loader生成的文件</span></span><br><span class="line">    <span class="string">|——</span> <span class="string">scripts</span></span><br><span class="line">        <span class="string">|——</span> <span class="string">main.js</span>  <span class="comment">#export default &quot;img/a.png&quot;</span></span><br><span class="line">    <span class="string">|——</span> <span class="string">html</span></span><br><span class="line">        <span class="string">|——</span> <span class="string">index.html</span> <span class="comment">#&lt;script src=&quot;.https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/scripts/main.js&quot; &gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>这种问题发生的根本原因：模块中的路径来自于某个<code>loader</code>或<code>plugin</code>，当产生路径时，<code>loader</code>或<code>plugin</code>只有相对于<code>dist</code>目录的路径，并不知道该路径将在哪个资源中使用，从而无法确定最终正确的路径</p><p>面对这种情况，需要依靠<code>webpack</code>的配置<code>publicPath</code>解决</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;scripts/[name].[chunkhash:5].js&quot;</span>,</span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&quot;/&quot;</span> <span class="comment">//用这个解决</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png)|(gif)|(jpg)$/</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">name</span>: <span class="string">&quot;imgs/[name].[hash:5].[ext]&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/public/index.html&quot;</span>,</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;html/index.html&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">openPage</span>: <span class="string">&quot;html/index.html&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">stats</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">colors</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack内置插件"><a href="#webpack内置插件" class="headerlink" title="webpack内置插件"></a>webpack内置插件</h3><p>所有的<code>webpack</code>内置插件都作为<code>webpack</code>的静态属性存在的，使用下面的方式即可创建一个插件对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> webpack.插件名(options)</span><br></pre></td></tr></table></figure><h4 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h4><p>全局常量定义插件，使用该插件通常定义一些常量值，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    <span class="attr">PI</span>: <span class="string">`Math.PI`</span>, <span class="comment">// PI = Math.PI</span></span><br><span class="line">    <span class="attr">VERSION</span>: <span class="string">`&quot;1.0.0&quot;`</span>, <span class="comment">// VERSION = &quot;1.0.0&quot;</span></span><br><span class="line">    <span class="attr">DOMAIN</span>: <span class="built_in">JSON</span>.stringify(<span class="string">&quot;duyi.com&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样一来，在源码中，我们可以直接使用插件中提供的常量，当<code>webpack</code>编译完成后，会自动替换为常量的值</p><h4 id="BannerPlugin"><a href="#BannerPlugin" class="headerlink" title="BannerPlugin"></a>BannerPlugin</h4><p>它可以为每个<code>chunk</code>生成的文件头部添加一行注释，一般用于添加作者、公司、版权等信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(&#123;</span><br><span class="line">  <span class="attr">banner</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  hash:[hash]</span></span><br><span class="line"><span class="string">  chunkhash:[chunkhash]</span></span><br><span class="line"><span class="string">  name:[name]</span></span><br><span class="line"><span class="string">  author:yuanjin</span></span><br><span class="line"><span class="string">  corporation:duyi</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h4><p>自动加载全局模块，而不必到处 <code>import</code> 或 <code>require</code> </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;  <span class="attr">$</span>: <span class="string">&#x27;jquery&#x27;</span>,  <span class="attr">_</span>: <span class="string">&#x27;lodash&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>然后在我们任意源码中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#item&#x27;</span>); <span class="comment">// &lt;= 起作用_.drop([1, 2, 3], 2); // &lt;= 起作用</span></span><br></pre></td></tr></table></figure><h4 id="CommonsChunksPlugin"><a href="#CommonsChunksPlugin" class="headerlink" title="CommonsChunksPlugin"></a>CommonsChunksPlugin</h4><ul><li><code>webpack3</code>使用的，已过时</li></ul><p><code>CommonsChunkPlugin</code>是一个可选的用于建立一个独立文件(又称作 <code>chunk</code>)的功能，这个文件包括多个入口 <code>chunk</code> 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。我们只需在<code>webpack.config.js</code> 添加下面的代码即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;    <span class="attr">name</span>:<span class="string">&#x27;commons&#x27;</span>, <span class="comment">//模块名    filename:&#x27;commons.js&#x27;, //资源文件名    minChunks:3 //公共模块如果使用超过3次，就会打包到commons.js&#125;)</span></span><br></pre></td></tr></table></figure><p>创建之后，需要把<code>commons.js</code>引入到<code>html</code>文件中</p><p><a href="https://www.webpackjs.com/plugins/">Plugins | webpack 中文网 (webpackjs.com)更多内置插件</a></p><h2 id="css工程化"><a href="#css工程化" class="headerlink" title="css工程化"></a>css工程化</h2><h3 id="css工程化概述"><a href="#css工程化概述" class="headerlink" title="css工程化概述"></a>css工程化概述</h3><h4 id="css的问题"><a href="#css的问题" class="headerlink" title="css的问题"></a>css的问题</h4><h5 id="类名冲突的问题"><a href="#类名冲突的问题" class="headerlink" title="类名冲突的问题"></a>类名冲突的问题</h5><p>当你写一个<code>css</code>类的时候，你是写全局的类呢，还是写多个层级选择后的类呢？</p><p>你会发现，怎么都不好</p><ul><li>过深的层级不利于编写、阅读、压缩、复用</li><li>过浅的层级容易导致类名冲突</li></ul><p>一旦样式多起来，这个问题就会变得越发严重，其实归根结底，就是类名冲突不好解决的问题</p><h5 id="重复样式"><a href="#重复样式" class="headerlink" title="重复样式"></a>重复样式</h5><p>这种问题就更普遍了，一些重复的样式值总是不断的出现在css代码中，维护起来极其困难</p><p>比如，一个网站的颜色一般就那么几种：</p><ul><li><strong>primary</strong></li><li><strong>info</strong></li><li><strong>warn</strong></li><li><strong>error</strong></li><li><strong>success</strong></li></ul><p>如果有更多的颜色，都是从这些色调中自然变化得来，可以想象，这些颜色会到处充斥到诸如背景、文字、边框中，一旦要做颜色调整，是一个非常大的工程</p><h5 id="css文件细分问题"><a href="#css文件细分问题" class="headerlink" title="css文件细分问题"></a>css文件细分问题</h5><p>在大型项目中，<code>css</code>也需要更细的拆分，这样有利于<code>css</code>代码的维护。</p><p>比如，有一个做轮播图的模块，它不仅需要依赖<code>js</code>功能，还需要依赖<code>css</code>样式，既然依赖的<code>js</code>功能仅关心轮播图，那<code>css</code>样式也应该仅关心轮播图，由此类推，不同的功能依赖不同的<code>css</code>样式、公共样式可以单独抽离，这样就形成了不同于过去的<code>css</code>文件结构：文件更多、拆分的更细</p><p>而同时，在真实的运行环境下，我们却希望文件越少越好，这种情况和<code>JS</code>遇到的情况是一致的</p><p>因此，对于<code>css</code>，也需要工程化管理</p><p>从另一个角度来说，css的工程化会遇到更多的挑战，因为<code>css</code>不像<code>JS</code>，它的语法本身经过这么多年并没有发生多少的变化（<code>css3</code>也仅仅是多了一些属性而已），对于<code>css</code>语法本身的改变也是一个工程化的课题</p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>这么多年来，官方一直没有提出方案来解决上述问题</p><p>一些第三方机构针对不同的问题，提出了自己的解决方案</p><h5 id="解决类名冲突"><a href="#解决类名冲突" class="headerlink" title="解决类名冲突"></a>解决类名冲突</h5><p>一些第三方机构提出了一些方案来解决该问题，常见的解决方案如下：</p><p><strong>命名约定</strong></p><p>即提供一种命名的标准，来解决冲突，常见的标准有：</p><ul><li><strong>BEM</strong></li><li><strong>OOCSS</strong></li><li><strong>AMCSS</strong></li><li><strong>SMACSS</strong></li><li><strong>其他</strong></li></ul><p><strong>css in js</strong></p><p>这种方案非常大胆，它觉得，<code>css</code>语言本身几乎无可救药了，干脆直接用<code>js</code>对象来表示样式，然后把样式直接应用到元素的style中</p><p>这样一来，<code>css</code>变成了一个一个的对象，就可以完全利用到<code>js</code>语言的优势，你可以：</p><ul><li>通过一个函数返回一个样式对象</li><li>把公共的样式提取到公共模块中返回</li><li>应用<code>js</code>的各种特性操作对象，比如：混合、提取、拆分</li><li>更多的花样</li></ul><blockquote><p>这种方案在手机端的React Native中大行其道</p></blockquote><p><strong>css module</strong></p><p>非常有趣和好用的<code>css</code>模块化方案，编写简单，绝对不重名</p><p>具体的课程中详细介绍</p><h5 id="解决重复样式的问题"><a href="#解决重复样式的问题" class="headerlink" title="解决重复样式的问题"></a>解决重复样式的问题</h5><p><strong>css in js</strong></p><p>这种方案虽然可以利用js语言解决重复样式值的问题，但由于太过激进，很多习惯写css的开发者编写起来并不是很适应</p><p><strong>预编译器</strong></p><p>有些第三方搞出一套css语言的进化版来解决这个问题，它支持变量、函数等高级语法，然后经过编译器将其编译成为正常的css</p><p>这种方案特别像构建工具，不过它仅针对css</p><p>常见的预编译器支持的语言有：</p><ul><li><strong>less</strong></li><li><strong>sass</strong></li></ul><h5 id="解决css文件细分问题"><a href="#解决css文件细分问题" class="headerlink" title="解决css文件细分问题"></a>解决css文件细分问题</h5><p>这一部分，就要依靠构建工具，例如<code>webpack</code>来解决了</p><p>利用一些<code>loader</code>或<code>plugin</code>来打包、合并、压缩<code>css</code>文件</p><h3 id="利用webpack拆分css"><a href="#利用webpack拆分css" class="headerlink" title="利用webpack拆分css"></a>利用webpack拆分css</h3><p>要拆分css，就必须把<code>css</code>当成像<code>js</code>那样的模块；要把<code>css</code>当成模块，就必须有一个构建工具（<code>webpack</code>），它具备合并代码的能力</p><p>而<code>webpack</code>本身只能读取<code>css</code>文件的内容、将其当作<code>JS</code>代码进行分析，因此，会导致错误</p><p>于是，就必须有一个<code>loader</code>，能够将css代码转换为<code>js</code>代码</p><h4 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h4><p><code>css-loader</code>的作用，就是将<code>css</code>代码转换为js代码</p><p>它的处理原理极其简单：将<code>css</code>代码作为字符串导出</p><p>例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">&quot;#f40&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过css-loader转换后变成js代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;</span></span><br><span class="line"><span class="string">    color:&quot;#f40&quot;;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的js代码是经过我简化后的，不代表真实的css-loader的转换后代码，css-loader转换后的代码会有些复杂，同时会导出更多的信息，但核心思想不变</p></blockquote><p>再例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">&quot;#f40&quot;</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/bg.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过css-loader转换后变成js代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> import1 = <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/bg.png&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;</span></span><br><span class="line"><span class="string">    color:&quot;#f40&quot;;</span></span><br><span class="line"><span class="string">    background:url(&quot;<span class="subst">$&#123;import1&#125;</span>&quot;)</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br></pre></td></tr></table></figure><p>这样一来，经过webpack的后续处理，会把依赖<code>https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/bg.png</code>添加到模块列表，然后再将代码转换为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> import1 = __webpack_require__(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/bg.png&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;</span></span><br><span class="line"><span class="string">    color:&quot;#f40&quot;;</span></span><br><span class="line"><span class="string">    background:url(&quot;<span class="subst">$&#123;import1&#125;</span>&quot;)</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/reset.css&quot;</span>;</span><br><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">&quot;#f40&quot;</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/bg.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会转换为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> import1 = <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/reset.css&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> import2 = <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/bg.png&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">`<span class="subst">$&#123;import1&#125;</span></span></span><br><span class="line"><span class="string">.red&#123;</span></span><br><span class="line"><span class="string">    color:&quot;#f40&quot;;</span></span><br><span class="line"><span class="string">    background:url(&quot;<span class="subst">$&#123;import2&#125;</span>&quot;)</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br></pre></td></tr></table></figure><p>总结，<code>css-loader</code>干了什么：</p><ol><li>将<code>css</code>文件的内容作为字符串导出</li><li>将<code>css</code>中的其他依赖作为<code>require</code>导入，以便<code>webpack</code>分析依赖</li></ol><h4 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h4><p>由于<code>css-loader</code>仅提供了将<code>css</code>转换为字符串导出的能力，剩余的事情要交给其他<code>loader</code>或plugin来处理</p><p><code>style-loader</code>可以将<code>css-loader</code>转换后的代码进一步处理，将<code>css-loader</code>导出的字符串加入到页面的<code>style</code>元素中</p><p>例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">&quot;#f40&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过<code>css-loader</code>转换后变成<code>js</code>代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;    color:&quot;#f40&quot;;&#125;`</span></span><br></pre></td></tr></table></figure><p>经过<code>style-loader</code>转换后变成：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;    color:&quot;#f40&quot;;&#125;`</span><span class="keyword">var</span> style = <span class="built_in">module</span>.exports;<span class="keyword">var</span> styleElem = <span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>);styleElem.innerHTML = style;<span class="built_in">document</span>.head.appendChild(styleElem);<span class="built_in">module</span>.exports = &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码均为简化后的代码，并不代表真实的代码<br>style-loader有能力避免同一个样式的重复导入</p></blockquote><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><code>BEM</code>是一套针对<code>css</code>类样式的命名方法。</p><blockquote><p>其他命名方法还有：OOCSS、AMCSS、SMACSS等等</p></blockquote><p><code>BEM</code>全称是：<strong>B</strong>lock <strong>E</strong>lement <strong>M</strong>odifier</p><p>一个完整的<code>BEM</code>类名：<code>block__element_modifier</code>，例如：<code>banner__dot_selected</code>，可以表示：轮播图中，处于选中状态的小圆点</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111750919.png"></p><p>三个部分的具体含义为：</p><ul><li><strong>Block</strong>：页面中的大区域，表示最顶级的划分，例如：轮播图(<code>banner</code>)、布局(<code>layout</code>)、文章(<code>article</code>)等等</li><li><strong>element</strong>：区域中的组成部分，例如：轮播图中的横幅图片(<code>banner__img</code>)、轮播图中的容器（<code>banner__container</code>）、布局中的头部(<code>layout__header</code>)、文章中的标题(<code>article_title</code>)</li><li><strong>modifier</strong>：可选。通常表示状态，例如：处于展开状态的布局左边栏（<code>layout__left_expand</code>）、处于选中状态的轮播图小圆点(<code>banner__dot_selected</code>)</li></ul><p>在某些大型工程中，如果使用BEM命名法，还可能会增加一个前缀，来表示类名的用途，常见的前缀有：</p><ul><li><strong>l</strong>: <code>layout</code>，表示这个样式是用于布局的</li><li><strong>c</strong>: <code>component</code>，表示这个样式是一个组件，即一个功能区域</li><li><strong>u</strong>: <code>util</code>，表示这个样式是一个通用的、工具性质的样式</li><li><strong>j</strong>: <code>javascript</code>，表示这个样式没有实际意义，是专门提供给js获取元素使用的</li></ul><h3 id="css-in-js"><a href="#css-in-js" class="headerlink" title="css in js"></a>css in js</h3><p><code>css in js</code> 的核心思想是：用一个<code>JS</code>对象来描述样式，而不是<code>css</code>样式表</p><p>例如下面的对象就是一个用于描述样式的对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> styles = &#123;    <span class="attr">backgroundColor</span>: <span class="string">&quot;#f40&quot;</span>,    <span class="attr">color</span>: <span class="string">&quot;#fff&quot;</span>,    <span class="attr">width</span>: <span class="string">&quot;400px&quot;</span>,    <span class="attr">height</span>: <span class="string">&quot;500px&quot;</span>,    <span class="attr">margin</span>: <span class="string">&quot;0 auto&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>由于这种描述样式的方式<strong>根本就不存在类名</strong>，自然不会有类名冲突</p><p>至于如何把样式应用到界面上，不是它所关心的事情，你可以用任何技术、任何框架、任何方式将它应用到界面。</p><blockquote><p>后续学习的vue、react都支持css in js，可以非常轻松的应用到界面</p></blockquote><p><code>css in js</code>的特点：</p><ul><li><strong>绝无冲突的可能</strong>：由于它根本不存在类名，所以绝不可能出现类名冲突</li><li><strong>更加灵活</strong>：可以充分利用<code>JS</code>语言灵活的特点，用各种招式来处理样式</li><li><strong>应用面更广</strong>：只要支持<code>js</code>语言，就可以支持<code>css in js</code>，因此，在一些用<code>JS</code>语言开发移动端应用的时候非常好用，因为移动端应用很有可能并不支持css</li><li><strong>书写不便</strong>：书写样式，特别是公共样式的时候，处理起来不是很方便</li><li><strong>在页面中增加了大量冗余内容</strong>：在页面中处理<code>css in js</code>时，往往是将样式加入到元素的<code>style</code>属性中，会大量增加元素的内联样式，并且可能会有大量重复，不易阅读最终的页面代码</li></ul><h3 id="css-module"><a href="#css-module" class="headerlink" title="css module"></a>css module</h3><blockquote><p>通过命名规范来限制类名太过死板，而css in js虽然足够灵活，但是书写不便。<br>css module 开辟一种全新的思路来解决类名冲突的问题</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>css module</code> 遵循以下思路解决类名冲突问题：</p><ol><li><code>css</code>的类名冲突往往发生在大型项目中</li><li>大型项目往往会使用构建工具（<code>webpack</code>等）搭建工程</li><li>构建工具允许将<code>css</code>样式切分为更加精细的模块</li><li>同<code>JS</code>的变量一样，每个<code>css</code>模块文件中难以出现冲突的类名，冲突的类名往往发生在不同的<code>css</code>模块文件中</li><li>只需要保证构建工具在合并样式代码后不会出现类名冲突即可</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744074.png"></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在<code>webpack</code>中，作为处理<code>css</code>的<code>css-loader</code>，它实现了<code>css module</code>的思想，要启用<code>css module</code>，需要将<code>css-loader</code>的配置<code>modules</code>设置为<code>true</code>。</p><p><code>css-loader</code>的实现方式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744020.png"></p><p>原理极其简单，开启了<code>css module</code>后，<code>css-loader</code>会将样式中的类名进行转换，转换为一个唯一的<code>hash</code>值。</p><p>由于<code>hash</code>值是根据模块路径和类名生成的，因此，不同的<code>css</code>模块，哪怕具有相同的类名，转换后的<code>hash</code>值也不一样。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744072.png"></p><h4 id="如何应用样式"><a href="#如何应用样式" class="headerlink" title="如何应用样式"></a>如何应用样式</h4><p><code>css module</code>带来了一个新的问题：源代码的类名和最终生成的类名是不一样的，而开发者只知道自己写的源代码中的类名，并不知道最终的类名是什么，那如何应用类名到元素上呢？</p><p>为了解决这个问题，<code>css-loader</code>会导出原类名和最终类名的对应关系，该关系是通过一个对象描述的</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744659.png"></p><p>这样一来，我们就可以在<code>js</code>代码中获取到<code>css</code>模块导出的结果，从而应用类名了</p><p><code>style-loader</code>为了我们更加方便的应用类名，会去除掉其他信息，仅暴露对应关系</p><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><h5 id="全局类名"><a href="#全局类名" class="headerlink" title="全局类名"></a>全局类名</h5><p>某些类名是全局的、静态的，不需要进行转换，仅需要在类名位置使用一个特殊的语法即可：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">global</span>(.main)&#123;    ...&#125;</span><br></pre></td></tr></table></figure><p>使用了<code>global</code>的类名不会进行转换，相反的，没有使用<code>global</code>的类名，表示默认使用了<code>local</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">local</span>(.main)&#123;    ...&#125;</span><br></pre></td></tr></table></figure><p>使用了<code>local</code>的类名表示局部类名，是可能会造成冲突的类名，会被<code>css module</code>进行转换</p><h5 id="如何控制最终的类名"><a href="#如何控制最终的类名" class="headerlink" title="如何控制最终的类名"></a>如何控制最终的类名</h5><p>绝大部分情况下，我们都不需要控制最终的类名，因为控制它没有任何意义</p><p>如果一定要控制最终的类名，需要配置<code>css-loader</code>的<code>localIdentName</code></p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种实现方法,实现css-modules，需要使用构建工具</span></span><br><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="attr">module</span>: &#123;    </span><br><span class="line">    <span class="attr">rules</span>: [        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: [</span><br><span class="line">                <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">modules</span>: &#123;</span><br><span class="line">                            <span class="attr">localIdentName</span>: <span class="string">&quot;[local]-[hash:5]&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="attr">modules</span>:<span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],         </span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use:[<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader?modules&quot;</span>]        </span><br><span class="line">&#125;    </span><br><span class="line">]</span><br><span class="line">&#125;,    </span><br><span class="line"></span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> style1 <span class="keyword">from</span><span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/assets/style1.css&quot;</span> <span class="comment">//引入css文件</span></span><br><span class="line"><span class="keyword">import</span> style2 <span class="keyword">from</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/assets/style2.css&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(style1)</span><br><span class="line"><span class="comment">//将元素div1的class类名更改为module之后的类名</span></span><br><span class="line"><span class="keyword">const</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);div1.className = style2.c1;</span><br></pre></td></tr></table></figure><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><ul><li><code>css module</code>往往配合构建工具使用</li><li><code>css module</code>仅处理顶级类名，尽量不要书写嵌套的类名，也没有这个必要</li><li><code>css module</code>仅处理类名，不处理其他选择器</li><li><code>css module</code>还会处理id选择器，不过任何时候都没有使用id选择器的理由</li><li>使用了<code>css module</code>后，只要能做到让类名望文知意即可，不需要遵守其他任何的命名规范</li></ul><h3 id="CSS预编译器-less"><a href="#CSS预编译器-less" class="headerlink" title="CSS预编译器{less}"></a>CSS预编译器{less}</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>编写<code>css</code>时，受限于<code>css</code>语言本身，常常难以处理一些问题：</p><ul><li>重复的样式值：例如常用颜色、常用尺寸</li><li>重复的代码段：例如绝对定位居中、清除浮动</li><li>重复的嵌套书写</li></ul><p>由于官方迟迟不对<code>css</code>语言本身做出改进，一些第三方机构开始想办法来解决这些问题</p><p>其中一种方案，便是预编译器</p><p>预编译器的原理很简单，即使用一种更加优雅的方式来书写样式代码，通过一个编译器，将其转换为可被浏览器识别的传统<code>css</code>代码</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744691.png"></p><p>目前，最流行的预编译器有<strong>LESS</strong>和<strong>SASS</strong>，由于它们两者特别相似，因此仅学习一种即可（本课程学习<code>LESS</code>）</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111744904.png"></p><blockquote><p>less官网：<a href="http://lesscss.org/">http://lesscss.org/</a><br>less中文文档1（非官方）：<a href="http://lesscss.cn/">http://lesscss.cn/</a><br>less中文文档2（非官方）：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a><br>sass官网：<a href="https://sass-lang.com/">https://sass-lang.com/</a><br>sass中文文档1（非官方）：<a href="https://www.sass.hk/">https://www.sass.hk/</a><br>sass中文文档2（非官方）：<a href="https://sass.bootcss.com/">https://sass.bootcss.com/</a></p></blockquote><h4 id="LESS的安装和使用"><a href="#LESS的安装和使用" class="headerlink" title="LESS的安装和使用"></a>LESS的安装和使用</h4><p>从原理可知，要使用<code>LESS</code>，必须要安装LESS编译器</p><p><code>LESS</code>编译器是基于<code>node</code>开发的，可以通过<code>npm</code>下载安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D less</span><br></pre></td></tr></table></figure><p>安装好了<code>less</code>之后，它提供了一个CLI工具<code>lessc</code>，通过该工具即可完成编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lessc less代码文件 编译后的文件</span><br></pre></td></tr></table></figure><p>试一试:</p><p>新建一个<code>index.less</code>文件，编写内容如下：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// less代码@red: #f40;.redcolor &#123;    color: @red;&#125;</span></span><br></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lessc index.less index.css</span><br></pre></td></tr></table></figure><p>可以看到编译之后的代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.redcolor</span> &#123;  <span class="attribute">color</span>: <span class="number">#f40</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="LESS的基本使用"><a href="#LESS的基本使用" class="headerlink" title="LESS的基本使用"></a>LESS的基本使用</h4><h5 id="什么是Less"><a href="#什么是Less" class="headerlink" title="什么是Less"></a>什么是Less</h5><ul><li><code>Less Css</code>是一种动态样式语言，属于<code>css</code>预处理语言的一种</li><li>它使用类似<code>css</code>的语法为<code>CSS</code>的赋予了动态的特性，</li><li>如变量，继承，运算，函数等，更方便<code>css</code>的编写和维护实现<code>css</code>模块化。</li><li>作为一种 <code>CSS</code> 扩展, <code>Less</code> 不仅向后兼容 <code>CSS</code>, 它还使用现有的 <code>CSS</code> 语法新增了额外的特性. 这使得学习 <code>Less</code> 更轻松, 一旦有任何问题，可以随时退回使用标准的 <code>CSS</code>.</li><li><code>less css</code>可以在多种语言，环境中使用，包括浏览器端，桌面客户端，服务端</li><li>配置<code>loader</code><ul><li>安装<code>npm install less-loader less --save-dev</code></li></ul></li></ul><h5 id="Less语法"><a href="#Less语法" class="headerlink" title="Less语法"></a>Less语法</h5><ul><li><p>注释：<code>//</code>不会被编译   <code>/**/</code>此注释会被编译</p></li><li><p>变量：声明变量 <code>@a:300px</code> 使用变量：<code>.box &#123;width:@a;&#125;</code></p></li></ul><ul><li>混合</li></ul><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@gr:</span>yellow;</span><br><span class="line"><span class="variable">@height:</span><span class="number">100px</span>;</span><br><span class="line"><span class="selector-class">.border</span>(<span class="variable">@width</span>,<span class="variable">@color</span>);&#123; </span><br><span class="line">    <span class="comment">/*并没有这个DOM元素，但是可以把这个定义为一组变量*/</span>   </span><br><span class="line">    <span class="attribute">border</span>:<span class="variable">@width</span> solid <span class="variable">@color</span>;</span><br><span class="line">    <span class="comment">//width和color属于参数，调用时可以传参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="variable">@gr</span>;</span><br><span class="line">    <span class="selector-tag">img</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="variable">@height</span>;        </span><br><span class="line">        <span class="selector-class">.border</span>(<span class="string">&#x27;5px&#x27;</span>,green);</span><br><span class="line">        <span class="comment">//给img添加border,并传参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小三角</span></span><br><span class="line"><span class="selector-class">.triangleStyle</span>(<span class="variable">@_</span>,<span class="variable">@color</span>) &#123; </span><br><span class="line">    <span class="comment">//@_代表公共样式，可以传入上下左右方向</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.triangleStyle</span>(top,<span class="variable">@color</span>)&#123;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>:<span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.triangleStyle</span>(bottom,<span class="variable">@color</span>) &#123;</span><br><span class="line">    <span class="attribute">border-top-color</span>:<span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.triangleStyle</span>(left,<span class="variable">@color</span>)&#123;</span><br><span class="line">    <span class="attribute">border-right-color</span>:<span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.triangleStyle</span>(right,<span class="variable">@color</span>)&#123;</span><br><span class="line">    <span class="attribute">border-left-color</span>:<span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>样式属性计算</li></ul><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="selector-class">.triangle</span>&#123;        </span><br><span class="line">        <span class="comment">//属性值可以进行计算,css3也有一个方法可以计算(calc())</span></span><br><span class="line">        <span class="attribute">width</span>:<span class="number">100px</span> + <span class="number">50px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="selector-class">.triangleStyle</span>(bottom,blue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要使用伪元素的时候，使用&amp;，代表当前元素    </span></span><br><span class="line">    <span class="selector-tag">&amp;</span>：<span class="selector-tag">hover</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">500px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h5><p>具体的使用见文档：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a></p><ul><li>变量</li><li>混合</li><li>嵌套</li><li>运算</li><li>函数</li><li>作用域</li><li>注释</li><li>导入</li></ul><h3 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h3><blockquote><p>本节课的内容和webpack无关！！！</p></blockquote><h4 id="什么是PostCss"><a href="#什么是PostCss" class="headerlink" title="什么是PostCss"></a>什么是PostCss</h4><p>学习到现在，可以看出，<code>CSS</code>工程化面临着诸多问题，而解决这些问题的方案多种多样。</p><p>如果把<code>CSS</code>单独拎出来看，光是样式本身，就有很多事情要处理。</p><p>既然有这么多事情要处理，何不把这些事情集中到一起统一处理呢？</p><p><code>PostCss</code>就是基于这样的理念出现的。</p><p><code>PostCss</code>类似于一个编译器，可以将样式源码编译成最终的<code>CSS</code>代码</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111745786.png"></p><p>看上去是不是和<code>LESS</code>、<code>SASS</code>一样呢？</p><p>但<code>PostCss</code>和<code>LESS</code>、<code>SASS</code>的思路不同，它其实只做一些代码分析之类的事情，将分析的结果交给插件，具体的代码转换操作是插件去完成的。</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111745688.png"></p><p>官方的一张图更能说明<code>postcss</code>的处理流程：</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111745727.png"></p><blockquote><p>这一点有点像webpack，webpack本身仅做依赖分析、抽象语法树分析，其他的操作是靠插件和加载器完成的。</p></blockquote><p>官网地址：<a href="https://postcss.org/">https://postcss.org/</a><br>        github地址：<a href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>PostCss</code>是基于<code>node</code>编写的，因此可以使用<code>npm</code>安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D postcss</span><br></pre></td></tr></table></figure><p><code>postcss</code>库提供了对应的js api用于转换代码，如果你想使用postcss的一些高级功能，或者想开发<code>postcss</code>插件，就要<code>api</code>使用<code>postcss</code>，<code>api</code>的文档地址是：<a href="http://api.postcss.org/">http://api.postcss.org/</a></p><p>不过绝大部分时候，我们都是使用者，并不希望使用代码的方式来使用<code>PostCss</code></p><p>因此，我们可以再安装一个<code>postcss-cli</code>，通过命令行来完成编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D postcss-cli</span><br></pre></td></tr></table></figure><p><code>postcss-cli</code>提供一个命令，它调用<code>postcss</code>中的<code>api</code>来完成编译</p><p>命令的使用方式为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss 源码文件 -o 输出文件</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>和<code>webpack</code>类似，<code>postcss</code>有自己的配置文件，该配置文件会影响<code>postcss</code>的某些编译行为。</p><p>配置文件的默认名称是：<code>postcss.config.js</code></p><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">map</span>: <span class="literal">false</span>, <span class="comment">//关闭source-map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>光使用postcss是没有多少意义的，要让它真正的发挥作用，需要插件</p><p><code>postcss</code>的插件市场：<a href="https://www.postcss.parts/">https://www.postcss.parts/</a></p><p>下面罗列一些<code>postcss</code>的常用插件</p><h5 id="postcss-preset-env"><a href="#postcss-preset-env" class="headerlink" title="postcss-preset-env"></a>postcss-preset-env</h5><p>过去使用<code>postcss</code>的时候，往往会使用大量的插件，它们各自解决一些问题</p><p>这样导致的结果是安装插件、配置插件都特别的繁琐</p><p>于是出现了这么一个插件<code>postcss-preset-env</code>，它称之为<code>postcss预设环境</code>，大意就是它整合了很多的常用插件到一起，并帮你完成了基本的配置，你只需要安装它一个插件，就相当于安装了很多插件了。</p><p>安装好该插件后，在<code>postcss</code>配置中加入下面的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: &#123;</span><br><span class="line">        <span class="string">&quot;postcss-preset-env&quot;</span>: &#123;&#125; <span class="comment">// &#123;&#125; 中可以填写插件的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该插件的功能很多，下面一一介绍</p><h6 id="自动的厂商前缀"><a href="#自动的厂商前缀" class="headerlink" title="自动的厂商前缀"></a>自动的厂商前缀</h6><p>某些新的<code>css</code>样式需要在旧版本浏览器中使用厂商前缀方可实现</p><p>例如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该功能在不同的旧版本浏览器中需要书写为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">::-webkit-input-placeholder &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">::-moz-placeholder &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">:-ms-input-placeholder &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">::-ms-input-placeholder &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要完成这件事情，需要使用<code>autoprefixer</code>库。</p><p>而<code>postcss-preset-env</code>内部包含了该库，自动有了该功能。</p><p>如果需要调整<strong>兼容的浏览器</strong>范围，可以通过下面的方式进行配置</p><p><strong>方式1：在postcss-preset-env的配置中加入browsers</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: &#123;</span><br><span class="line">        <span class="string">&quot;postcss-preset-env&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">browsers</span>: [</span><br><span class="line">                <span class="string">&quot;last 2 version&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&gt; 1%&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式2【推荐】：添加 .browserslistrc 文件</strong></p><p>创建文件<code>.browserslistrc</code>，填写配置内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1%</span><br></pre></td></tr></table></figure><p><strong>方式3【推荐】：在package.json的配置中加入browserslist</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;last 2 version&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt; 1%&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>browserslist</code>是一个多行的（数组形式的）标准字符串。</p><p>它的书写规范多而繁琐，详情见：<a href="https://github.com/browserslist/browserslist">https://github.com/browserslist/browserslist</a></p><p>一般情况下，大部分网站都使用下面的格式进行书写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1% in CN</span><br><span class="line">not ie &lt;= 8</span><br></pre></td></tr></table></figure><ul><li><code>last 2 version</code>: 浏览器的兼容最近期的两个版本</li><li><code>&gt; 1% in CN</code>: 匹配中国大于<code>1%</code>的人使用的浏览器， <code>in CN</code>可省略</li><li><code>not ie &lt;= 8</code>: 排除掉版本号小于等于8的IE浏览器</li></ul><blockquote><p>默认情况下，匹配的结果求的是并集</p></blockquote><p>你可以通过网站：<a href="https://browserl.ist/">https://browserl.ist/</a> 对配置结果覆盖的浏览器进行查询，查询时，多行之间使用英文逗号分割</p><blockquote><p>browserlist的数据来自于<a href="http://caniuse.com/">CanIUse</a>网站，由于数据并非实时的，所以不会特别准确</p></blockquote><h6 id="未来的CSS语法"><a href="#未来的CSS语法" class="headerlink" title="未来的CSS语法"></a>未来的CSS语法</h6><p>CSS的某些前沿语法正在制定过程中，没有形成真正的标准，如果希望使用这部分语法，为了浏览器兼容性，需要进行编译</p><p>过去，完成该语法编译的是<code>cssnext</code>库，不过有了<code>postcss-preset-env</code>后，它自动包含了该功能。</p><p>你可以通过<code>postcss-preset-env</code>的<code>stage</code>配置，告知<code>postcss-preset-env</code>需要对哪个阶段的css语法进行兼容处理，它的默认值为2</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;postcss-preset-env&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">stage</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有5个阶段可配置：</p><ul><li><code>Stage 0</code>: <code>Aspirational</code> - 只是一个早期草案，极其不稳定</li><li><code>Stage 1</code>: <code>Experimental</code> - 仍然极其不稳定，但是提议已被<code>W3C</code>公认</li><li><code>Stage 2</code>: <code>Allowable</code> - 虽然还是不稳定，但已经可以使用了</li><li><code>Stage 3</code>: <code>Embraced</code> - 比较稳定，可能将来会发生一些小的变化，它即将成为最终的标准</li><li><code>Stage 4</code>: <code>Standardized</code> - 所有主流浏览器都应该支持的<code>W3C</code>标准</li></ul><p>了解了以上知识后，接下来了解一下未来的<code>css</code>语法，尽管某些语法仍处于非常早期的阶段，但是有该插件存在，编译后仍然可以被浏览器识别</p><ul><li><p><strong>变量</strong></p><ul><li><p>未来的<code>css</code>语法是天然支持变量的</p></li><li><p>在<code>:root&#123;&#125;</code>中定义常用变量，使用<code>--</code>前缀命名变量</p></li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  --lightColor: <span class="number">#ddd</span>;</span><br><span class="line">  --darkColor: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--lightColor);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--darkColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>编译后，仍然可以看到原语法，因为某些新语法的存在并不会影响浏览器的渲染，尽管浏览器可能不认识<br>如果不希望在结果中看到新语法，可以配置<code>postcss-preset-env</code>的<code>preserve</code>为<code>false</code></p></blockquote></li><li><p><strong>自定义选择器</strong></p></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@custom-selector</span> :--heading h1, h2, h3, h4, h5, h6;</span><br><span class="line"><span class="keyword">@custom-selector</span> :--enter :focus,:<span class="attribute">hover</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>:--enter&#123;</span><br><span class="line">    color: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:--heading&#123;</span><br><span class="line">    font-weight:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:--heading.active&#123;</span><br><span class="line">    font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.active</span>,<span class="selector-tag">h2</span><span class="selector-class">.active</span>,<span class="selector-tag">h3</span><span class="selector-class">.active</span>,<span class="selector-tag">h4</span><span class="selector-class">.active</span>,<span class="selector-tag">h5</span><span class="selector-class">.active</span>,<span class="selector-tag">h6</span><span class="selector-class">.active</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>嵌套</strong></p><ul><li>与<code>LESS</code>相同，只不过嵌套的选择器前必须使用符号<code>&amp;</code></li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    &amp; <span class="selector-class">.b</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &amp; &gt; <span class="selector-class">.b</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>编译后</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span>&gt;<span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="postcss-apply"><a href="#postcss-apply" class="headerlink" title="postcss-apply"></a>postcss-apply</h5><p>该插件可以支持在<code>css</code>中书写属性集</p><p>类似于<code>LESS</code>中的混入，可以利用<code>CSS</code>的新语法定义一个<code>CSS</code>代码片段，然后在需要的时候应用它</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --center: &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="variable">@apply</span> --center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上，该功能也属于cssnext，不知为何<code>postcss-preset-env</code>没有支持</p></blockquote><h5 id="postcss-color-function"><a href="#postcss-color-function" class="headerlink" title="postcss-color-function"></a>postcss-color-function</h5><p>该插件支持在源码中使用一些颜色函数</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 使用颜色#aabbcc，不做任何处理，等同于直接书写 #aabbcc */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span>);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc透明度设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> a(<span class="number">90%</span>));</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc的红色部分设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> red(<span class="number">90%</span>));</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调亮50%（更加趋近于白色），类似于less中的lighten函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> tint(<span class="number">50%</span>));</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调暗50%（更加趋近于黑色），类似于less中的darken函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> shade(<span class="number">50%</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 使用颜色#aabbcc，不做任何处理，等同于直接书写 #aabbcc */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">170</span>, <span class="number">187</span>, <span class="number">204</span>);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc透明度设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">170</span>, <span class="number">187</span>, <span class="number">204</span>, <span class="number">0.9</span>);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc的红色部分设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">230</span>, <span class="number">187</span>, <span class="number">204</span>);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调亮50%（更加趋近于白色），类似于less中的lighten函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">213</span>, <span class="number">221</span>, <span class="number">230</span>);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调暗50%（更加趋近于黑色），类似于less中的darken函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">85</span>, <span class="number">94</span>, <span class="number">102</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩展-postcss-import"><a href="#扩展-postcss-import" class="headerlink" title="[扩展]postcss-import"></a>[扩展]postcss-import</h5><p>该插件可以让你在<code>postcss</code>文件中导入其他样式代码，通过该插件可以将它们合并</p><blockquote><p>由于后续的课程中，会将postcss加入到webpack中，而webpack本身具有依赖分析的功能，所以该插件的实际意义不大</p></blockquote><h5 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h5><blockquote><p>官网：<a href="https://stylelint.io/">https://stylelint.io/</a></p></blockquote><p>在实际的开发中，我们可能会错误的或不规范的书写一些<code>css</code>代码，<code>stylelint</code>插件会即时的发现错误</p><p>由于不同的公司可能使用不同的<code>CSS</code>书写规范，<code>stylelint</code>为了保持灵活，它本身并没有提供具体的规则验证</p><p>你需要安装或自行编写规则验证方案</p><p>通常，我们会安装<code>stylelint-config-standard</code>库来提供标准的CSS规则判定</p><p>安装好后，我们需要告诉<code>stylelint</code>使用该库来进行规则验证</p><p>告知的方式有多种，比较常见的是使用文件<code>.stylelintrc</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.styleintrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: <span class="string">&quot;stylelint-config-standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果你的代码出现不规范的地方，编译时将会报出错误</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: #f4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111745671.png"></p><p>发生了两处错误：</p><ol><li>缩进应该只有两个空格</li><li>十六进制的颜色值不正确</li></ol><p>如果某些规则并非你所期望的，可以在配置中进行设置</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: <span class="string">&quot;stylelint-config-standard&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;indentation&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置为<code>null</code>可以禁用该规则，或者设置为4，表示一个缩进有4个空格。具体的设置需要参见<code>stylelint</code>文档：<a href="https://stylelint.io/">https://stylelint.io/</a></p><p>但是这种错误报告需要在编译时才会发生，如果我希望在编写代码时就自动在编辑器里报错呢？</p><p>既然想在编辑器里达到该功能，那么就要在编辑器里做文章</p><p>安装<code>vscode</code>的插件<code>stylelint</code>即可，它会读取你工程中的配置文件，按照配置进行实时报错</p><blockquote><p>实际上，如果你拥有了<code>stylelint</code>插件，可以不需要在postcss中使用该插件了</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>文件结构</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">│  .browserslistrc <span class="comment">//兼容浏览器，配置文件(手动配置)</span></span><br><span class="line">│  .stylelintrc <span class="comment">//书写规范(自动配置)</span></span><br><span class="line">│</span><br><span class="line">│  package-lock.json <span class="comment">//webpack的配置文件(自动生成)</span></span><br><span class="line">│  package.json <span class="comment">//webpack的初始化文件(自动生成)</span></span><br><span class="line">│</span><br><span class="line">│  postcss.config.js <span class="comment">//postcss配置文件(手动配置)</span></span><br><span class="line">│  webpack.config.js <span class="comment">//webpack配置文件(手动配置)</span></span><br><span class="line">│  </span><br><span class="line">├─public</span><br><span class="line">│      index.html <span class="comment">//html文件</span></span><br><span class="line">│      </span><br><span class="line">└─src</span><br><span class="line">    │  index.js <span class="comment">//js文件</span></span><br><span class="line">    │  </span><br><span class="line">    └─assets</span><br><span class="line">            index.pcss <span class="comment">//前瞻的css文件</span></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">├─├─package.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^3.4.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcss&quot;</span>: <span class="string">&quot;^7.0.36&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcss-loader&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcss-preset-env&quot;</span>: <span class="string">&quot;^6.7.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;style-loader&quot;</span>: <span class="string">&quot;^1.1.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;stylelint-config-standard&quot;</span>: <span class="string">&quot;^19.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^4.41.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.10&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.11.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">├─├─index<span class="selector-class">.html</span></span><br><span class="line">HTML5结构，没有内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">├─├─index<span class="selector-class">.pcss</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">--dangerColor: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.danger</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--dangerColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">├─├─index<span class="selector-class">.js</span></span><br><span class="line">import styles <span class="selector-tag">from</span>  &quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/assets/index.pcss<span class="string">&quot;;</span></span><br><span class="line"><span class="string">console.log(styles)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">├─├─webpack.config.js</span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">    map: false, //关闭source-map</span></span><br><span class="line"><span class="string">    plugins: &#123;</span></span><br><span class="line"><span class="string">        &quot;</span>postcss-preset-env<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">            stage: 0, //哪怕是处于草案阶段的语法，也需要转换</span></span><br><span class="line"><span class="string">            preserve: false</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">├─├─webpack.config.js</span></span><br><span class="line"><span class="string">const HtmlWebpackPlugin = require(&quot;</span>html-webpack-plugin<span class="string">&quot;)</span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">    mode: &quot;</span>development<span class="string">&quot;,</span></span><br><span class="line"><span class="string">    devtool: &quot;</span>source-map<span class="string">&quot;,</span></span><br><span class="line"><span class="string">    module: &#123;</span></span><br><span class="line"><span class="string">        rules: [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                test: /\.pcss$/, use: [&quot;</span>style-loader<span class="string">&quot;, &quot;</span>css-loader?modules<span class="string">&quot;, &quot;</span>postcss-loader<span class="string">&quot;]</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    devServer: &#123;</span></span><br><span class="line"><span class="string">        open: true</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    plugins: [</span></span><br><span class="line"><span class="string">        new HtmlWebpackPlugin(&#123;</span></span><br><span class="line"><span class="string">            template: &quot;</span>https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/public/index.html<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">├─├─.stylelintrc</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;</span>extends<span class="string">&quot;: &quot;</span>stylelint-config-standard<span class="string">&quot;,</span></span><br><span class="line"><span class="string">    &quot;</span>rules<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;</span>indentation<span class="string">&quot;: 4 //空格为4个，标准，如果不是4个，就会报错</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">├─├─.browserslistrc</span></span><br><span class="line"><span class="string">last 3 version</span></span><br><span class="line"><span class="string">&gt; 1%</span></span><br><span class="line"><span class="string">not ie &lt;= 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后使用webpack进行打包</span></span><br></pre></td></tr></table></figure><h3 id="分离css文件"><a href="#分离css文件" class="headerlink" title="分离css文件"></a>分离css文件</h3><p>目前，<code>css</code>代码被<code>css-loader</code>转换后，交给的是<code>style-loader</code>进行处理。</p><p><code>style-loader</code>使用的方式是用一段<code>js</code>代码，将样式加入到<code>style</code>元素中。</p><p>而实际的开发中，我们往往希望依赖的样式最终形成一个css文件</p><p>此时，就需要用到一个库：<code>mini-css-extract-plugin</code></p><p>该库提供了1个<code>plugin</code>和1个<code>loader</code></p><ul><li><code>plugin</code>：负责生成<code>css</code>文件</li><li><code>loader</code>：负责记录要生成的<code>css</code>文件的内容，同时导出开启<code>css-module</code>后的样式对象</li></ul><p>使用方式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, </span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader, </span><br><span class="line">                    <span class="string">&quot;css-loader?modules&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            <span class="attr">filename</span>:<span class="string">&#x27;css/[name].css&#x27;</span>, <span class="comment">//生成的css文件名</span></span><br><span class="line">        <span class="attr">chunkFilename</span>: <span class="string">&#x27;css/[id].css&#x27;</span></span><br><span class="line">        &#125;) <span class="comment">//负责生成css文件</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置生成的文件名</strong></p><p>同<code>output.filename</code>的含义一样，即根据<code>chunk</code>生成的样式文件名</p><p>配置生成的文件名，例如<code>[name].[contenthash:5].css</code></p><p>默认情况下，每个<code>chunk</code>对应一个<code>css</code>文件</p><h2 id="JS兼容性"><a href="#JS兼容性" class="headerlink" title="JS兼容性"></a>JS兼容性</h2><h3 id="babel的安装和使用"><a href="#babel的安装和使用" class="headerlink" title="babel的安装和使用"></a>babel的安装和使用</h3><blockquote><p>官网：<a href="https://babeljs.io/">https://babeljs.io/</a><br>民间中文网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a></p></blockquote><h4 id="babel简介"><a href="#babel简介" class="headerlink" title="babel简介"></a>babel简介</h4><p><code>babel</code>一词来自于希伯来语，直译为巴别塔</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111745841.png"></p><p>巴别塔象征的统一的国度、统一的语言</p><p>而今天的<code>JS</code>世界缺少一座巴别塔，不同版本的浏览器能识别的<code>ES</code>标准并不相同，就导致了开发者面对不同版本的浏览器要使用不同的语言，和古巴比伦一样，前端开发也面临着这样的困境。</p><p><code>babel</code>的出现，就是用于解决这样的问题，它是一个编译器，可以把不同标准书写的语言，编译为统一的、能被各种浏览器识别的语言</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111745225.png"></p><p>由于语言的转换工作灵活多样，<code>babel</code>的做法和<code>postcss</code>、<code>webpack</code>差不多，它本身仅提供一些分析功能，真正的转换需要依托于插件完成</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111745908.png"></p><h4 id="babel的安装"><a href="#babel的安装" class="headerlink" title="babel的安装"></a>babel的安装</h4><p><code>babel</code>可以和构建工具联合使用，也可以独立使用</p><p>如果要独立的使用<code>babel</code>，需要安装下面两个库：</p><ul><li><code>@babel/core</code>：<code>babel</code>核心库，提供了编译所需的所有<code>api</code></li><li><code>@babel/cli</code>：提供一个命令行工具，调用核心库的<code>api</code>完成编译</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/core @babel/cli</span><br></pre></td></tr></table></figure><h4 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h4><p><code>@babel/cli</code>的使用极其简单</p><p>它提供了一个命令<code>babel</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按文件编译</span></span><br><span class="line">babel 要编译的文件 -o 编辑结果文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按目录编译</span></span><br><span class="line">babel 要编译的整个目录 -d 编译结果放置的目录</span><br></pre></td></tr></table></figure><h4 id="babel的配置"><a href="#babel的配置" class="headerlink" title="babel的配置"></a>babel的配置</h4><p>可以看到，<code>babel</code>本身没有做任何事情，真正的编译要依托于<strong>babel插件</strong>和<strong>babel预设</strong>来完成</p><blockquote><p>babel预设和postcss预设含义一样，是多个插件的集合体，用于解决一系列常见的兼容问题</p></blockquote><p>如何告诉<code>babel</code>要使用哪些插件或预设呢？需要通过一个配置文件<code>.babelrc</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="babel预设"><a href="#babel预设" class="headerlink" title="babel预设"></a>babel预设</h3><p><code>babel</code>有多种预设，最常见的预设是<code>@babel/preset-env</code></p><p><code>@babel/preset-env</code>可以让你使用最新的<code>JS</code>语法，而无需针对每种语法转换设置具体的插件</p><p><strong>配置</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;@babel/preset-env&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>兼容的浏览器</strong></p><p><code>@babel/preset-env</code>需要根据兼容的浏览器范围来确定如何编译，和<code>postcss</code>一样，可以使用文件<code>.browserslistrc</code>来描述浏览器的兼容范围</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">last 3 version</span><br><span class="line">&gt; 1%</span><br><span class="line">not ie &lt;= 8</span><br></pre></td></tr></table></figure><p><strong>自身的配置</strong></p><p>和<code>postcss-preset-env</code>一样，<code>@babel/preset-env</code>自身也有一些配置</p><blockquote><p>具体的配置见：<a href="https://www.babeljs.cn/docs/babel-preset-env#options">https://www.babeljs.cn/docs/babel-preset-env#options</a></p></blockquote><p>配置方式是：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">        [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">&quot;配置项1&quot;</span>: <span class="string">&quot;配置值&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;配置项2&quot;</span>: <span class="string">&quot;配置值&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;配置项3&quot;</span>: <span class="string">&quot;配置值&quot;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个比较常见的配置项是<code>usebuiltins</code>，该配置的默认值是false</p><p>它有什么用呢？由于该预设仅转换新的语法，并不对新的API进行任何处理</p><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>转换的结果为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果遇到没有<code>Promise</code>构造函数的旧版本浏览器，该代码就会报错</p><p>而配置<code>usebuiltins</code>可以在编译结果中注入这些新的<code>API</code>，它的值默认为<code>false</code>，表示不注入任何新的<code>API</code>，可以将其设置为<code>usage</code>，表示根据<code>API</code>的使用情况，按需导入<code>API</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">        [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="babel插件"><a href="#babel插件" class="headerlink" title="babel插件"></a>babel插件</h3><blockquote><p>上节课补充：@babel/polyfill 已过时，目前被<code>core-js</code>和<code>generator-runtime</code>所取代</p></blockquote><p>除了预设可以转换代码之外，插件也可以转换代码，它们的顺序是：</p><ul><li>插件在 <code>Presets</code> 前运行。</li><li>插件顺序从前往后排列。</li><li><code>Preset</code> 顺序是颠倒的（从后往前）。</li></ul><p>通常情况下，<code>@babel/preset-env</code>只转换那些已经形成正式标准的语法，对于某些处于早期阶段、还没有确定的语法不做转换。</p><p>如果要转换这些语法，就要单独使用插件</p><p>下面随便列举一些插件</p><h4 id="babel-plugin-proposal-class-properties"><a href="#babel-plugin-proposal-class-properties" class="headerlink" title="@babel/plugin-proposal-class-properties"></a><code>@babel/plugin-proposal-class-properties</code></h4><p>该插件可以让你在类中书写初始化字段</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="babel-plugin-proposal-function-bind"><a href="#babel-plugin-proposal-function-bind" class="headerlink" title="@babel/plugin-proposal-function-bind"></a><code>@babel/plugin-proposal-function-bind</code></h4><p>该插件可以让你轻松的为某个方法绑定this</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.loginId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">loginId</span>: <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj::Print(); <span class="comment">//相当于：Print.call(obj);</span></span><br></pre></td></tr></table></figure><blockquote><p>遗憾的是，目前vscode无法识别该语法，会在代码中报错，虽然并不会有什么实际性的危害，但是影响观感</p></blockquote><h4 id="babel-plugin-proposal-optional-chaining"><a href="#babel-plugin-proposal-optional-chaining" class="headerlink" title="@babel/plugin-proposal-optional-chaining"></a><code>@babel/plugin-proposal-optional-chaining</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123;</span><br><span class="line">      <span class="attr">baz</span>: <span class="number">42</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = obj?.foo?.bar?.baz; <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safe = obj?.qux?.baz; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="babel-plugin-transform-remove-console"><a href="#babel-plugin-transform-remove-console" class="headerlink" title="babel-plugin-transform-remove-console"></a><code>babel-plugin-transform-remove-console</code></h4><p>该插件会移除源码中的控制台输出语句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a><code>@babel/plugin-transform-runtime</code></h4><p>用于提供一些公共的<code>API</code>，这些<code>API</code>会帮助代码转换</p><h3 id="拓展-对类的转换"><a href="#拓展-对类的转换" class="headerlink" title="[拓展]对类的转换"></a>[拓展]对类的转换</h3><ul><li><strong>source.js</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    prop1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    method2 = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">b = <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prop2 = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">method1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">method3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;method3&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> method4 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;method4&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>target.js</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.js</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; right[<span class="built_in">Symbol</span>.hasInstance]) &#123;</span><br><span class="line">        <span class="keyword">return</span> !!right[<span class="built_in">Symbol</span>.hasInstance](left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">instanceof</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断instance 是不是Constructor的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!_instanceof(instance, Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//props: [&#123;key:&quot;xxx&quot;, value:&quot;xxxxxx&quot;&#125;, &#123;key:&quot;ccc&quot;, value:function()&#123;&#125;&#125;]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">        descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">        descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> descriptor)</span><br><span class="line">            descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (protoProps)</span><br><span class="line">        _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">    <span class="keyword">if</span> (staticProps)</span><br><span class="line">        _defineProperties(Constructor, staticProps);</span><br><span class="line">    <span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperty</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">            <span class="attr">value</span>: value, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A =</span><br><span class="line">    <span class="comment">//该立即执行函数的返回结果，应该是一个构造函数A</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数A，对应类中的constructor</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//转换：参数默认值</span></span><br><span class="line">            <span class="keyword">var</span> b = <span class="built_in">arguments</span>.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">0</span>] : <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//类调用检查</span></span><br><span class="line">            _classCallCheck(<span class="built_in">this</span>, A);</span><br><span class="line">            <span class="comment">//定义一个属性：给this定义一个属性prop1，赋值为1，类似于 this.prop1 = 1;</span></span><br><span class="line">            _defineProperty(<span class="built_in">this</span>, <span class="string">&quot;prop1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将箭头函数方法，作为普通属性定义，箭头函数方法并不在原型上</span></span><br><span class="line">            _defineProperty(<span class="built_in">this</span>, <span class="string">&quot;method2&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, args = <span class="keyword">new</span> <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">                    args[_key] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">console</span>.log(args);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.prop2 = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为构造函数A，定义原型方法，以及静态方法</span></span><br><span class="line">        _createClass(A, [&#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&quot;method1&quot;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">method1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;], [&#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&quot;method3&quot;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">method3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;method3&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">_defineProperty(A, <span class="string">&quot;method4&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;method4&quot;</span>, A);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="拓展-async和await的转换"><a href="#拓展-async和await的转换" class="headerlink" title="[拓展]async和await的转换"></a>[拓展]async和await的转换</h3><ul><li><strong>source</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> A();</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> A();</span><br><span class="line">    <span class="keyword">return</span> b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B().then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure><ul><li><strong>target</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGeneratorStep</span>(<span class="params">gen, resolve, reject, _next, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> info = gen.next(arg);</span><br><span class="line">        <span class="keyword">var</span> value = info.value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(value).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            _next(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> b = <span class="keyword">yield</span> A();</span><br><span class="line">        <span class="keyword">const</span> c = <span class="keyword">yield</span> A();</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> gen = fn();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            asyncGeneratorStep(gen, resolve, reject, _next, value);</span><br><span class="line">        &#125;</span><br><span class="line">        _next(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B().then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="性能优化概述"><a href="#性能优化概述" class="headerlink" title="性能优化概述"></a>性能优化概述</h3><p>本章所讲的性能优化主要体现在三个方面：</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111746481.png"></p><p><strong>构建性能</strong></p><p>这里所说的构建性能，是指在<strong>开发阶段的构建性能</strong>，而不是生产环境的构建性能</p><p>优化的目标，<strong>是降低从打包开始，到代码效果呈现所经过的时间</strong></p><p>构建性能会影响开发效率。构建性能越高，开发过程中时间的浪费越少</p><p><strong>传输性能</strong></p><p>传输性能是指，打包后的<code>JS</code>代码传输到浏览器经过的时间</p><p>在优化传输性能时要考虑到：</p><ol><li>总传输量：所有需要传输的<code>JS</code>文件的内容加起来，就是总传输量，重复代码越少，总传输量越少</li><li>文件数量：当访问页面时，需要传输的<code>JS</code>文件数量，文件数量越多，<code>http</code>请求越多，响应速度越慢</li><li>浏览器缓存：<code>JS</code>文件会被浏览器缓存，被缓存的文件不会再进行传输</li></ol><p><strong>运行性能</strong></p><p>运行性能是指，<code>JS</code>代码在浏览器端的运行速度</p><p>它主要取决于我们如何书写高性能的代码</p><p><strong>永远不要过早的关注于性能</strong>，因为你在开发的时候，无法完全预知最终的运行性能，过早的关注性能会极大的降低开发效率</p><hr><p>性能优化主要从上面三个维度入手</p><p><strong>性能优化没有完美的解决方案，需要具体情况具体分析</strong></p><h3 id="减少模块解析"><a href="#减少模块解析" class="headerlink" title="减少模块解析"></a>减少模块解析</h3><h4 id="什么叫做模块解析？"><a href="#什么叫做模块解析？" class="headerlink" title="什么叫做模块解析？"></a>什么叫做模块解析？</h4><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111746351.png"></p><p>模块解析包括：抽象语法树分析、依赖分析、模块语法替换</p><h4 id="不做模块解析会怎样？"><a href="#不做模块解析会怎样？" class="headerlink" title="不做模块解析会怎样？"></a>不做模块解析会怎样？</h4><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111746331.png"></p><p>如果某个模块不做解析，该模块经过<code>loader</code>处理后的代码就是最终代码。</p><p>如果没有<code>loader</code>对该模块进行处理，该模块的源码就是最终打包结果的代码。</p><p>如果不对某个模块进行解析，可以缩短构建时间</p><h4 id="哪些模块不需要解析？"><a href="#哪些模块不需要解析？" class="headerlink" title="哪些模块不需要解析？"></a>哪些模块不需要解析？</h4><p>模块中无其他依赖：一些已经打包好的第三方库，比如<code>jquery</code></p><h4 id="如何让某个模块不要解析？"><a href="#如何让某个模块不要解析？" class="headerlink" title="如何让某个模块不要解析？"></a>如何让某个模块不要解析？</h4><p>配置<code>module.noParse</code>，它是一个正则，被正则匹配到的模块不会解析</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">noParse</span>: <span class="regexp">/test/</span> <span class="comment">//正则匹配，匹配到的模块不会被解析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化loader性能"><a href="#优化loader性能" class="headerlink" title="优化loader性能"></a>优化loader性能</h3><h4 id="进一步限制loader的应用范围"><a href="#进一步限制loader的应用范围" class="headerlink" title="进一步限制loader的应用范围"></a>进一步限制loader的应用范围</h4><p>思路是：对于某些库，不使用<code>loader</code></p><p>例如：<code>babel-loader</code>可以转换<code>ES6</code>或更高版本的语法，可是有些库本身就是用<code>ES5</code>语法书写的，不需要转换，使用<code>babel-loader</code>反而会浪费构建时间</p><p><code>lodash</code>就是这样的一个库</p><blockquote><p>lodash是在ES5之前出现的库，使用的是ES3语法</p></blockquote><p>通过<code>module.rule.exclude</code>或<code>module.rule.include</code>，排除或仅包含需要应用loader的场景</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/lodash/</span>,</span><br><span class="line">                use: <span class="string">&quot;babel-loader&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果暴力一点，甚至可以排除掉<code>node_modules</code>目录中的模块，或仅转换<code>src</code>目录的模块</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                </span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>, <span class="comment">//排除node_modules目录的模块</span></span><br><span class="line">                <span class="comment">//或</span></span><br><span class="line">                <span class="comment">// include: /src/, //只包含src目录的模块</span></span><br><span class="line">                </span><br><span class="line">                use: <span class="string">&quot;babel-loader&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种做法是对loader的范围进行进一步的限制，和noParse不冲突，想想看，为什么不冲突</p></blockquote><h4 id="缓存loader的结果"><a href="#缓存loader的结果" class="headerlink" title="缓存loader的结果"></a>缓存loader的结果</h4><p>我们可以基于一种假设：如果某个文件内容不变，经过相同的<code>loader</code>解析后，解析后的结果也不变</p><p>于是，可以将<code>loader</code>的解析结果保存下来，让后续的解析直接使用保存的结果</p><p><code>cache-loader</code>可以实现这样的功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;cache-loader&#x27;</span>, ...loaders]</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有趣的是，<code>cache-loader</code>放到最前面，却能够决定后续的<code>loader</code>是否运行</p><p>实际上，<code>loader</code>的运行过程中，还包含一个过程，即<code>pitch</code></p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111746058.png"></p><p><code>cache-loader</code>还可以实现各自自定义的配置，具体方式见文档</p><h4 id="为loader的运行开启多线程"><a href="#为loader的运行开启多线程" class="headerlink" title="为loader的运行开启多线程"></a>为loader的运行开启多线程</h4><p><code>thread-loader</code>会开启一个线程池，线程池中包含适量的线程</p><p>它会把后续的<code>loader</code>放到线程池的线程中运行，以提高构建效率</p><p>由于后续的<code>loader</code>会放到新的线程中，所以，后续的<code>loader</code>不能：</p><ul><li>使用 <code>webpack api</code> 生成文件</li><li>无法使用自定义的 <code>plugin api</code></li><li>无法访问 <code>webpack options</code></li></ul><blockquote><p>在实际的开发中，可以进行测试，来决定<code>thread-loader</code>放到什么位置</p></blockquote><p><strong>特别注意</strong>，开启和管理线程需要消耗时间，在小型项目中使用<code>thread-loader</code>反而会增加构建时间</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="comment">// &#123;</span></span><br><span class="line">                    <span class="comment">//   loader: &quot;cache-loader&quot;,</span></span><br><span class="line">                    <span class="comment">//   options:&#123;</span></span><br><span class="line">                    <span class="comment">//       cacheDirectory: &quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/cache&quot;</span></span><br><span class="line">                    <span class="comment">//   &#125;</span></span><br><span class="line">                    <span class="comment">// &#125;,</span></span><br><span class="line">                    <span class="string">&quot;thread-loader&quot;</span>, <span class="comment">//开启一个线程池</span></span><br><span class="line">                    <span class="string">&quot;babel-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="热替换-HMR"><a href="#热替换-HMR" class="headerlink" title="热替换 HMR"></a>热替换 HMR</h3><blockquote><p>热替换并不能降低构建时间（可能还会稍微增加），但可以降低代码改动到效果呈现的时间</p></blockquote><p>当使用<code>webpack-dev-server</code>时，考虑代码改动到效果呈现的过程</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111746389.png" alt="|400"></p><p>而使用了热替换后，流程发生了变化</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111746339.png" alt="|400"></p><h4 id="使用和原理"><a href="#使用和原理" class="headerlink" title="使用和原理"></a>使用和原理</h4><ol><li>更改配置</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">hot</span>:<span class="literal">true</span> <span class="comment">// 开启HMR</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[ </span><br><span class="line">    <span class="comment">// 可选</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>更改代码</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123; <span class="comment">// 是否开启了热更新</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept() <span class="comment">// 接受热更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这段代码会参与最终运行！</p><p>当开启了热更新后，<code>webpack-dev-server</code>会向打包结果中注入<code>module.hot</code>属性</p><p>默认情况下，<code>webpack-dev-server</code>不管是否开启了热更新，当重新打包后，都会调用<code>location.reload</code>刷新页面</p><p>但如果运行了<code>module.hot.accept()</code>，将改变这一行为</p><p><code>module.hot.accept()</code>的作用是让<code>webpack-dev-server</code>通过<code>socket</code>管道，把服务器更新的内容发送到浏览器</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111747451.png" alt="|300"></p><p>然后，将结果交给插件<code>HotModuleReplacementPlugin</code>注入的代码执行</p><p>插件<code>HotModuleReplacementPlugin</code>会根据覆盖原始代码，然后让代码重新执行</p><p><strong>所以，热替换发生在代码运行期</strong></p><h4 id="样式热替换"><a href="#样式热替换" class="headerlink" title="样式热替换"></a>样式热替换</h4><p>对于样式也是可以使用热替换的，但需要使用<code>style-loader</code></p><p>因为热替换发生时，<code>HotModuleReplacementPlugin</code>只会简单的重新运行模块代码</p><p>因此<code>style-loader</code>的代码一运行，就会重新设置<code>style</code>元素中的样式</p><p>而<code>mini-css-extract-plugin</code>，由于它生成文件是在<strong>构建期间</strong>，运行期间并会也无法改动文件，因此它对于热替换是无效的</p><h3 id="手动分包"><a href="#手动分包" class="headerlink" title="手动分包"></a>手动分包</h3><h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>手动分包的总体思路是：</p><ol><li>先单独的打包公共模块</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111747630.png" alt="单独打包公共模块"></p><p>公共模块会被打包成为动态链接库(<code>dll Dynamic Link Library</code>)，并生成资源清单</p><ol start="2"><li>根据入口模块进行正常打包</li></ol><p>打包时，如果发现模块中使用了资源清单中描述的模块，则不会形成下面的代码结构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码，入口文件index.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span></span><br><span class="line">_.isArray($(<span class="string">&quot;.red&quot;</span>));</span><br></pre></td></tr></table></figure><p>由于资源清单中包含<code>jquery</code>和<code>lodash</code>两个模块，因此打包结果的大致格式是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)(&#123;  </span><br><span class="line">    <span class="comment">// index.js文件的打包结果并没有变化  </span></span><br><span class="line">    <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/src/index.js&quot;</span>:  <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>)</span>&#123;    <span class="keyword">var</span> $ = __webpack_require__(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/node_modules/jquery/index.js&quot;</span>)    <span class="keyword">var</span> _ = __webpack_require__(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/node_modules/lodash/index.js&quot;</span>)    _.isArray($(<span class="string">&quot;.red&quot;</span>));  &#125;,  </span><br><span class="line">    <span class="comment">// 由于资源清单中存在，jquery的代码并不会出现在这里  </span></span><br><span class="line">    <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/node_modules/jquery/index.js&quot;</span>:  <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>)</span>&#123;    <span class="built_in">module</span>.exports = jquery;  &#125;,  </span><br><span class="line">    <span class="comment">// 由于资源清单中存在，lodash的代码并不会出现在这里  </span></span><br><span class="line">    <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/node_modules/lodash/index.js&quot;</span>:  <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>)</span>&#123;    <span class="built_in">module</span>.exports = lodash;  &#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="打包公共模块"><a href="#打包公共模块" class="headerlink" title="打包公共模块"></a>打包公共模块</h4><p>打包公共模块是一个<strong>独立的</strong>打包过程</p><ol><li>单独打包公共模块，暴露变量名</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,  </span><br><span class="line">    <span class="attr">entry</span>: &#123;    </span><br><span class="line">        <span class="attr">jquery</span>: [<span class="string">&quot;jquery&quot;</span>],    </span><br><span class="line">        <span class="attr">lodash</span>: [<span class="string">&quot;lodash&quot;</span>]  &#125;,  </span><br><span class="line">    <span class="attr">output</span>: &#123;    </span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;dll/[name].js&quot;</span>,    </span><br><span class="line">        <span class="attr">library</span>: <span class="string">&quot;[name]&quot;</span>  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用<code>DllPlugin</code>生成资源清单</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    <span class="attr">plugins</span>: [    </span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;     </span><br><span class="line">            <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dll&quot;</span>, <span class="string">&quot;[name].manifest.json&quot;</span>), </span><br><span class="line">            <span class="comment">//资源清单的保存位置      </span></span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;[name]&quot;</span></span><br><span class="line">            <span class="comment">//资源清单中，暴露的变量名    </span></span><br><span class="line">        &#125;)  </span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行后，即可完成公共模块打包</p><h4 id="使用公共模块"><a href="#使用公共模块" class="headerlink" title="使用公共模块"></a>使用公共模块</h4><ol><li>在页面中手动引入公共模块</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/dll/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/dll/lodash.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>重新设置<code>clean-webpack-plugin</code></li></ol><p>如果使用了插件<code>clean-webpack-plugin</code>，为了避免它把公共模块清除，需要做出以下配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin(&#123;  </span><br><span class="line">    <span class="comment">// 要清除的文件或目录  </span></span><br><span class="line">    <span class="comment">// 排除掉dll目录本身和它里面的文件  </span></span><br><span class="line">    <span class="attr">cleanOnceBeforeBuildPatterns</span>: [<span class="string">&quot;**/*&quot;</span>, <span class="string">&#x27;!dll&#x27;</span>, <span class="string">&#x27;!dll/*&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>目录和文件的匹配规则使用的是<a href="https://github.com/sindresorhus/globby#globbing-patterns">globbing patterns</a></p></blockquote><ol start="3"><li>使用<code>DllReferencePlugin</code>控制打包结果</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    <span class="attr">plugins</span>:[    </span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;      </span><br><span class="line">            <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/dll/jquery.manifest.json&quot;</span>)    </span><br><span class="line">        &#125;),    </span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;     </span><br><span class="line">            <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/dll/lodash.manifest.json&quot;</span>)    </span><br><span class="line">        &#125;)  </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>手动打包的过程</strong>：</p><ol><li>开启<code>output.library</code>暴露公共模块</li><li>用<code>DllPlugin</code>创建资源清单</li><li>用<code>DllReferencePlugin</code>使用资源清单</li></ol><p><strong>手动打包的注意事项</strong>：</p><ol><li>资源清单不参与运行，可以不放到打包目录中</li><li>记得手动引入公共<code>JS</code>，以及避免被删除</li><li>不要对小型的公共<code>JS</code>库使用</li></ol><p><strong>优点</strong>：</p><ol><li>极大提升自身模块的打包速度</li><li>极大的缩小了自身文件体积</li><li>有利于浏览器缓存第三方库的公共代码</li></ol><p><strong>缺点</strong>：</p><ol><li>使用非常繁琐</li><li>如果第三方库中包含重复代码，则效果不太理想</li></ol><h3 id="自动分包"><a href="#自动分包" class="headerlink" title="自动分包"></a>自动分包</h3><h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>不同与手动分包，自动分包是从<strong>实际的角度</strong>出发，从一个更加<strong>宏观的角度</strong>来控制分包，而一般不对具体哪个包要分出去进行控制</p><p>因此使用自动分包，不仅非常方便，而且更加贴合实际的开发需要</p><p>要控制自动分包，关键是要配置一个合理的<strong>分包策略</strong></p><p>有了分包策略之后，不需要额外安装任何插件，<code>webpack</code>会自动的按照策略进行分包</p><blockquote><p>实际上，webpack在内部是使用<code>SplitChunksPlugin</code>进行分包的<br>过去有一个库<code>CommonsChunkPlugin</code>也可以实现分包，不过由于该库某些地方并不完善，到了<code>webpack4</code>之后，已被<code>SplitChunksPlugin</code>取代</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111747606.png" alt="分包简单流程"></p><p>从分包流程中至少可以看出以下几点：</p><ul><li>分包策略至关重要，它决定了如何分包</li><li>分包时，<code>webpack</code>开启了一个<strong>新的chunk</strong>，对分离的模块进行打包</li><li>打包结果中，公共的部分被提取出来形成了一个单独的文件，它是新<code>chunk</code>的产物</li></ul><h4 id="分包策略的基本配置"><a href="#分包策略的基本配置" class="headerlink" title="分包策略的基本配置"></a>分包策略的基本配置</h4><p><code>webpack</code>提供了<code>optimization</code>配置项，用于配置一些优化信息</p><p>其中<code>splitChunks</code>是分包策略的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    <span class="attr">optimization</span>: &#123;    </span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;      </span><br><span class="line">            <span class="comment">// 分包策略    </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，分包策略有其默认的配置，我们只需要轻微的改动，即可应对大部分分包场景</p><ol><li><strong>chunks</strong></li></ol><p>该配置项用于配置需要应用分包策略的<code>chunk</code></p><p>我们知道，分包是从已有的<code>chunk</code>中分离出新的<code>chunk</code>，那么哪些<code>chunk</code>需要分离呢</p><p><code>chunks</code>有三个取值，分别是：</p><ul><li><code>all</code>: 对于所有的<code>chunk</code>都要应用分包策略</li><li><code>async</code>：【默认】仅针对异步<code>chunk</code>应用分包策略</li><li><code>initial</code>：仅针对普通<code>chunk</code>应用分包策略</li></ul><p>所以，你只需要配置<code>chunks</code>为<code>all</code>即可</p><ol start="2"><li><strong>maxSize</strong></li></ol><p>该配置可以控制包的最大字节数</p><p>如果某个包（包括分出来的包）超过了该值，则<code>webpack</code>会尽可能的将其分离成多个包</p><p>但是不要忽略的是，分包的<strong>基础单位是模块</strong>，如果一个完整的模块超过了该体积，它是无法做到再切割的，因此，尽管使用了这个配置，完全有可能某个包还是会超过这个体积</p><p>另外，该配置看上去很美妙，实际意义其实不大</p><p>因为分包的目的是<strong>提取大量的公共代码</strong>，从而减少总体积和充分利用浏览器缓存</p><p>虽然该配置可以把一些包进行再切分，但是实际的总体积和传输量并没有发生变化</p><blockquote><p>如果要进一步减少公共模块的体积，只能是压缩和<code>tree shaking</code></p></blockquote><h4 id="分包策略的其他配置"><a href="#分包策略的其他配置" class="headerlink" title="分包策略的其他配置"></a>分包策略的其他配置</h4><p>如果不想使用其他配置的默认值，可以手动进行配置：</p><ul><li><strong>automaticNameDelimiter</strong>：新<code>chunk</code>名称的分隔符，默认值~</li><li><strong>minChunks</strong>：一个模块被多少个<code>chunk</code>使用时，才会进行分包，默认值<code>1</code></li><li><strong>minSize</strong>：当分包达到多少字节后才允许被真正的拆分，默认值<code>30000</code></li></ul><h4 id="缓存组"><a href="#缓存组" class="headerlink" title="缓存组"></a>缓存组</h4><p>之前配置的分包策略是全局的</p><p>而实际上，分包策略是基于缓存组的</p><p>每个缓存组提供一套独有的策略，<code>webpack</code>按照缓存组的优先级依次处理每个缓存组，被缓存组处理过的分包不需要再次分包</p><p>默认情况下，<code>webpack</code>提供了两个缓存组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    <span class="attr">optimization</span>:&#123;    </span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;      </span><br><span class="line">            <span class="comment">//全局配置      </span></span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;        </span><br><span class="line">                <span class="comment">// 属性名是缓存组名称，会影响到分包的chunk名        </span></span><br><span class="line">                <span class="comment">// 属性值是缓存组的配置，缓存组继承所有的全局配置，也有自己特殊的配置</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">vendors</span>: &#123;           </span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>, </span><br><span class="line">                <span class="comment">// 当匹配到相应模块时，将这些模块进行单独打包          </span></span><br><span class="line">                priority: -<span class="number">10</span> </span><br><span class="line">                <span class="comment">// 缓存组优先级，优先级越高，该策略越先进行处理，默认值为0        </span></span><br><span class="line">            &#125;,        </span><br><span class="line">            <span class="attr">default</span>: &#123;          </span><br><span class="line">                <span class="attr">minChunks</span>: <span class="number">2</span>,  </span><br><span class="line">                <span class="comment">// 覆盖全局配置，将最小chunk引用数改为2          </span></span><br><span class="line">                <span class="attr">priority</span>: -<span class="number">20</span>, <span class="comment">// 优先级          </span></span><br><span class="line">                <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span> </span><br><span class="line">                <span class="comment">// 重用已经被分离出去的chunk        </span></span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多时候，缓存组对于我们来说没什么意义，因为默认的缓存组就已经够用了</p><p>但是我们同样可以利用缓存组来完成一些事情，比如对公共样式的抽离</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    <span class="attr">optimization</span>: &#123;    </span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;      </span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,      </span><br><span class="line">            <span class="comment">// maxSize: 60000      </span></span><br><span class="line">            <span class="comment">// automaticNameDelimiter: &quot;.&quot;,      </span></span><br><span class="line">            <span class="comment">// minChunks: 1,      </span></span><br><span class="line">            <span class="comment">// minSize: 0      </span></span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;        </span><br><span class="line">                <span class="attr">styles</span>: &#123;          </span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">// 匹配样式模块          </span></span><br><span class="line">                    minSize: <span class="number">0</span>, <span class="comment">// 覆盖默认的最小尺寸，这里仅仅是作为测试          </span></span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span> <span class="comment">// 覆盖默认的最小chunk引用数        </span></span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="attr">module</span>: &#123;    </span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, </span><br><span class="line">                use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>] </span><br><span class="line">            &#125;</span><br><span class="line">        ]  </span><br><span class="line">    &#125;,  <span class="attr">plugins</span>: [    </span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),    </span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;      </span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/public/index.html&quot;</span>,     </span><br><span class="line">            <span class="attr">chunks</span>: [<span class="string">&quot;index&quot;</span>]    &#125;),   </span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;      </span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;[name].[hash:5].css&quot;</span>,      </span><br><span class="line">            <span class="comment">// chunkFilename是配置来自于分割chunk的文件名      </span></span><br><span class="line">            <span class="attr">chunkFilename</span>: <span class="string">&quot;common.[hash:5].css&quot;</span>     </span><br><span class="line">        &#125;)  </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配合多页应用"><a href="#配合多页应用" class="headerlink" title="配合多页应用"></a>配合多页应用</h4><p>虽然现在单页应用是主流，但免不了还是会遇到多页应用</p><p>由于在多页应用中需要为每个<code>html</code>页面指定需要的<code>chunk</code>，这就造成了问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="attr">template</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/public/index.html&quot;</span>,  <span class="attr">chunks</span>: [<span class="string">&quot;index~other&quot;</span>, <span class="string">&quot;vendors~index~other&quot;</span>, <span class="string">&quot;index&quot;</span>]&#125;)</span><br></pre></td></tr></table></figure><p>我们必须手动的指定被分离出去的chunk名称，这不是一种好办法</p><p>幸好<code>html-webpack-plugin</code>的新版本中解决了这一问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D html-webpack-plugin@next</span><br></pre></td></tr></table></figure><p>做出以下配置即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;  <span class="attr">template</span>: <span class="string">&quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/public/index.html&quot;</span>,  <span class="attr">chunks</span>: [<span class="string">&quot;index&quot;</span>]&#125;)</span><br></pre></td></tr></table></figure><p>它会自动的找到被<code>index</code>分离出去的<code>chunk</code>，并完成引用</p><blockquote><p>目前这个版本仍处于测试解决，还未正式发布</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>自动分包的原理其实并不复杂，主要经过以下步骤：</p><ol><li>检查每个<code>chunk</code>编译的结果</li><li>根据分包策略，找到那些满足策略的模块</li><li>根据分包策略，生成新的<code>chunk</code>打包这些模块（代码有所变化）</li><li>把打包出去的模块从原始包中移除，并修正原始包代码</li></ol><p>在代码层面，有以下变动</p><ol><li>分包的代码中，加入一个全局变量，类型为数组，其中包含公共模块的代码</li><li>原始包的代码中，使用数组中的公共代码</li></ol><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol><li><strong>为什么要进行代码压缩</strong></li></ol><p>减少代码体积；破坏代码的可读性，提升破解成本；</p><ol start="2"><li><strong>什么时候要进行代码压缩</strong></li></ol><p>生产环境</p><ol start="3"><li><strong>使用什么压缩工具</strong></li></ol><p>目前最流行的代码压缩工具主要有两个：<code>UglifyJs</code>和<code>Terser</code></p><p><code>UglifyJs</code>是一个传统的代码压缩工具，已存在多年，曾经是前端应用的必备工具，但由于它不支持<code>ES6</code>语法，所以目前的流行度已有所下降。</p><p><code>Terser</code>是一个新起的代码压缩工具，支持<code>ES6+</code>语法，因此被很多构建工具内置使用。<code>webpack</code>安装后会内置<code>Terser</code>，当启用生产环境后即可用其进行代码压缩。</p><p>因此，我们选择<code>Terser</code></p><p><strong>关于副作用 side effect</strong></p><p>副作用：函数运行过程中，可能会对外部环境造成影响的功能</p><p>如果函数中包含以下代码，该函数叫做副作用函数:</p><ul><li>异步代码</li><li><code>localStorage</code></li><li>对外部数据的修改</li></ul><p>如果一个函数没有副作用，同时，函数的返回结果仅依赖参数，则该函数叫做纯函数(pure function)</p><h4 id="Terser"><a href="#Terser" class="headerlink" title="Terser"></a>Terser</h4><p>在<code>Terser</code>的官网可尝试它的压缩效果</p><blockquote><p>Terser官网：<a href="https://terser.org/">https://terser.org/</a></p></blockquote><h4 id="webpack-Terser"><a href="#webpack-Terser" class="headerlink" title="webpack+Terser"></a>webpack+Terser</h4><p><code>webpack</code>自动集成了<code>Terser</code></p><p>如果你想更改、添加压缩工具，又或者是想对Terser进行配置，使用下面的<code>webpack</code>配置即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);<span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);<span class="built_in">module</span>.exports = &#123;  <span class="attr">optimization</span>: &#123;    <span class="comment">// 是否要启用压缩，默认情况下，生产环境会自动开启    minimize: true,     minimizer: [ // 压缩时使用的插件，可以有多个      new TerserPlugin(),       new OptimizeCSSAssetsPlugin()    ],  &#125;,&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><blockquote><p>压缩可以移除模块内部的无效代码<br>tree shaking 可以移除模块之间的无效代码</p></blockquote><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>某些模块导出的代码并不一定会被用到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myMath.jsexport function add(a, b)&#123;  console.log(&quot;add&quot;)  return a+b;&#125;export function sub(a, b)&#123;  console.log(&quot;sub&quot;)  return a-b;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.jsimport &#123;add&#125; from &quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/myMath&quot;console.log(add(1,2));</span></span><br></pre></td></tr></table></figure><p><code>tree shaking</code> 用于移除掉不会用到的导出</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p><code>webpack2</code>开始就支持了<code>tree shaking</code></p><p>只要是生产环境，<code>tree shaking</code>自动开启</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><code>webpack</code>会从入口模块出发寻找依赖关系</p><p>当解析一个模块时，<code>webpack</code>会根据<code>ES6</code>的模块导入语句来判断，该模块依赖了另一个模块的哪个导出</p><p><code>webpack</code>之所以选择<code>ES6</code>的模块导入语句，是因为<code>ES6</code>模块有以下特点：</p><ol><li>导入导出语句只能是顶层语句</li><li><code>import</code>的模块名只能是字符串常量</li><li><code>import</code>绑定的变量是不可变的</li></ol><p>这些特征都非常有利于分析出稳定的依赖</p><p>在具体分析依赖时，<code>webpack</code>坚持的原则是：<strong>保证代码正常运行，然后再尽量tree shaking</strong></p><p>所以，如果你依赖的是一个导出的对象，由于<code>JS</code>语言的动态特性，以及<code>webpack</code>还不够智能，为了保证代码正常运行，它不会移除对象中的任何信息</p><p>因此，我们在编写代码的时候，<strong>尽量</strong>：</p><ul><li>使用<code>export xxx</code>导出，而不使用<code>export default &#123;xxx&#125;</code>导出</li><li>使用<code>import &#123;xxx&#125; from &quot;xxx&quot;</code>导入，而不使用<code>import xxx from &quot;xxx&quot;</code>导入</li></ul><p>依赖分析完毕后，<code>webpack</code>会根据每个模块每个导出是否被使用，标记其他导出为<code>dead code</code>，然后交给代码压缩工具处理</p><p>代码压缩工具最终移除掉那些<code>dead code</code>代码</p><h4 id="使用第三方库"><a href="#使用第三方库" class="headerlink" title="使用第三方库"></a>使用第三方库</h4><p>某些第三方库可能使用的是<code>commonjs</code>的方式导出，比如<code>lodash</code></p><p>又或者没有提供普通的<code>ES6</code>方式导出</p><p>对于这些库，<code>tree shaking</code>是无法发挥作用的</p><p>因此要寻找这些库的<code>es6</code>版本，好在很多流行但没有使用的<code>ES6</code>的第三方库，都发布了它的<code>ES6</code>版本，比如<code>lodash-es</code></p><h4 id="作用域分析"><a href="#作用域分析" class="headerlink" title="作用域分析"></a>作用域分析</h4><p><code>tree shaking</code>本身并没有完善的作用域分析，可能导致在一些<code>dead code</code>函数中的依赖仍然会被视为依赖</p><p>插件<code>webpack-deep-scope-plugin</code>提供了作用域分析，可解决这些问题</p><h4 id="副作用问题"><a href="#副作用问题" class="headerlink" title="副作用问题"></a>副作用问题</h4><p><code>webpack</code>在<code>tree shaking</code>的使用，有一个原则：<strong>一定要保证代码正确运行</strong></p><p>在满足该原则的基础上，再来决定如何<code>tree shaking</code></p><p>因此，当<code>webpack</code>无法确定某个模块是否有副作用时，它往往将其视为有副作用</p><p>因此，某些情况可能并不是我们所想要的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common.jsvar n  = Math.random();//index.jsimport &quot;https://cdn.jsdelivr.net/gh/HAODEabcd/Note@master/Web/webpack/common.js&quot;</span></span><br></pre></td></tr></table></figure><p>虽然我们根本没用有<code>common.js</code>的导出，但<code>webpack</code>担心<code>common.js</code>有副作用，如果去掉会影响某些功能</p><p>如果要解决该问题，就需要标记该文件是没有副作用的</p><p>在<code>package.json</code>中加入<code>sideEffects</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    <span class="attr">&quot;sideEffects&quot;</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>有两种配置方式：</p><ul><li><strong>false</strong>：当前工程中，所有模块都没有副作用。注意，这种写法会影响到某些<code>css</code>文件的导入</li><li>数组：设置哪些文件拥有副作用，例如：<code>[&quot;!src/common.js&quot;]</code>，表示只要不是<code>src/common.js</code>的文件，都有副作用</li></ul><blockquote><p>这种方式我们一般不处理，通常是一些第三方库在它们自己的<code>package.json</code>中标注</p></blockquote><h4 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h4><p><code>webpack</code>无法对<code>css</code>完成<code>tree shaking</code>，因为<code>css</code>跟<code>es6</code>没有半毛钱关系</p><p>因此对<code>css</code>的<code>tree shaking</code>需要其他插件完成</p><p>例如：<code>purgecss-webpack-plugin</code></p><blockquote><p>注意：<code>purgecss-webpack-plugin</code>对<code>css module</code>无能为力</p></blockquote><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p><code>ESLint</code>是一个针对<code>JS</code>的代码风格<strong>检查</strong>工具，当不满足其要求的风格时，会给予警告或错误</p><p>官网：<a href="https://eslint.org/">https://eslint.org/</a></p><p>民间中文网：<a href="https://eslint.bootcss.com/">https://eslint.bootcss.com/</a></p><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p><code>ESLint</code>通常配合编辑器使用</p><ol><li>在<code>vscode</code>中安装<code>ESLint</code></li></ol><p>该工具会自动检查工程中的<code>JS</code>文件</p><p>检查的工作交给<code>eslint</code>库，如果当前工程没有，则会去全局库中查找，如果都没有，则无法完成检查</p><p>另外，检查的依据是<code>eslint</code>的配置文件<code>.eslintrc</code>，如果找不到工程中的配置文件，也无法完成检查</p><ol start="2"><li>安装<code>eslint</code></li></ol><p><code>npm i [-g] eslint</code></p><ol start="3"><li>创建配置文件</li></ol><p>可以通过<code>eslint</code>交互式命令创建配置文件</p><blockquote><p>由于windows环境中git窗口对交互式命名支持不是很好，建议使用powershell</p></blockquote><p><code>npx eslint --init</code></p><blockquote><p>eslint会识别工程中的<code>.eslintrc.*</code>文件，也能够识别<code>package.json</code>中的<code>eslintConfig</code>字段</p></blockquote><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><h5 id="env"><a href="#env" class="headerlink" title="env"></a>env</h5><p>配置代码的运行环境</p><ul><li><code>browser</code>：代码是否在浏览器环境中运行</li><li><code>es6</code>：是否启用<code>ES6</code>的全局<code>API</code>，例如<code>Promise</code>等</li></ul><h5 id="parserOptions"><a href="#parserOptions" class="headerlink" title="parserOptions"></a>parserOptions</h5><p>该配置指定<code>eslint</code>对哪些语法的支持</p><ul><li><code>ecmaVersion</code>: 支持的ES语法版本</li><li><code>sourceType</code><ul><li><code>script</code>：传统脚本</li><li><code>module</code>：模块化脚本</li></ul></li></ul><h5 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h5><p><code>eslint</code>的工作原理是先将代码进行解析，然后按照规则进行分析</p><p><code>eslint</code> 默认使用<code>Espree</code>作为其解析器，你可以在配置文件中指定一个不同的解析器。</p><h5 id="globals"><a href="#globals" class="headerlink" title="globals"></a>globals</h5><p>配置可以使用的额外的全局变量</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;globals&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;var1&quot;</span>: <span class="string">&quot;readonly&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;var2&quot;</span>: <span class="string">&quot;writable&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eslint</code>支持注释形式的配置，在代码中使用下面的注释也可以完成配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* global var1, var2 */</span></span><br><span class="line"><span class="comment">/* global var3:writable, var4:writable */</span></span><br></pre></td></tr></table></figure><h5 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h5><p>该配置继承自哪里</p><p>它的值可以是字符串或者数组</p><p>比如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: <span class="string">&quot;eslint:recommended&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示，该配置缺失的位置，使用<code>eslint</code>推荐的规则</p><h5 id="ignoreFiles"><a href="#ignoreFiles" class="headerlink" title="ignoreFiles"></a>ignoreFiles</h5><p>排除掉某些不需要验证的文件</p><p><code>.eslintignore</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dist/**/*.js</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure><h5 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h5><p><code>eslint</code>规则集</p><p>每条规则影响某个方面的代码风格</p><p>每条规则都有下面几个取值：</p><ul><li><code>off</code> 或 <code>0</code> 或 <code>false</code>: 关闭该规则的检查</li><li><code>warn</code> 或 <code>1</code> 或 <code>true</code>：警告，不会导致程序退出</li><li><code>error</code> 或 <code>2</code>：错误，当被触发的时候，程序会退出</li></ul><p>除了在配置文件中使用规则外，还可以在注释中使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */</span></span><br></pre></td></tr></table></figure><h5 id="总配置"><a href="#总配置" class="headerlink" title="总配置"></a>总配置</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件名 .eslintrc.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;browser&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;es6&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">  <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;ecmaVersion&quot;</span>: <span class="number">2018</span>,</span><br><span class="line">    <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;curly&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://eslint.bootcss.com/docs/rules/">https://eslint.bootcss.com/docs/rules/</a></p></blockquote><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><code>gzip</code>是一种压缩文件的算法</p><h4 id="B-S结构中的压缩传输"><a href="#B-S结构中的压缩传输" class="headerlink" title="B/S结构中的压缩传输"></a>B/S结构中的压缩传输</h4><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111749067.png"></p><p>优点：传输效率可能得到大幅提升</p><p>缺点：服务器的压缩需要时间，客户端的解压需要时间</p><h4 id="使用webpack进行预压缩"><a href="#使用webpack进行预压缩" class="headerlink" title="使用webpack进行预压缩"></a>使用webpack进行预压缩</h4><p>使用<code>compression-webpack-plugin</code>插件对打包结果进行预压缩，可以移除服务器的压缩时间</p><p><img src="https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202111111749071.png"></p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="comment">//压缩</span></span><br><span class="line"><span class="keyword">const</span> CmpressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CmpressionWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js/</span>,</span><br><span class="line">      minRatio: <span class="number">0.5</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="补充和案例"><a href="#补充和案例" class="headerlink" title="补充和案例"></a>补充和案例</h2><ul><li><p><strong>搭建多页应用</strong></p><ul><li>见：<a href="https://github.com/yjisme/multi-static-pages-webpackproj">https://github.com/yjisme/multi-static-pages-webpackproj</a></li></ul></li><li><p><strong>搭建vue单页应用</strong></p><ul><li>见：<a href="https://github.com/yjisme/vue-webpack">https://github.com/yjisme/vue-webpack</a></li></ul></li><li><p><strong>搭建React单页应用</strong></p><ul><li>见：<a href="https://github.com/yjisme/react-webpack">https://github.com/yjisme/react-webpack</a></li></ul></li><li><p><strong>搭建Node应用</strong></p><ul><li>见：<a href="https://github.com/yjisme/node-webpack">https://github.com/yjisme/node-webpack</a></li></ul></li></ul><pre><code>1. 直接开发，直接部署   1. 搭建`node`工程，直接开发   2. 开发过程中使用`git`进行管理   3. 开发完成后，提交`git`   4. 进入部署服务器，从`git`中拉取最新代码，然后`npm install`问题：1. 服务器在`npm install`的过程中，会占用比较大的网络资源2. 代码没有压缩，拉取速度较慢3. 开发过程中，无法使用较新的语法4. 开发过程中，无法使用ES6模块化2. 直接开发，用`webpack`打包，然后部署   1. 搭建`node + webpack`工程   2. 开发后，使用`webpack`打包   3. 将打包结果上传到服务器，服务器直接运行生产环境的运行：1. 监控源代码目录，如果源代码有变动2. 将环境变量设置为`development`，然后进行打包3. 运行打包结果</code></pre><ul><li><strong>搭建全栈应用</strong><ul><li>见：<a href="https://github.com/yjisme/node-vue-webpack">https://github.com/yjisme/node-vue-webpack</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;h2 id=&quot;核心功能&quot;&gt;&lt;a href=&quot;#核心功能&quot; class=&quot;headerlink&quot; title=&quot;核心功能&quot;&gt;&lt;/a&gt;核心功能&lt;/h2&gt;&lt;h3 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h3&gt;&lt;h4 id=&quot;模块化简介&quot;&gt;&lt;a href=&quot;#模块化简介&quot; class=&quot;headerlink&quot; title=&quot;模块化简介&quot;&gt;&lt;/a&gt;模块化简介&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;具有相同属性和行为的事物的集合。在前端中，将一些属性比较类似和行为比较类似的内容放在同一个&lt;code&gt;js&lt;/code&gt;文件里面，把这个&lt;code&gt;js&lt;/code&gt;文件称为模块，为了每个&lt;code&gt;js&lt;/code&gt;文件只关注与自身有关的事情，让每个&lt;code&gt;js&lt;/code&gt;文件各行其职。&lt;/li&gt;
&lt;li&gt;模块要有几个特点： 独立、完整、依赖关系&lt;/li&gt;
&lt;li&gt;在最开始的阶段，&lt;code&gt;Js&lt;/code&gt;并没有这些模块机制，各种&lt;code&gt;Js&lt;/code&gt;到处飞，也就是你们现在的野生代码，得不到有效妥善的管理。后来前端圈开始制定规范，最耳熟能详的是&lt;code&gt;CommonJs&lt;/code&gt;和&lt;code&gt;AMD&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="构建工具" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Webpack" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/Luckiiest/Luckiiest.github.io.git/2021/11/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-11-08T07:35:53.000Z</published>
    <updated>2022-05-17T01:12:47.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式就是一个表达式，用来查找一个有指定【特点】的表达式，规则匹配的。</p><h2 id="正则表达式方法"><a href="#正则表达式方法" class="headerlink" title="正则表达式方法"></a>正则表达式方法</h2><h3 id="正则表达式定义的方式"><a href="#正则表达式定义的方式" class="headerlink" title="正则表达式定义的方式"></a>正则表达式定义的方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reg = /abc/;</span><br><span class="line">var reg = new RegExp(&#x27;abc&#x27;);</span><br></pre></td></tr></table></figure><h3 id="正则表达式使用方法"><a href="#正则表达式使用方法" class="headerlink" title="正则表达式使用方法"></a>正则表达式使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg.test(str);</span><br><span class="line">str.match(reg);</span><br></pre></td></tr></table></figure><h3 id="特殊属性-i-g-m"><a href="#特殊属性-i-g-m" class="headerlink" title="特殊属性  i/g/m"></a>特殊属性  i/g/m</h3><ul><li><p><code>g</code>代表的是<code>global</code>全局匹配</p></li><li><p><code>i</code>代表<code>ignoreCase</code>忽略大小写，</p></li><li><p><code>m</code>代表<code>multiline</code>多行匹配，</p></li></ul><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>具有特殊含义的字符。</p><ul><li><p><code>\</code>   转义字符</p></li><li><p><code>|</code>   或</p></li></ul><h4 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h4> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[abc]  查找方括号内的任意一个字符</span><br><span class="line"></span><br><span class="line">[^abc]   查找任何不在方括号内的字符</span><br><span class="line"></span><br><span class="line">[0-9]  查找0-9之间的数字</span><br><span class="line"></span><br><span class="line">[a-z]  查找任何小写字母</span><br><span class="line"></span><br><span class="line">[A-Z]  查找任何大写字母</span><br><span class="line"></span><br><span class="line">[A-z]  查找任何字母</span><br><span class="line"></span><br><span class="line">(red|blue|green)  查找指定字符串（子表达式）</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.       查找单个字符，除了换行和行结束符。</span><br><span class="line">\w      查找单词字符（匹配字母、数字、下划线。等价于&#x27;[A-Za-z0-9_]&#x27;）</span><br><span class="line">\W      查找非单词字符</span><br><span class="line">\d      查找数字</span><br><span class="line">\D      查找非数字</span><br><span class="line">\s      查找空白字符 </span><br><span class="line">\S      查找非空白字符</span><br><span class="line">\b      查找单词边界</span><br><span class="line">\B      查找非单词边界</span><br><span class="line">\n      查找换行符</span><br><span class="line">\f      查找换页符</span><br><span class="line">\r      查找回车符</span><br><span class="line">\t      查找制表符</span><br><span class="line">\v      查找垂直制表符</span><br><span class="line">\uxxx   查找以十六位进制数xxxx规定的Unicode字符</span><br><span class="line">[\u4e00-\u9fa5] 所有中文字符</span><br></pre></td></tr></table></figure><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下均遵循贪婪匹配：</span><br><span class="line"></span><br><span class="line">n+      匹配任何包含至少一个n的字符</span><br><span class="line">n*      匹配任何包含0个或多个n的字符</span><br><span class="line">n?      匹配任何0个或一个n的字符</span><br><span class="line">n&#123;X&#125;    匹配X个n的序列字符串</span><br><span class="line">n&#123;X,Y&#125;  匹配X至Y个n的序列字符串</span><br><span class="line">n$      匹配以n结尾的字符串</span><br><span class="line">^n      匹配任何以n开头的字符串</span><br><span class="line">?=n     正向肯定预查匹配任何后面紧接着指定字符串n的字符串</span><br><span class="line">匹配n前面的那个位置</span><br><span class="line">?!n     正向否定预查匹配任何其后没有紧接着指定字符串n的字符串</span><br><span class="line">匹配除了n前面的那个位置，?=n的反面意思</span><br><span class="line">?&lt;=n    反向肯定预查匹配任何前面紧跟着指定字符串n的字符串</span><br><span class="line">匹配n后面的那个位置</span><br><span class="line">?&lt;!n    反向否定预查匹配任何前面没有紧接着指定字符串n的字符串</span><br><span class="line">匹配除了n后面的那个位置，?&lt;=n的反面意思</span><br><span class="line">非贪婪匹配：</span><br><span class="line">n+?    n*? ...</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?:n)   匹配时子表达式中没有这一项（不补获分组）</span><br></pre></td></tr></table></figure><h3 id="RegExp对象属性"><a href="#RegExp对象属性" class="headerlink" title="RegExp对象属性"></a>RegExp对象属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global      查看RegExp对象是否具有g标志</span><br><span class="line">ignoreCase  查看RegExp对象是否具有i标志</span><br><span class="line">multiline   查看RegExp对象是否具有m标志</span><br><span class="line">source      查看正则表达式源文本</span><br><span class="line">lastIndex   一个整数标志开始下一次匹配的字符位置（一般与exec一起使用）</span><br></pre></td></tr></table></figure><h3 id="RegExp对象方法"><a href="#RegExp对象方法" class="headerlink" title="RegExp对象方法"></a>RegExp对象方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile    编译正则表达式。（就是改变这个正则表达式）</span><br><span class="line">exec       检索字符串中指定的值。返回找到的值，并确定其位置。</span><br><span class="line">test       检索字符串中指定的值。返回 true 或 false。</span><br></pre></td></tr></table></figure><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search          检索正则表达式相匹配的值</span><br><span class="line">match           查找所有符合正则匹配条件的结果</span><br><span class="line">replace替换与正则表达式匹配的字符串</span><br><span class="line">split           把字符串分割成数组(注： 用字表达式分割的话会保留子表达式)</span><br></pre></td></tr></table></figure><h2 id="正则类型匹配"><a href="#正则类型匹配" class="headerlink" title="正则类型匹配"></a>正则类型匹配</h2><h3 id="字符匹配题"><a href="#字符匹配题" class="headerlink" title="字符匹配题"></a>字符匹配题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配16进制颜色</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/^#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"><span class="comment">// 匹配24小时时间</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/^(0?[0-9]|[01][0-9]|[2][0-3]):(0?[0-9]|[0-5][0-9])$/</span>;</span><br><span class="line"><span class="comment">// 匹配日期（格式：2017-06-10）</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/^([0-9]&#123;4&#125;)-([0][1-9]|[1][0-2])-([0][0-9]|[12][0-9]|[3][12])$/</span>;</span><br><span class="line"><span class="comment">// 匹配window文件路径（格式：盘符:\\文件夹\文件夹\文件夹\）</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/^[a-zA-Z]:\\([^\\:&lt;&gt;?|*&quot;\r\n/]+\/)*([^\\:&lt;&gt;?*&quot;|\r\n/]+)?$/</span>;</span><br><span class="line"><span class="comment">// 匹配id</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/id=&quot;[^&quot;]*&quot;/</span>;</span><br></pre></td></tr></table></figure><h3 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h3><ul><li>对于位置的理解，我们可以理解成空字符 “”。<ul><li>比如 “hello” 字符串等价于如下的形式：</li><li><code>&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;o&quot; + &quot;&quot;;</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配开头和结尾，并替换#</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/^|$/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.replace(regexp,<span class="string">&quot;#&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配单词边界，并替换#</span></span><br><span class="line"><span class="keyword">var</span> regexo = <span class="regexp">/\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;[JS] Lesson_01.mp4&quot;</span>;</span><br><span class="line">str.replace(regexp,<span class="string">&quot;#&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配非单词边界，并替换#</span></span><br><span class="line"><span class="keyword">var</span> regexo = <span class="regexp">/\B/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;[JS] Lesson_01.mp4&quot;</span>;</span><br><span class="line">str.replace(regexp,<span class="string">&quot;#&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配l字符前面的位置</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?=l)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(regexp,<span class="string">&#x27;#&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配除了n前面的那个位置，?=n的反面意思</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?!l)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(regexp,<span class="string">&#x27;#&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配l字符后面的位置</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?&lt;=l)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(regexp,<span class="string">&#x27;#&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配除了n后面的那个位置，?=n的反面意思</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?&lt;!l)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(regexp,<span class="string">&#x27;#&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不匹配任何东西的正则</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/.^/</span>;</span><br><span class="line"><span class="comment">// 因为此正则要求只有一个字符，但该字符后面是开头，而这样的字符串是不存在的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把123456789变成123,456,789</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>;</span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><blockquote><ol><li> 正则表达式实现aabb的形式变成bbaa</li><li>给10000000000三位打点 变成 10.000.000.000<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>;</span><br></pre></td></tr></table></figure></li><li> 字符串去重 aaaaaaaaaaaaaaaaaaaaaabbbbbbbbcccccccccc变成abc</li><li> 把the-first-name转换成小驼峰式theFirstName</li><li> 匹配结尾的数字</li><li> 统一空格数</li><li> 判断字符串是不是由数字构成</li><li> 删除字符串中的空格</li><li> 身份证号匹配</li><li> 将字符串”select student.*,result.* from student inner join result on student.id = result.studentid” 和字符串”select * from student “中的student替换成key值   </li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;正则表达式就是一个表达式，用来查找一个有指定【特点】的表达式，规则匹配的。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式方法&quot;&gt;&lt;a href=&quot;#正则表达式方法&quot; class=&quot;headerlink&quot; title=&quot;正则表达式方法&quot;&gt;&lt;/a&gt;正则表达式方法&lt;/h2&gt;&lt;h3 id=&quot;正则表达式定义的方式&quot;&gt;&lt;a href=&quot;#正则表达式定义的方式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式定义的方式&quot;&gt;&lt;/a&gt;正则表达式定义的方式&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var reg = /abc/;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var reg = new RegExp(&amp;#x27;abc&amp;#x27;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;正则表达式使用方法&quot;&gt;&lt;a href=&quot;#正则表达式使用方法&quot; class=&quot;headerlink&quot; title=&quot;正则表达式使用方法&quot;&gt;&lt;/a&gt;正则表达式使用方法&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;reg.test(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.match(reg);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;特殊属性-i-g-m&quot;&gt;&lt;a href=&quot;#特殊属性-i-g-m&quot; class=&quot;headerlink&quot; title=&quot;特殊属性  i/g/m&quot;&gt;&lt;/a&gt;特殊属性  i/g/m&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;g&lt;/code&gt;代表的是&lt;code&gt;global&lt;/code&gt;全局匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;i&lt;/code&gt;代表&lt;code&gt;ignoreCase&lt;/code&gt;忽略大小写，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;m&lt;/code&gt;代表&lt;code&gt;multiline&lt;/code&gt;多行匹配，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;特殊字符&quot;&gt;&lt;a href=&quot;#特殊字符&quot; class=&quot;headerlink&quot; title=&quot;特殊字符&quot;&gt;&lt;/a&gt;特殊字符&lt;/h3&gt;&lt;p&gt;具有特殊含义的字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\&lt;/code&gt;   转义字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;|&lt;/code&gt;   或&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;方括号&quot;&gt;&lt;a href=&quot;#方括号&quot; class=&quot;headerlink&quot; title=&quot;方括号&quot;&gt;&lt;/a&gt;方括号&lt;/h4&gt; &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[abc]  查找方括号内的任意一个字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[^abc]   查找任何不在方括号内的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0-9]  查找0-9之间的数字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[a-z]  查找任何小写字母&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[A-Z]  查找任何大写字母&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[A-z]  查找任何字母&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(red|blue|green)  查找指定字符串（子表达式）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="正则表达式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
    <category term="正则表达式" scheme="https://github.com/Luckiiest/Luckiiest.github.io.git/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
