---
title: 微机原理
date: 2022-07-21 09:21:43
tags:
categories:

---

# 微机原理

## 绪论

### 微机发展概况

- **电子计算机**
  - 第一代：1946年 电子管 30吨 176㎡ 5000次/s 18000支电子管 6000个继电器 功率150KW 48万美元 
  - 第二代：1958 晶体管
  - 第三代：1965 `SSI/MSI`
  - 第四代：1970 `LSI/VLSI`（微型计算机）
  - 第五代：具有人工智能（推理/判断/决策/学习/联想）
- **微型计算机（第四代）**
  - 第一代：`1971` `Intel` `4004/8008`   `4/8位机`   `10~15us`
  - 第二代：`1973` `8080/Z80/M6800/8085` `8位`     `1~2us`
  - 第三代：`1978` `8086/M68000/80286`   `16位`     `0.5us`
  - 第四代：`1983` `80386/486`           `32位`     `<0.1us`
  - 第五代：`1993` `Pentium/P2/P3/P4`    `32/64位`  `fclk>2Ghz`
  - 第六代：`2006` `酷睿(core)双核/四核/八核......`
- **8086(微型计算机第三代)**
  - `Intel 8086/8088 CPU`
  - `128Kb RAM`
  - `5''360kb或720软驱`
  - `5MB硬盘`
- **80286(微型计算机第三代)**
  - `Intel 80286 CPU`
  - `3.5英寸1.44MB软盘`
  - `270万条指令/s`
  - `集成134000个晶体管`
- **80386/486/Pentium/Pro...(微型计算机第四、五代)**
  - Intel第一枚32位处理器：80386
  - 120万晶体管：486
  - 300多万晶体管1亿条指令/s：`Pentium`
  - 550多万晶体管4.4亿条指令/s：`Pentium Pro`
- **计算机第一定理：摩尔定律**
  - 继承电率的集成度每18个月翻一番，既每18个月芯片能力增长一倍
  - 晶体管的数量每两年增加一倍
- **16位机是32/64位机的区别**
  - 16位机是32/64位机的基础
  - 8086系列向上兼容
  - 16位基础-->32/64位拓展

### 微机应用领域

- 科学计算：数/理/化/天文/气象/工程...
- 信息处理：OA/MIS/图文声像多媒体...
- 自动控制：厂矿企业/军事工业/CIMS
- 智能仪器仪表：单片机(MCU)/DSP/ARM类产品
- 网络通讯：无线，光纤，卫星通讯/Internet...
- 计算机辅助系统：CAD/CAM/CAPP/CAI...
- 人工智能：智能机器人/机器视觉/深度学习
- 各个领域，无处不在

### 微机系统的概念

- 硬件
  - 微型计算机
    - CPU：运算器，控制器，寄存器组
    - 存储器：ROM/RAM
    - I/O接口：并行/串行，简单/可编程...
    - 总线：AB、DB、CB
  - 外部设备
    - I/O设备：键盘，鼠标/CRT，PRN
    - 外存储器：软盘/硬盘/光盘/U盘...
- 软件
  - 系统软件：操作系统/编译/汇编/监控程序...
  - 应用软件：MIS/CAD/CAI/MILL/APP...
  - 程序设计语言：机器/汇编/高级语言

### 总线

- 计算机的结构
  - 冯·诺依曼结构
  - 五箱结构
    - 输入设备、存储器、输出设备、控制器、运算器
    - ![image-20220721143935477](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211439855.png)

- 总线的类型

  - 内部总线/外部总线
  - 局部总线/系统总线
  - 地址总线（AB）：单向/三态，决定寻址容量
  - 数据总线（DB）：双向/三态，决定传输能力
  - 控制总线（CB）：有入有出
  - ![image-20220721144423692](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211453436.png)

  - 微机总线标准
    - 各模块间的互联标准/传输协议
      - 如：PC总线/ISA/EISA/MCA/PCI等
    - 微机系统模块化：符合总线标准的各种模块（如：显示卡、网卡、多功能卡等）可任意插拔、方便拓展

- 单片机

![image-20220721150017876](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211500036.png)

## 8086系统结构

- 8086CPU
  - DB：16条，16位微处理器
  - AB：20条，直接寻址空间，2^20=1MB
  - 时钟频率：5MHz~10MHz
  - 可与8087/8089组成多机系统
  - 40引脚/双列直插/HMOS工艺
- 8088CPU
  - 准16位CPU。DB：内部16位/外部8位
- 8086/8088CPU特点
  - 引脚复用：引脚功能复用/总线分时复用
  - 可控三态结构
  - 单总线，累加器结构

### 8086CPU结构

![image-20220721154150460](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211541664.png)

#### 两大部件

- **总线接口部件BIU**
  - 负责对外
  - 作用：CPU与外部（存储器,I/O）的接口，对外提供16位DB，20位AB
  - 功能：地址形成，取指令，指令排队，读/写操作数和总线控制
  - 组成：
    - 段地址寄存器(16位)：`CS：代码段`、`DS：数据段`、`ES：附加段`、`SS：堆栈段`
    - 指令指针寄存器IP(16位)：存放下一条待执行指令的偏移地址
    - 物理地址加法器：由段地址与偏移地址形成20位实际地址
    - 指令队列寄存器：预存6字节指令码（先进先出）
    - 总线控制逻辑：发总线控制信号，存储器、I/O读/写信号
- **指令执行部件EU**
  - 负责对内

  - 功能：从指令队列中取指令、译码、执行

  - 组成：

    - ALU：完成算数/逻辑运算
    - FLAGS：存放运算结果的特征
    - 寄存器组：通用(AX，BX，CX，DX)/专用（SI,DI,SP,BP）
    - EU控制器：取指令、时序控制

  - 8位机执行过程
    - `| 取指 | 执行 | 取指 | 执行 | 取指 | 执行 |` 

    - 从外部存储器取指令

  - 8086执行过程
    - `| 取指 | 取指 | 取指 | 取指 | 取指 | 取指 | ` BIU完成
    - `| 等待 | 执行 | 执行 | 执行 | 执行 | 执行 |` EU完成
    - 并行工作
    - 流水线结构
    - 执行指令的同时预取下一条指令

#### 寄存器组

![image-20220721174839199](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211748463.png)

- **专用寄存器**

  - 段寄存器（16位）
    - 1MB空间分为若干个逻辑段
    - 存储单元20位实际地址（即：物理地址）由两部分组成：段基址（存放在段寄存器中）和段内偏移地址
    - `物理地址 = 段基址左移4位(乘以16) + 段内偏移地址`
  - 指令指针IP（16位）
    - 存放下一条待执行指令在先行代码段中的偏移地址，控制指令序列的流程
  - 标志寄存器FLAGS（程序状态字PSW，16位）
    - 存放运算结果的状态和控制标志，每一位有特定的含义
    - ![image-20220721172634096](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211726904.png)

    - `AF`：辅助进位标志（低4位）有/无半进(借)位
    - `SF`：符号标志，结果为负/正
    - `ZF`：零标志，结果为0/非0（运算结果非0的话指0，是0的话指1）
    - `PF`：奇偶标志，结果低字节有偶数个1/奇数个1
    - `CF`：进位标志，有/无进(借)位（反应无符号数是否超范围，溢出）
      - 8位无符号数范围：0~255
      - 反应无符号数是否超范围（溢出）
    - `OF`：溢出标志，溢出/无溢出（OF=Cy最高+Cy次高）（反应带符号数是否超范围,溢出）
      - 8位带符号数范围：`-128~+127`
      - 反应有符号数是否超范围
    - `DF`：方向标志，地址自动减/增
    - `IF`：中断标志，中断允许/禁止
    - `TF`：单步标志，单步允许/禁止

### 8086/8088CPU引脚及功能

> 40引脚，双列直插

- 两种工作模式

  - 最小模式：单机系统中所有控制信号，全部由8086直接提供

  - 最大模式：多处理器系统系统中控制信号由总线控制器8288提供

#### 40引脚，双列直插

- ![image-20220722152717125](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207221527404.png)
- `AD15~AD0（地址/数据总线）`
  - 分时复用
    - 传送地址时，三态输出，单向
    - 传送数据时，三台输入/输入，双向
  - 总线周期T1：输出地址--->外部锁存器；T2~T4：传送数据中断/总线保持响应:高阻
- `A19/S6~A16/S3（地址/状态线）`
  - 三态，输出，分时复用
  - T1：输出地址（访问I/O时:0000）--->外部锁存器
  - T2~T4：做状态线
  - S6=0：表明8086当前连在总线上；S5：IF当前状态；S4,S3组合：指明当前使用的段（ES/SS/CS/DS）
- `BHE/S7（高8位数据总线允许/状态线）`
  - 分时复用，需锁存
  - T1：输出BHE（0/1:高/低8位数据有效）

- `ALE（地址锁存允许）`
  - 输出，高有效，作9292的选通信号
  - 解决地址/数据复用：T1:ALE=1，CPU发地址--->外部锁存器，ALE下降沿锁存地址，此后传输数据
- `RD（读选通）`
  - RD=0，读存储器或I/O（与M/IO配合）
- `WR（写选通）`
  - WR=0，写存储器或I/O（与M/IO配合）
- `M/IO（存储器或I/O端口选择）`
  - 1/0：CPU访问存储器/访问I/O
- `INTR（可屏蔽中断请求输入）`
  - CPU每条指令最后一个T状态测试INTR
  - 如INTR=1，表明外设有中断请求，若此时允许中断(1F=1)，则CPU执行完先行指令后响应中断；否则(1F=0)，CPU不予理睬
- `INTA（中断响应）`
  - 作为INTR的回答信号
  - 中断响应时，CPU发出两个INTA负脉冲，第一个通知外设已响应其请求，第二个脉冲外设收到后，向DB放置中断类型号。
- `NMI（非屏蔽中断请求）`
  - 上升沿有效
  - 不能由软件屏蔽（与IF状态无关）
  - 常用于处理最紧急事件
- `DEN（数据允许）`
  - 做数据收发器8286的输出允许信号
  - 8286：总线收发器，用于增加总线驱动能力
- `DT/R（数据发送/接收控制）`
  - 控制8286的数据传输方向
  - DT/R=0：CPU读，即接收
  - DT/R=1：CPU写，即发送
- `RESET（复位）`
  - 高电平（>=4T时钟）使CPU复位（CS=FFFFH，其他寄存器=0）
  - 复位后，CPU从FFFF0H单元开始执行程序
- `CLK（时钟信号）`
  - 由8284时钟发生器提供的基本定时脉冲
  - 8086：5~10MHz
- `MN/MK（最小/最大模式选择：1/0）`
- `READY（准备就绪）`
  - CPU检测到READY=0，则在T4状态前自动插入若干个Tw，直至READY=1
  - 保证告诉CPU与低速外设时许的配合
- `TEST（测试信号的输入）`
  - CPU执行WAIT指令时测试TEST，若为1，等待；若为0，向下执行
  - 可使CPU与外部硬件同步
- `HOLD（总线保持请求）`
  - 输入，高有效
  - 系统其他部件要求占用总线
- `HLDA（总线保持响应）`
  - 输出，高有效
  - HOLD的会打信号。当其他部件发HOLD=1，CPU则发HLDA=1应答，随后让出三总线控制权(高阻)，申请不见随即获得BUS控制权。此后，HOLD=HLDA=1，直至BUS使用完毕，HOLD=0，CPU重获BUS控制权，并使HLDA=0
- `Vcc、GND（+5V供电）`

#### 最大模式引脚定义

除224~31引脚外，其余与最小模式相同

- S2，S1，S0（总线周期状态）

  - 最小模式：CPU直接产生RD，WR，M/IO等各种控制信号
  - 最大模式：CPU发S2 S1 S0--->总线控制器8288--->译码产生各种控制信号

- LOCK（总线封锁信号）

  - LOCK=0，CPU禁止其他部件占用总线
  - 指令前缀LOCK可使指令执行时LOCK=0
  - CPU发两个INTA之间自动使LOCK=0

- RQ/GT0,RQ/GT1（总线请求/应答）

  - 请求/应答一条线完成
  - 可与两个CPU相连，前者优先权高

- QS1，QS0（指令队列状态信号）

  - 10：队列空
  - 01/11：从队列取第一字节/取后续字节

- | S2 S1 S0 | 操作           |
  | -------- | -------------- |
  | 0 0 0    | 发中断响应信号 |
  | 0 0 1    | 读I/O口        |
  | 0 1 0    | 写I/O口        |
  | 0 1 1    | 暂停           |
  | 1 0 0    | 取指令         |
  | 1 0 1    | 读存储器       |
  | 1 1 0    | 写存储器       |
  | 1 1 1    | 无效           |

#### 8088与8086CPU区别

- 8086：16位机
  - 内部、外部DB宽度均为16位
- 8088：准16位机
  - 内部DB宽度16位，外部8位
  - 8088指令队列长度位4字节
  - 不同引脚定义
    - AD15~8改为A5~8
    - M/IO改为IO/M
    - BHE改为SSO
  - 总线周期状态如表所示

![image-20220722162905559](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241629201.png)

### 8086存储器组织

#### 存储器组织

- 存储器地址的分段
  - 8086由20条地址线
    - 寻址空间2^20=1MB（00000H~FFFFFH）
  - CPU内部寄存器16位
    - 不能直接提供20位地址
    - 解决办法采用分段技术
    - 将1M空间分成若干个段，每个段<=64K，每个段的段内地址即可用16位表示
    - 段起始地址应能被16整除，既：地址的最低4位为0
    - ![image-20220722163639278](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241629604.png)
- 物理地址
  - 即20位实际地址，又称为绝对地址
  - `物理地址=段基址左移4位+段内偏移地址`
- 逻辑地址
  - 由两个16位地址构成，短地址：段内偏移地址
- 方便重定位
  - 数据块搬家时只需修改段地址
- 一个物理地址可以对应不同的逻辑地址
  - 如：12345H，1200H:0345，1234:0005H，1231：0035
- 每个段的起始地点能被16整除（对于实模式8086）
  - 如：10200H，25010H，12A60H，3F9C0H

#### 存储器分体结构

- 8086 1MB空间分为两个存储体

  - 奇地址存储体：与DB高8位相连
  - 偶地址存储体：与DB低8位相连

- | BHE A0    | 操作                                | DB            |
  | --------- | ----------------------------------- | ------------- |
  | 0 0       | 从偶地址起读/写一个字               | AD15-0        |
  | 0 1       | 从奇地址单元读/写一个字节           | AD15-8        |
  | 1 0       | 从偶地址单元读/写一个字节           | AD7~0         |
  | 1 1       | 无效                                |               |
  | 0 1   1 0 | 从奇地址起读/写一个字（分两次完成） | AD15-8  AD7~0 |

- ![](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207240959990.png)

- 对准存放：从偶地址开始存放字数据

- 8088 1MB看出一个整体，不用BHE，A0选择，一次只能一个字节

#### 堆栈的概念

- 堆栈：存储器中开辟的一个区域,存放需暂时保存的数据。
- 存取数据的原则：先进后出/后进先出;一次传送16位/一个字
- 有关寄存器：
  - SS:存放段基址;
  - SP:堆栈指针,始终指向栈顶
- 地址增长方式：向上增长，即:地址由高到低增长
- 堆栈段可在1M空间内任意浮s动
- 堆栈操作:
  - PUSH：压入，SP-2->SP，低8位->(SP)，高8位->(SP+1)
  - POP：弹出,依次弹出低8位、高8位，SP+2->SP

### 系统配置

![](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241513062.png)

- 地址锁存器---74LS373

  - ![](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241513052.png)

  - 作用：锁存地址，实现地址/数据的分时复用

#### CPU时序

- 典型总线时序简介

![image-20220724163855806](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241638639.png)

- 系统复位与启动
  - RESET引脚加高电平（>=4T时钟），系统即复位
  - 复位后的状态：
    - FLAGS=0，CS=FFFFH，IP=0000H
    - DS=ES=SS=0000H
    - 指令队列=0
    - 其他REG=0
  - 思考，8086程序的第一条指令应放在何处？

## 8086指令系统

- 程序：指令的有序集合
- 每种CPU都有各自的指令系统
- 指令格式
  - `操作码 操作数; 注释`
  - 操作码：要求CPU作何种操作，（不可少，用助记符表示，有确定的机器码）
  - 操作数：单/双/无；（可为立即数，寄存器，存储单元，I/O接口）
  - 例：MOV AL, 3AH; AL<-3AH B03A
    - MOV为操作码,AL为累加寄存器，3AH为操作数，AL<-3AH为注释，B03A为对应得机器码

### 8086寻址方式

指令中说明操作数所在地址的方法

寻址方式越多，编程越灵活方便

- **立即寻址**

  - 操作数（立即数）直接包含在指令中

  - 例如

```
MOV AL, 26H    ; 8位立即数
MOV CX, 2A50H  ; 16位
MOV AX, 0FF00H ; 16位
```

- **寄存器寻址**
  - 从某一个寄存器中寻找数据，赋给目的操作寄存器
  - `指令 目的寄存器 源寄存器`

```
MOV DX, AX ;（将AX寄存器的数的数送于DX寄存器）
MOV CL, AH ; copy
```

- **直接寻址**
  - 存储单元的有效地址（EA）由指令给出
  - `MOV AL, [2000H] ;` 默认段位DS，一个数外面有[]就代表是一个地址，从一个地址中寻找数据给AL

```
若DS=3000H，(32000H)=1234H，则执行后：AL=34H
MOV AX, [2000H] ; AX=1234H
MOV AX, ES:[500H] ; 段超越前缀，操作数地址=ES*16+500H
MOV AX, AREA ; 符号地址/立即数
```

- **寄存器间接寻址**
  - `MOV BX, [SI]`
  - 若DS=1000H，SI=2000H，（12000H）=318BH，则执行后BX=318BH
  - `MOV AX,[BP] ; `默认段为SS
  - `MOV BX,DS:[BP] ; `强制段为DS
  - `MOV AX,ES:[SI] ; `段超越前缀
  - [ ]中只能为BX,BP,SI,DI之一

- **寄存器相对寻址**
  - `MOV BX, COUNT [SI] ;` 等价于`MOV BX，[COUNT＋SI]`
  - 若DS=3000H,SI=2000H,COUNT=400OH，(36000H)=5678H，则:物理地址=16×DS+SI+COUNT=36000H，执行后BX=5678H
- **基址变址寻址**
  - EA=基址寄存器BX/BP＋变址寄存器SI/DI
  - `MOV AX，[BX][SI];` 等价于`MOV AX，[BX+SI]`
  - 若DS=3000H,BX=1200H,SI=0500H，(31700H)则:执行后AX=ABCDH
- **相对基址变址寻址**
  - `MOV AX，MASK[BX][SI];`等价于`MOV AX，[MASK+BX+SI]`
- **I/O端口寻址**
  - `IN AL,63H ;`将端口63中内容-->AL
  - `MOV DX,213H`
  - `OUT DX,AL;` AL->端口213H
- **隐含寻址**
  - DAA：操作数存放于规定位置
- **转移类指令寻址**

### 8086指令系统

- 程序是指令的有序集合
- 不同的CPU有各自的指令系统
  - 机器指令：用二进制码表示
  - 汇编指令：用助记符表示
- 8086指令共115条，分为六大类
  - 数据传送指令
  - 算术运算指令
  - 逻辑运算与循环移位指令
  - 字符串处理指令
  - 控制转移指令
  - CPU控制指令

#### 数据传送指令

- 通过数据传送指令
- **MOV** 传送
  - 格式：`MOV 目的,源 ; 目的<-源B/W`
  - ![image-20220725163626559](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207251637722.png)
- **PUSH** 入栈
  - 格式：`PUSH 源; SP<-SP-2,源操作数（字）入栈`
  - 默认段：SS
  - 先进后出
  - SP始终指向栈项
  - 源：
    - 16位通用寄存器
    - 段寄存器
    - 存储单元
    - 不能为立即数
  - SP为`FFFEH~0`之间的偶地址
- **POP** 出栈
  - 格式：`POP 目的; 目的<-栈顶字，SP<-SP+2`
  - 目的：不能为CS，其他和源相同

- **XCHG** 交换指令
  - 格式：`XCHG 目的，源; 目的<-->源`

```
例： 设AX=2022H， DS=3000H，BX=1800H，（31A00H）=1984H
则： XCHG AX,[BX+200H ] //寻址方式
执行后： AX=1984H，（31A00H）=2022H
```

- **XLAT** 查表指令
  - 格式：`XLAT [表首地址]; BX<-表首地址，AL<-偏移量; AL<-结果`

```
查表求n的段码，查表，BX表首地址加上AL你给出的偏移量，然后得出的结果给AL
TAB : DB 40H,79H,24H,3OH,19H DB12H,02H,78H,OOH，18H 
MOV AL,n
MOV BX, OFFSET TAB
XLAT ; (AL) <- (BX+AL)
```

- **I/O** 指令
  - **IN** 输入指令
    - 格式：
    - `IN AL/AX, 端口地址 ; 8位地址`
    - `IN AL/AX, DX ; 16位地址`
  - **OUT** 输出指令
    - 格式：
    - `OUT 端口地址, AL/AX`
    - `OUT DX, AL/AX`

```
例：
IN AL,OF1H //送8位

IN AX,80H  // 送16位，端口地址80H,81H中内容->AX

MOV DX,310H  // 如果端口地址是16位的话，需要先送DX，再送AL
IN AL,DX

OUT 85H, AL

MOV DX, OFF4H
OUT DX, AL ; AL中内容从地址为OFF4H端口输出
```

- **地址目标传送指令**
  - **LEA** 取有效地址，将源的偏移地址送入目的中
    - 格式：`LEA 目的, 源; 目的<-源存储单元有效地址`
  - **LDS** 双字指针->寄存器和DS
    - 格式：`LDS 目的，源`
    - 目的：常用SI
    - 源：连续4字节，前两个存放EA，后两个存放段地址
  - **LES** 双字指针->寄存器和ES
    - 格式：`LES 目的,源`

```
LEA，例
LEA BX, TAB 等价于 MOV BX, OFFSET TAB
设SI=1000H,DS=5000H,(51000H)=1234H,则：
	LEA BX, [SI]; 
	执行后：BX=1000H	//LEA将偏移地址送给BX
	MOV BX, [SI]; 
	执行后：BX=1234H	//MOV将偏移地址和数据段的数送给BX	
```

```
LDS 例，这条指令取两个16位，一个送到指定的SI中，一个送到默认的DS数据段中
设DS=1200H，BX=0020H，（12450H）=F346H，（12452H）=0A90H
则：LDS SI,[450H]; 
执行后：SI=F346H DS=0A90H
```

- 标志传送指令
  - `LAHF; AH<-FLAGS低8位`
  - `SAHF; FLAGS低8位<-AH 8080/8085的FLAG为AH`
  - 常在子程序调用及中断过程：保护/恢复标志
  - `PUSHF; FLAGS入栈`
  - `POPF; 栈顶内容->FLAGS`

#### 算数运算指令

- 包括加、减、乘、除4类运算

- 绝大部分指令影响标志位

- 可处理4位类型数据

- | 二(B)    | 十六(H) | 无符号(D) | 带符号(D) | 非压缩(BCD) | 压缩(BCD) |
  | -------- | ------- | --------- | --------- | ----------- | --------- |
  | 00000111 | 07      | 7         | +7        | 7           | 07        |
  | 10001001 | 89      | 137       | -119      | 无效        | 89        |
  | 11000101 | C5      | 197       | -59       | 无效        | 无效      |


##### 加

- **ADD** 加法指令
  - 格式：`ADD 目的, 源;  目的<-源+目的`
  - 源：寄存器，存储器
  - 目的：寄存器，存储器，立即数
- **ADC** 带进位的加法
  - 格式：`ADC 目的, 源; 目的<-源+目的+CF`

```
例：ADD，ADC
ADD AL, 18H
ADC BL, CL
ADC AX, DX
ADD AL,COST [BX]

分析对FLAGS的影响
MOV AL, 5EH ; 01011110=5EH=94
MOV BL, 3CH ; 00111100=3CH=60
ADD AL, BL  ; AL=100111010=154>127

// FLAGS: CF=0,AF=1,PF=1,ZF=0,SF=1,OF=0与或1=1
// 注意运算指令对FLAGS的影响：
// 无符号数：CF，ZF
// 带符号数: SF,OF,ZF
// BCD码: AF,CF
// 奇偶校验： PF
```

- **INC** 增量指令（自动增1）
  - 格式：`INC 目的 ; 不影响CF`

```
INC BL
INC CX
INC WORD PTR [BX]
// PTR代表属性说明，操作数在[BX]中的属性单元中，WORD就代表对16位数进行操作，不加属性说明就代表按字节加
```

- **AAA**  加法的非压缩BCD调整
  - 格式：`AAA` 
  - 对两个非压缩BCD数相加后位于AL中的和进行调整
  - 使其仍未非压缩BCD，并将结果->AX

```
设AL=BCD9， BL=BCD5
ADD AL,BL ; AL=OEH
AAA       ; AX=0104H,CF=AF=1
		  ; 对于ASCLL，再加一条OR AX，3030H
```

- **DAA** 加法的压缩BCD调整
  - 格式：`DAA`
  - 将两个压缩BCD数相加后位于AL的和调整为压缩BCD->AL

```
设AL=38H, BL=50HM, CL=49H
ADD AL,BL  ; AL=88H
DAA        ; AL=88H
ADD AL,CL  ; AL=88H+49H=D1H
DAA        ; AL=37H,CF=1

校正方法：
	若AL低4位>9或AF=1，则：
	AL<-AL+6，调整低4位；
	若此时AL高4位>9或CF=1，则：
	AL<-AL+60H，调整高4位，且CF=1，
	否则CF清0
```

##### 减

- **SUB** 减法指令
  - 格式：`SUB 目的，源; 目的<-目的-源`
- **SBB** 带借位的减法指令
  - 格式：`SBB 目的，源; 目的<-目的-源-CF`
- **DEC** 减量指令（自动减1）
  - 格式：`DEC 目的; 目的<-目的-1,不影响CF`
- **NEG** 取补指令
  - 格式：`NEG 目的; 目的<-0-目的，求补码`
- **CMP** 比较指令
  - 格式：`CMP 目的，源;目的-源，不回送结果但影响FLAGS`

```
设AL=B1H，DL=4AH
SUB AL,DL; AL=67H  （CF:0，AF:1，ZF:0，SF:0，OF:1，PF:0）
CMP AL,DL; AL不变，FLAGS同上
```

-  **AAS** 减法的非压缩BCD调整/ASCLL调整

```
设AL=BCD3，BL=BCD8，则:
SUB AL,BL ; AL=FBH
AAS       ; AL=BCD5,CF=1

 00000011
-00001000
=11111011
```

- **DAS** 减法的压缩BCD调整

```
设AL=56H，CL=98H
SUB AL,CL; AL=56H-98H=BEH
DAS      ; AL=58H,CF=1
```

##### 乘

- **MUL** 无符号数乘法
  - 格式：`MUL 源; AX<-AL*源 (字节乘) | DX,AX<-AL*源 (字乘)`
  - 若结果的高半部分(字节乘为AH，字乘为DX≠0，CF=OF=1，字乘为DX=0，CF=OF=0)
  - 源：不能为立即数

```
MUL DL 		; AX<-AL*DL
MUL CX 		; DX,AX<-AX*CX
MUL B[SI]   ; AX<-AL*内存中的字节
MUL W[BX]	; DX,AX<-AX*内存中字
```

- **IMUL** 带符号数乘法
  - 格式：`IMUL 源: AX<-AL*源 (字节乘) | DX,AX<-AX*源(字乘)`
  - 若结果的高半部分（AH或DX）为全0或全1，CF=OF=0，表明为符号扩展为;否则，CF=OF=1，表明为乘积的高位

- **AAM** 无符号数乘法的非压缩BCD调整; 调整AL中的非压缩BCD乘积->AX

```
MOV AL, 09H
MOV BL, 06H
MUL BL		; AL=36H
AAM 		; AX=0504H

;ASCLL码作乘法前，需先将高4位清0
```

##### 除

- **DIV** 无符号数除法指令； FLAGS无定义
  - 格式：`DIV 源;`
  - ; AL<-AX/源（B）的商(最大为FFH)
  - ; AH<-余数
  - ; AX<-DX,AX/源(W)的商（最大为FFFFH）
  - ; DX<-余数
- **IDIV** 带符号数除法
  - 格式：`IDIV 源; 余数的符号与被除数相同`
  - ; 字节除:商值范围:-128~+127
  - ; 字除:商值范围:-32768~+32767

```
除法运算要求被除数是除数的2倍长度，
即，16/8或32/16，否色需扩展高位
扩展方法：将符号位扩展至高位寄存器的所有位
```

- **CBW** 扩展字节为字

```
   AH		     AL
00000000	  0xxxxxxx
11111111	  1xxxxxxx
```

- **CWD** 扩展字为双字

```
   	   DX			  		   AX
0000000000000000		0xxxxxxxxxxxxxxx
1111111111111111		1xxxxxxxxxxxxxxx
```

- **AAD** 除法的非压缩BCD调整
  - ; 做除法前，将BCD转换为二进制数

```
设AX=0307H，BL=05H，求AX/BL=？
AAD			; AL=25H
DIV BL		; AX=0207H

；若为压缩BCD，需优化为非压缩BCD
```

#### 逻辑运算与循环移位指令

##### 逻辑运算指令

- **NOT** 取反
  - 格式：NOT 目的; 目的<-目的(非)

```
NOT AX
NOT BL
NOT BYTE [BX]

以下双逻辑操作数逻辑指令执行后：CF=OF=0；ZF，SF，PF反应结果
```

- **AND** 逻辑与
  - 格式：`AND 目的, 源; 目的<-目的∧源`
  - 与0相与,清0；与1相与,不变

```
设AX=3538H，则：AND AX,OFOFH   --->AX=0508H
```

- **OR** 逻辑或
  - 格式：`OR 目的,源; 目的<-目的∨源`
  - 与0相或,不变，与1相或,置1

```
设AX=0508H，则：OR AX,3030H    --->AX=3538H
```

- **XOR** 异或
  - `格式：XOR 目的,源; 目的<-目的 ⊕ 源 ;`
  - ; X⊕0=X;X⊕1=X(非)
  - 与0异或,不变，与1异或求反
  - 如果`目的`和`源`两个值不相同，则异或结果为1。如果`目的`和`源`两个值相同，异或结果为0。

```
IN AL,61H ; 端口61H的D1位控制扬声器
XOR AL, 00000010B
OUT 61H, AL
```

- **TEST** 测试指令
  - 格式：`TEST 目的, 源; 目的∧源，不回送结果，但影响FLAGS`

```
TEST AL,80H; 测AL中第7位
JNZ T_ALARM; D7=1,转温度报警
TEST AL,40H; 测D6位
JNZ P_ALAR; D6=1,转压力报警
... ... ...
```

##### 移位指令

- **SHL** **SAL** 算数/逻辑左移
  - 格式：`SHL/SAL 目的, 计数值`
  - 计数值：移位次数，1次或者CL(多次)
  - ; CF<-MSB<-LSB<-0
  - ; 移位后，若最高位≠CF，则OF=1；若最高位=CF，则OF=0
  - ; 左移1位，相当于乘2

```
MOV AH, 06H
SAL AH, 1
MOV CL, 03H
SHL DI, CL
SAL BYTE PTR [BX], 1
```

- **SHR** 逻辑右移
  - 格式：`SHR 目的, 计数值`
  - 右移一次，无符号数相当于除以2(余数丢弃)

```
MOV AL, 10000110B; AL=134
SHR AL, 1		 ; AL=67
SHR AL, 1 		 ; AL=33, CF=1
```

- **SAL** 算数右移
  - 格式：`SAR 目的, 计数值;`
  - ; 右移一次，带符号数相当于除以2

```
MOV AL, 80H; AL=1000000B=-128
MOV CL, 03H
SAR AL, CL;  AL=1110000B=FOH=-16
```

#### 字符串指令

- **CMPSB/W** 字符串比较指令
  - 格式：`CMPSB/W 目的串, 源串; 不影响串内容，但影响FLAGS`
  - 比较两个字符串：口令串PASSWORD和键盘输入字符串IN_WORD。若相同，程序向下执行；否则，喇叭响，拒绝执行
  - 例![image-20220727154206331](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207271542209.png)

- **SCASB/W** 字符串扫描指令
  - 格式：`SCASB/W 目的串 ; AL/AX--目的串,不回送,但影响FLAGS`

```
例：在字符串中查找关键字'A'
      MOV DI, OFFSET STRING	; DI<-字符串偏移地址
      MOV CX, COUNT			; CX<-串长度
      MOV AL, 'A'				; AL<-关键字'A'
      CLD
      PEPNE SCASB				; 不等且CX≠0时重复
      JZ FIND					; 查到，转FIND
      MOV DI, 0
FIND: MOV BX, DI
	  HLT
```

- **LODS** 字符串装入指令
  - 格式：`LODS 源串; AL/AX<-源串内容，DS:SI自动修改`
- **STOS** 数据传存储指令
  - 格式：`STOSB/W 目的串; 目的串单元<-AL/AX,ES:DI自动修改`
  - 目的串：常用于将某数据区填充相同的数

![image-20220727162823111](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207271628999.png)

#### 控制转移类指令

##### 无条件转移与过程调用返回指令

- **JMP** 无条件转移
  - 格式：`JMP 目的`
  - 4种类型
    - 段内直接转移：段不变，转向的偏移地址=IP当前+DISP(偏移量)
      - `JMP SHORT PTR 标号;` 8位DISP，转移范围：-128~+127
      - `JMP NEAR PTR 标号;` 16位DISP，范围：-32768~+32767 
    - 段内间接转移
      - `JMP BX; 若BX=4500H,则转向4500H处`
    - 段间直接转移
      - `JMP FAR PTR PROG_F;` 跳到另一个段
      - FAR：属性说明跳到比较远的地址，不是8和16位
    - 段间间接转移
      - `JMP DWORD PTR [SI+0125H]`

```
// 段内直接转移
例：地址	 机器码	PROG_S：ADD  AL, 05H
   0000	    0405		 	NOP
   0002	  	90				JMP SHORT PROG_S
   0005		90				NOP
DISP=目的地址——IP当前=0000H-0005H=-5

// 段内间接转移
设DS=2000H，BX=100H，(20105H)=4F0H,则
JMP WORD PTR 5 [BX] ; IP=(20000+100+5)=4F0H

// 段间间接转移
执行前：CS=1200H，IP=05H，DS=2500H
	   SI=1300H，（26425H）=4500H
	   (26427H)=32F0H
执行：JMP DWORD PTR [SI+0125H]
执行后：转向32F0H:4500H
```

- **CALL RET 过程调用与返回指令**

![image-20220728143826977](https://cdn.jsdelivr.net/gh/Luckiiest/noteImage@master/202207281438801.png)

```
调用：CALL 过程名： 
  保护断点：SP<-SP-2,CS入栈
  		  SP<-SP-2,IP入栈
  转子程序入口（与JMP方法一样）
  
返回：RET	; IP<-(栈顶字),SP<-SP+2
		    CS<-(栈顶字),SP<-SP+2（仅对远调用）
		    
返回：RET n; 弹出断电后，再弹出n个字节，SP<-SP+n
```

##### 条件转移指令

- 全为段内短转移

| 助记符 | 功能         | 测试条件     |
| ------ | ------------ | ------------ |
| JC     | 有进位/借位  | CF=1         |
| JNC    | 无进位/借位  | CF=0         |
| JZ/JE  | 结果为0/相等 | ZF=1         |
| JNZ    | 结果非0/不等 | ZF=0         |
| JS     | 为负         | SF=1         |
| JNS    | 为正         | SF=0         |
| JO     | 溢出         | OF=1         |
| JNO    | 无溢出       | OF=0         |
| JP     | 奇偶位为1    | PF=1         |
| JNP    | 奇偶位为0    | PF=0         |
| JA     | 高于         | CF=0         |
| JAE    | 高于等于     | CF∨ZF=0      |
| JB     | 低于         | CF=1         |
| JBE    | 低于等于     | CF∨ZF=1      |
| JG     | 大于         | SF⊕OF=1      |
| JGE    | 大于等于     | (SF⊕OF)∨ZF=0 |
| JL     | 小于         | SF⊕OF=1      |
| JLE    | 小于等于     | (SF⊕OF)∨ZF=1 |

- Above/Below：用于无符号数
- Great/Less：用于带符号数

