<!DOCTYPE html>


  <html class="dark page-post">


<head>
  <meta charset="utf-8">
  
  <title>ES6 | Haodex Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="ES6," />
  

  <meta name="description" content="Es6概述 介绍： ES2015年退出JavaScript新版本也叫ES2015 现在已经ES7（2016），ES8（2017），ES9（2018）很多新增内容仍是填 普遍使用的依然是ES6，ES7部分内容 ES7及后面版本浏览器或node环境未完全支持，但已有babel工具可对其进行编译支持（转成ES5） 所以：新版本语言只是在原有基础上新增了一些语法糖，执行时还会转换为ES5   ECMASc">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6">
<meta property="og:url" content="https://github.com/haodex/haodex.github.io.git/2021/11/08/ES6/index.html">
<meta property="og:site_name" content="Haodex Blog">
<meta property="og:description" content="Es6概述 介绍： ES2015年退出JavaScript新版本也叫ES2015 现在已经ES7（2016），ES8（2017），ES9（2018）很多新增内容仍是填 普遍使用的依然是ES6，ES7部分内容 ES7及后面版本浏览器或node环境未完全支持，但已有babel工具可对其进行编译支持（转成ES5） 所以：新版本语言只是在原有基础上新增了一些语法糖，执行时还会转换为ES5   ECMASc">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-08T07:35:53.000Z">
<meta property="article:modified_time" content="2021-11-11T10:35:43.482Z">
<meta property="article:author" content="Haodex">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">
<link href="/css/other.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  

  

  


  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  <!-- 聊天系统 -->
  
    
   <link type="text/css" rel="stylesheet" href="/renxi/default.css">
   <style>
      #modal {
        position: static !important;
      }
      .filter {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: #fe5757;
        animation: colorChange 30s ease-in-out infinite;
        animation-fill-mode: both;
        mix-blend-mode: overlay;
      }
  
      @keyframes colorChange {
        0%, 100% {
            opacity: 0;
        }
        50% {
            opacity: .9;
        }
      }
   </style>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Haodex Blog" type="application/atom+xml">
</head>

<body>
  
  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录<i class="iconfont toc-title" style="display:inline-block;color:#87998d;width:20px;height:20px;">&#xf004b;</i></strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Es6"><span class="toc-text">Es6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A"><span class="toc-text">块级绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#babel%E6%9C%AC%E5%9C%B0%E4%BD%BF%E7%94%A8"><span class="toc-text">babel本地使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8const%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F"><span class="toc-text">使用const声明常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2API"><span class="toc-text">更多的字符串API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8C%E9%87%8D%E7%94%A8%E9%80%94"><span class="toc-text">确函数的双重用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="toc-text">新增的对象字面量语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-amp-reflect"><span class="toc-text">proxy &amp; reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-Class"><span class="toc-text">类-Class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-text">类：构造函数的语法糖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decorator-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">Decorator(装饰器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES7%E4%B9%8BClass%E6%8F%90%E6%A1%88%E5%B1%9E%E6%80%A7"><span class="toc-text">ES7之Class提案属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%86%99Class"><span class="toc-text">手写Class</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6%E4%B9%8B%E6%A8%A1%E6%8B%9Fclass"><span class="toc-text">ES6之模拟class</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES5%E6%A8%A1%E6%8B%9F%E4%B9%8BClass"><span class="toc-text">ES5模拟之Class</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84-destructuring"><span class="toc-text">解构(destructuring)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-text">对象解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%BB%93%E6%9E%84"><span class="toc-text">参数结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="toc-text">符号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%AC%A6%E5%8F%B7"><span class="toc-text">普通符号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-toStringTag"><span class="toc-text">Symbol.toStringTag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">事件和回调函数的缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise%E7%9A%84%E4%B8%B2%E8%81%94"><span class="toc-text">Promise的串联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise%E7%9A%84%E5%85%B6%E4%BB%96api"><span class="toc-text">Promise的其他api</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES5%E4%B9%8B%E6%89%8B%E5%86%99Promise"><span class="toc-text">ES5之手写Promise</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E5%92%8C-await"><span class="toc-text">async 和 await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await"><span class="toc-text">await</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FetchApi"><span class="toc-text">FetchApi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch-Api-%E6%A6%82%E8%BF%B0"><span class="toc-text">Fetch Api 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-%E5%AF%B9%E8%B1%A1"><span class="toc-text">Request 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Response-%E5%AF%B9%E8%B1%A1"><span class="toc-text">Response 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headers-%E5%AF%B9%E8%B1%A1"><span class="toc-text">Headers 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">文件上传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">迭代器和生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="toc-text">迭代器(Iterator)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-text">背景知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">JS中的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-of-%E5%BE%AA%E7%8E%AF"><span class="toc-text">for-of 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">展开运算符与可迭代对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Generator"><span class="toc-text">生成器 (Generator)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES5%E4%B9%8B%E5%AE%9E%E7%8E%B0Map"><span class="toc-text">ES5之实现Map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet-%E5%92%8C-WeakMap"><span class="toc-text">WeakSet 和 WeakMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakSet"><span class="toc-text">WeakSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-text">代理与反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%9B%9E%E9%A1%BE%E3%80%91%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">【回顾】属性描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">存取器属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect"><span class="toc-text">Reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-%E4%BB%A3%E7%90%86"><span class="toc-text">Proxy 代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%B7%E6%87%92%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">偷懒的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%AA%8C%E8%AF%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">可验证的函数参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%95%B0%E7%BB%84%E5%8A%9F%E8%83%BD"><span class="toc-text">增强的数组功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E7%BB%84API"><span class="toc-text">新增的数组API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-text">[扩展]类型化数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%98%E5%82%A8%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">数字存储的前置知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-text">类型化数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBuffer"><span class="toc-text">ArrayBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99ArrayBuffer"><span class="toc-text">读写ArrayBuffer</span></a></li></ol></li></ol></li></ol></li></ol>
  </div>
  




<div class="content content-post CENTER">
   <!-- canvas 彩带 -->
<canvas id="evanyou" width="1302" height="678" style="position: fixed;width: 100%;height: 100%;top: 0;left:0;z-index:-1;"></canvas>

<!-- <div class="qrcode_container">
  <div class="tencent_code">
    <h4>关注作者公众号</h4> 
    <p>和万千小伙伴一起学习</p> 
    <img src="https://poetries1.gitee.io/img-repo/2020/06/qrcode.jpg" alt="">
  </div> 
</div> -->

<article id="post-ES6" class="article article-type-post" itemprop="blogPost">
  <header class="article-header" style="position:relative;">
    <h1 class="post-title">ES6</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.11.08</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Haodex</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
       
          <span class="post-count">
            <i class="fa fa-file-word-o"></i>&nbsp
            <span>字数统计 29k字</span>
          </span>

          <span class="post-count">
            <i class="fa fa-columns"></i>&nbsp
            <span>阅读时长 130分</span>
          </span>
      
      
    </div>

    <i class="iconfont" id="toc-eye" style="display:inline-block;color:#b36619;position:absolute;top:0;right:0;cursor:pointer;
    font-size: 24px;">&#xe61c;</i>

  </header>

  <div class="article-content">
    
      <div id="container">
        <h1 id="Es6"><a href="#Es6" class="headerlink" title="Es6"></a>Es6</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>介绍：<ul>
<li><code>ES2015</code>年退出<code>JavaScript</code>新版本也叫<code>ES2015</code></li>
<li>现在已经<code>ES7（2016）</code>，<code>ES8（2017）</code>，<code>ES9（2018）</code>很多新增内容仍是填</li>
<li>普遍使用的依然是<code>ES6</code>，<code>ES7</code>部分内容</li>
<li><code>ES7</code>及后面版本浏览器或node环境未完全支持，但已有<code>babel</code>工具可对其进行编译支持（转成<code>ES5</code>）</li>
<li>所以：新版本语言只是在原有基础上新增了一些语法糖，执行时还会转换为<code>ES5</code></li>
</ul>
</li>
<li><strong>ECMAScript</strong>、<strong>JavaScript</strong>、<strong>NodeJs</strong>，它们的区别是什么？<ul>
<li><code>ECMAScript</code>：简称<code>ES</code>，是一个语言标准（循环、判断、变量、数组等数据类型）</li>
<li><code>JavaScript</code>：运行在浏览器端的语言，该语言使用<code>ES</code>标准，<code>ES + web api = JavaScript</code></li>
<li><code>NodeJs</code>：运行在服务器端的语言，该语言使用<code>ES</code>标准，<code>ES + node api = JavaScript</code></li>
</ul>
</li>
<li><strong>ECMAScript</strong>有哪些关键的版本？<ul>
<li><code>ES3.0</code>：<code>1999</code></li>
<li><code>ES5.0</code>：<code>2009</code></li>
<li><code>ES6.0</code>：<code>2015</code>，从该版本不再使用数字作为编号，而使用年份，也叫<code>ES2015</code></li>
<li><code>ES7.0</code>：<code>2016</code></li>
</ul>
</li>
<li>为什么<strong>ES6</strong>如此重要？<ul>
<li><code>ES6</code>解决<code>JS</code>无法开发大型应用的语言层面的问题。</li>
</ul>
</li>
<li>为什么要学习<code>ES6</code>？<ul>
<li><code>ES6</code>引入的语言新特性，更具规范性，易读性，方便操作，简化了大型项目开发的复杂程度、降低了出错概率，提升了开发效率</li>
<li>大部分公司（不代表所有，代表着一个趋势）都在用<code>ES6</code>开发，已成为开发，求职必会内容</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="块级绑定"><a href="#块级绑定" class="headerlink" title="块级绑定"></a>块级绑定</h2><h3 id="babel本地使用"><a href="#babel本地使用" class="headerlink" title="babel本地使用"></a>babel本地使用</h3><ul>
<li><p>用<code>Babel</code>工具做对比<code>ES6</code>-&gt;低级语法</p>
</li>
<li><p>在线<code>Babel</code>工具(<a target="_blank" rel="noopener" href="https://babeljs.io/repl)%EF%BC%88https://babeljs.cn%EF%BC%89">https://babeljs.io/repl)（https://babeljs.cn）</a></p>
</li>
<li><p><code>npm</code>本地下载工具（用于生产环境）</p>
<ul>
<li><p><code>npm init -y</code> ：初始化</p>
</li>
<li><p><code>npm install @babel/core @babel/cli @babel/preset-env</code>：安装<strong>Babel</strong></p>
</li>
<li><p><code>npx babel xxx.js(需要被转换的文件名称) -o xxx.js(转换完成的文件名称) --watch</code>：编译<code>ES6</code>格式的<code>js</code>文件，<code>--watch</code>是时刻监控(更新)</p>
</li>
<li><p><strong>babel</strong>配置文件：</p>
<ul>
<li><p><strong>.babelrc</strong>文件，严格<code>json</code></p>
</li>
<li><p>```js<br>{</p>
<pre><code>&quot;presets&quot;: [
    &quot;@babel/preset-env&quot;
],
&quot;plugins&quot;: [

],
……
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 声明变量的问题</span><br><span class="line"></span><br><span class="line">- 使用`var`声明变量</span><br><span class="line">- 允许重复的变量声明：导致数据被覆盖</span><br><span class="line">- 变量提升：怪异的数据访问、闭包问题</span><br><span class="line">- 全局变量挂载到`window`全局对象：全局对象成员污染问题</span><br><span class="line"></span><br><span class="line">### 使用let声明变量</span><br><span class="line"></span><br><span class="line">- 加强了对作用域的控制</span><br><span class="line"></span><br><span class="line">`ES6`不仅引入`let`关键字用于解决变量声明的问题，同时引入了块级作用域的概念</span><br><span class="line"></span><br><span class="line">块级作用域：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域</span><br><span class="line"></span><br><span class="line">- 特点</span><br><span class="line">  - `let`声明的变量不会挂载到全局对象</span><br><span class="line">  - `let`声明的变量，不允许当前作用域范围内重复声明</span><br><span class="line">  - 在块级作用域中用`let`定义的变量，在作用域外不能访问</span><br><span class="line">  - 使用`let`不会有变量提升，因此，不能在定义`let`变量之前使用它</span><br><span class="line"></span><br><span class="line">底层实现上，`let`声明的变量实际上也会有提升，但是，提升后会将其放入到“暂时性死区”，如果访问的变量位于暂时性死区，则会报错：`“Cannot access &#x27;a&#x27; before initialization”`。当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。</span><br><span class="line"></span><br><span class="line">在循环中，用`let`声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域（每次循环，使用的是一个全新的循环变量）</span><br><span class="line"></span><br><span class="line">在循环中使用`let`声明的循环变量，在循环结束后会销毁</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">//临时死区</span><br><span class="line">let a = 10;</span><br><span class="line">&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    //Cannot access &#x27;a&#x27; before initialization</span><br><span class="line">    let a = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//闭包</span><br><span class="line">var arr = [];</span><br><span class="line">//let声明会销毁块级作用域</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	arr[i] = function()&#123; </span><br><span class="line">		console.log(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[0]();</span><br><span class="line">arr[4]();</span><br><span class="line">arr[7]();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用const声明常量"><a href="#使用const声明常量" class="headerlink" title="使用const声明常量"></a>使用const声明常量</h3><blockquote>
<p> <code>const</code>和<code>let</code>完全相同，仅在于用<code>const</code>声明的变量，必须在声明时赋值，而且不可以重新赋值。</p>
</blockquote>
<ul>
<li>实际上，在开发中，应该尽量使用<code>const</code>来声明变量，以保证变量的值不会随意篡改，原因如下：</li>
</ul>
<ol>
<li><p>根据经验，开发中的很多变量，都是不会更改，也不应该更改的。</p>
</li>
<li><p>后续的很多框架或者是第三方<code>JS</code>库，都要求数据不可变，使用常量可以一定程度上保证这一点。</p>
</li>
<li><p>注意的细节：</p>
<ol>
<li><p>常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变。</p>
<ol>
<li>```js<br>const PI = {};<br>PI.name = 20;<br>//PI = 20;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   1. 常量的命名</span><br><span class="line">      1. 特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率、月地距地或其他一些绝不可能变化的配置。通常，**该常量的名称全部使用大写，多个单词之间用下划线分割**</span><br><span class="line">      2. 普通的常量：使用和之前一样的命名即可</span><br><span class="line">   2. 在`for`循环中，循环变量不可以使用常量</span><br><span class="line"></span><br><span class="line">## 字符串和正则表达式</span><br><span class="line"></span><br><span class="line">### 更好的Unicode支持</span><br><span class="line"></span><br><span class="line">- 早期，由于存储空间宝贵，`Unicode`使用`16`位二进制来存储文字。我们将一个`16`位的二进制编码叫做一个码元（`Code Unit`）。</span><br><span class="line"></span><br><span class="line">- 后来，由于技术的发展，`Unicode`对文字编码进行了扩展，将某些文字扩展到了`32`位（占用两个码元），并且，将某个文字对应的二进制数字叫做码点（`Code Point`）。</span><br><span class="line"></span><br><span class="line">- `ES6`为了解决这个困扰，为字符串提供了方法：`codePointAt`，根据字符串码元的位置得到其码点。</span><br><span class="line"></span><br><span class="line">- 同时，`ES6`为正则表达式添加了一个`flag: u`，如果添加了该配置，则匹配时，使用码点匹配</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const text = &#x27;𠮷&#x27;;</span><br><span class="line">  </span><br><span class="line">  console.log(&quot;字符串长度：&quot;, text.length);</span><br><span class="line">  console.log(&quot;使用正则测试：&quot;, /^.$/u.test(text));</span><br><span class="line">  console.log(&quot;得到第一个码元：&quot;, text.charCodeAt(0));</span><br><span class="line">  console.log(&quot;得到第二个码元：&quot;, text.charCodeAt(1));</span><br><span class="line">  </span><br><span class="line">  //𠮷：\ud842\udfb7</span><br><span class="line">  console.log(&quot;得到第一个码点：&quot;, text.codePointAt(0));</span><br><span class="line">  console.log(&quot;得到第二个码点：&quot;, text.codePointAt(1));</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 判断字符串char，是32位，还是16位</span><br><span class="line">   * @param &#123;*&#125; char </span><br><span class="line">   */</span><br><span class="line">  function is32bit(char, i) &#123;</span><br><span class="line">      //如果码点大于了16位二进制的最大值，则其是32位的</span><br><span class="line">      return char.codePointAt(i) &gt; 0xffff;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 得到一个字符串码点的真实长度</span><br><span class="line">   * @param &#123;*&#125; str </span><br><span class="line">   */</span><br><span class="line">  function getLengthOfCodePoint(str) &#123;</span><br><span class="line">      var len = 0;</span><br><span class="line">      for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">          //i在索引码元</span><br><span class="line">          if (is32bit(str, i)) &#123;</span><br><span class="line">              //当前字符串，在i这个位置，占用了两个码元</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          len++;</span><br><span class="line">      &#125;</span><br><span class="line">      return len;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  console.log(&quot;𠮷是否是32位的：&quot;, is32bit(&quot;𠮷&quot;, 0))</span><br><span class="line">  console.log(&quot;ab𠮷ab的码点长度：&quot;, getLengthOfCodePoint(&quot;ab𠮷ab&quot;))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="更多的字符串API"><a href="#更多的字符串API" class="headerlink" title="更多的字符串API"></a>更多的字符串API</h3><ul>
<li><p>以下均为字符串的实例（原型）方法</p>
</li>
<li><p><strong>includes</strong>：判断字符串中是否包含指定的子字符串</p>
</li>
<li><p><strong>startsWith</strong>：判断字符串中是否以指定的字符串开始</p>
</li>
<li><p><strong>endsWith</strong>：判断字符串中是否以指定的字符串结尾</p>
</li>
<li><p><strong>repeat</strong>：将字符串重复指定的次数，然后返回一个新字符串。</p>
</li>
<li><p>```js<br>const text = “成哥是狠人”;</p>
<p>console.log(“是否包含“狠”：”, text.includes(“狠”));<br>console.log(“是否以“成哥”开头：”, text.startsWith(“成哥”));<br>console.log(“是否以“狠人”结尾：”, text.endsWith(“狠人”));<br>console.log(“重复4次：”, text.repeat(4));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 模板字符串</span><br><span class="line"></span><br><span class="line">- `ES6`之前处理字符串繁琐的两个方面：</span><br><span class="line">  - 多行字符串</span><br><span class="line">  - 字符串拼接</span><br><span class="line"></span><br><span class="line">- 在`ES6`中，提供了模板字符串的书写，可以非常方便的换行和拼接，要做的，仅仅是将字符串的开始或结尾改为 **`** 符号</span><br><span class="line"></span><br><span class="line">- 如果要在字符串中拼接`js`表达式，只需要在模板字符串中使用```$&#123;JS表达式&#125;```</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  let val = &quot;我是&quot;</span><br><span class="line">  var text = `$&#123;val&#125;人` </span><br><span class="line">  //等同于</span><br><span class="line">  var text = &quot;我是&quot; + &quot;人&quot;;</span><br><span class="line">  //$&#123;表达式&#125;，表达式可以是任何表达式</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><ul>
<li><p>使用</p>
<ul>
<li><p>在书写形参时，直接给形参赋值，附的值即为默认值</p>
</li>
<li><p>这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是<code>undefined</code>），则会自动使用默认值。</p>
</li>
<li><p>```js<br>function sum(a, b = 1, c = 2) {</p>
<pre><code>return a + b + c;
</code></pre>
<p>}<br>console.log(sum(10, undefined, undefined))<br>console.log(sum(11))<br>console.log(sum(1, undefined, 5))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- [扩展]对**arguments**的影响</span><br><span class="line"></span><br><span class="line">  - 只要给函数加上参数默认值，该函数会自动变量严格模式下的规则：arguments和形参脱离</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    function getContainer() &#123;</span><br><span class="line">        console.log(&quot;abc&quot;);</span><br><span class="line">        return document.getElementById(&quot;container&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 创建一个元素</span><br><span class="line">     * @param &#123;*&#125; name 元素的名称 </span><br><span class="line">     * @param &#123;*&#125; container 元素的父元素</span><br><span class="line">     * @param &#123;*&#125; content 元素的内容 </span><br><span class="line">     */</span><br><span class="line">    function createElement(name = &quot;div&quot;, container = getContainer(), content = &quot;&quot;) &#123;</span><br><span class="line">        const ele = document.createElement(name)</span><br><span class="line">        if (content) &#123;</span><br><span class="line">            ele.innerHTML = content;</span><br><span class="line">        &#125;</span><br><span class="line">        container.appendChild(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    createElement(undefined, undefined, &quot;手动阀手动阀十分&quot;)</span><br><span class="line">    createElement(undefined, undefined, &quot;234242342424&quot;)</span><br><span class="line">    createElement(undefined, document.getElementById(&quot;container&quot;), &quot;234242342424&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>[扩展]留意暂时性死区</p>
<ul>
<li><p>形参和<code>ES6</code>中的<code>let</code>或<code>const</code>声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。</p>
</li>
<li><p>```js<br>function test(a, b = 1) {</p>
<pre><code>console.log(&quot;arugments&quot;, arguments[0], arguments[1]);
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b);
a = 3;
console.log(&quot;arugments&quot;, arguments[0], arguments[1]);
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b);
</code></pre>
<p>}</p>
<p>test(1, 2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 剩余参数</span><br><span class="line"></span><br><span class="line">- **arguments**的缺陷：</span><br><span class="line"></span><br><span class="line">  - 如果和形参配合使用，容易导致混乱</span><br><span class="line">  - 从语义上，使用`arguments`获取参数，由于形参缺失，无法从函数定义上理解函数的真实意图</span><br><span class="line"></span><br><span class="line">- **ES6**的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。</span><br><span class="line"></span><br><span class="line">  - 语法:</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    function (...形参名)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li><p>```js<br>function test(a, b, …args) {</p>
<p>}</p>
<p>test(1, 32, 46, 7, 34); </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  function sum(...args) &#123;</span><br><span class="line">      //args收集了所有的参数，形成的一个数组</span><br><span class="line">      let sum = 0;</span><br><span class="line">      for (let i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">          sum += args[i];</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  console.log(sum())</span><br><span class="line">  console.log(sum(1))</span><br><span class="line">  console.log(sum(1, 2))</span><br><span class="line">  console.log(sum(1, 2, 3))</span><br><span class="line">  console.log(sum(1, 2, 3, 4))</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>function test(…args1, …args2) {</p>
<pre><code>console.log(args1)
console.log(args2)
</code></pre>
<p>}</p>
<p>test(1, 32, 46, 7, 34);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **细节：**</span><br><span class="line">  - 一个函数，仅能出现一个剩余参数</span><br><span class="line">  - 一个函数，如果有剩余参数，剩余参数必须是最后一个参数</span><br><span class="line"></span><br><span class="line">### 展开运算符</span><br><span class="line"></span><br><span class="line">使用方式：```  ...要展开的东西  ```</span><br><span class="line"></span><br><span class="line">- 对数组展开 **ES6**</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    const arr1 = [3, 67, 8, 5];</span><br><span class="line">    </span><br><span class="line">    //克隆arr1数组到arr2</span><br><span class="line">    </span><br><span class="line">    const arr2 = [0, ...arr1, 1];</span><br><span class="line">    </span><br><span class="line">    console.log(arr2, arr1 === arr2)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对对象展开 <strong>ES7</strong></p>
<ul>
<li><p>```js<br>const obj1 = {</p>
<pre><code>name: &quot;成哥&quot;,
age: 18,
love: &quot;邓嫂&quot;,
address: &#123;
    country: &quot;中国&quot;,
    province: &quot;黑龙江&quot;,
    city: &quot;哈尔滨&quot;
&#125;
</code></pre>
<p>}</p>
<p>// 浅克隆到obj2</p>
<p>const obj2 = {</p>
<pre><code>...obj1,
name: &quot;邓哥&quot;
</code></pre>
<p>};</p>
<p>console.log(obj2)</p>
<p>console.log(obj1.address === obj2.address)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    const obj1 = &#123;</span><br><span class="line">        name: &quot;成哥&quot;,</span><br><span class="line">        age: 18,</span><br><span class="line">        loves: [&quot;邓嫂&quot;, &quot;成嫂1&quot;, &quot;成嫂2&quot;],</span><br><span class="line">        address: &#123;</span><br><span class="line">            country: &quot;中国&quot;,</span><br><span class="line">            province: &quot;黑龙江&quot;,</span><br><span class="line">            city: &quot;哈尔滨&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 浅克隆到obj2</span><br><span class="line">    const obj2 = &#123;</span><br><span class="line">        ...obj1,</span><br><span class="line">        name: &quot;邓哥&quot;,</span><br><span class="line">        address: &#123;</span><br><span class="line">            ...obj1.address</span><br><span class="line">        &#125;,</span><br><span class="line">        loves: [...obj1.loves, &quot;成嫂3&quot;]</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    console.log(obj2)</span><br><span class="line">    </span><br><span class="line">    console.log(obj1.loves === obj2.loves)</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>/**</p>
<ul>
<li>对所有数字求和</li>
<li>@param  {…any} args </li>
<li>/<br>function sum(…args) {<br>  let sum = 0;<br>  for (let i = 0; i &lt; args.length; i++) {<pre><code>  sum += args[i];
</code></pre>
  }<br>  return sum;<br>}</li>
</ul>
<p>/**</p>
<ul>
<li>获取一个指定长度的随机数组成的数组</li>
<li>@param {*} length </li>
<li>/<br>function getRandomNumbers(length) {<br>  const arr = [];<br>  for (let i = 0; i &lt; length; i++) {<pre><code>  arr.push(Math.random());
</code></pre>
  }<br>  return arr;<br>}</li>
</ul>
<p>const numbers = getRandomNumbers(10);<br>//将数组的每一项展开，依次作为参数传递，而不是把整个数组作为一个参数传递<br>// sum(numbers)</p>
<p>console.log(sum(…numbers))//相当于传递了10个参数<br>console.log(sum(1, 3, …numbers, 3, 5))</p>
</li>
</ul>
</li>
</ul>
<h3 id="确函数的双重用途"><a href="#确函数的双重用途" class="headerlink" title="确函数的双重用途"></a>确函数的双重用途</h3><blockquote>
<p><code>ES6</code>提供了一个特殊的<code>API</code>，可以使用该<code>API</code>在函数内部，判断该函数是否使用了<code>new</code>来调用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>.target </span><br><span class="line"><span class="comment">//该表达式，得到的是：如果没有使用new来调用函数，则返回undefined</span></span><br><span class="line"><span class="comment">//如果使用new调用函数，则得到的是new关键字后面的函数本身</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>```js<br>function Person(firstName, lastName) {</p>
<pre><code>//判断是否是使用new的方式来调用的函数

// //过去的判断方式
// if (!(this instanceof Person)) &#123;
//     throw new Error(&quot;该函数没有使用new来调用&quot;)
// &#125;

if (new.target === undefined) &#123;
    throw new Error(&quot;该函数没有使用new来调用&quot;)
&#125;
this.firstName = firstName;
this.lastName = lastName;
this.fullName = `$&#123;firstName&#125; $&#123;lastName&#125;`;
</code></pre>
<p>}</p>
<p>const p1 = new Person(“袁”, “进”);<br>console.log(p1)</p>
<p>const p2 = Person(“袁”, “进”);<br>console.log(p2);</p>
<p>const p3 = Person.call(p1, “袁”, “进”)<br>console.log(p3);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 箭头函数</span><br><span class="line"></span><br><span class="line">- 回顾：`this`指向</span><br><span class="line">  - 通过对象调用函数，`this`指向对象</span><br><span class="line">  - 直接调用函数，`this`指向全局对象</span><br><span class="line">  - 如果通过`new`调用函数，`this`指向新创建的对象</span><br><span class="line">  - 如果通过`apply`、`call`、`bind`调用函数，`this`指向指定的数据</span><br><span class="line">  - 如果是`DOM`事件函数，`this`指向事件源</span><br><span class="line">- 特点</span><br><span class="line">  - 不用写`function`关键字</span><br><span class="line">  - 只能作为函数使用不能`new`为构造函数，没有原型</span><br><span class="line">  - 参数不能重复命名</span><br><span class="line">  - 返回值可以不写`return`，但是有时需要配合`&#123;&#125;`</span><br><span class="line">  - 内部`arguments`、`this` 由定义时外围最接近一层的非箭头函数的`arguments`和`this`决定其值</span><br><span class="line"></span><br><span class="line">- 使用语法</span><br><span class="line">  - 箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数</span><br><span class="line"></span><br><span class="line">  - 完整语法：</span><br><span class="line"></span><br><span class="line">    - ```js</span><br><span class="line">      (参数1, 参数2, ...)=&gt;&#123;</span><br><span class="line">          //函数体</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      const isOdd = (num) =&gt; &#123;</span><br><span class="line">          return num % 2 !== 0;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果参数只有一个，可以省略小括号</p>
<ul>
<li>```js<br>参数 =&gt; const print = num =&gt; {console.log(“给我的数字是：”, num)}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如果箭头函数只有一条返回语句，可以省略大括号，和`return`关键字</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    参数 =&gt; 返回值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意细节</p>
<ul>
<li>箭头函数中，不存在<code>this</code>、<code>arguments</code>、<code>new.target</code>，如果使用了，则使用的是函数外层的对应的<code>this</code>、<code>arguments</code>、<code>new.target</code></li>
<li>箭头函数没有原型</li>
<li>箭头函数不能作用构造函数使用</li>
</ul>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>临时性使用的函数，并不会可以调用它，比如：</li>
<li>事件处理函数</li>
<li>异步处理函数</li>
<li>其他临时性的函数</li>
<li>为了绑定外层this的函数</li>
</ul>
<ol start="3">
<li>在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li>
</ol>
</li>
<li><p>实例</p>
<ul>
<li><p>```js<br>//原来的函数<br>function sum(a,b) {</p>
<pre><code>return a + b;
</code></pre>
<p>}</p>
<p>//箭头函数<br>//求和,可以不写return，但是函数体需要在箭头后面<br>let sum = (a,b) =&gt; a + b;</p>
<p>//对象,如果想返回对象，则需要将对象变为函数表达式，大括号外面加一层括号,({})<br>let sum = (a,b) =&gt; ({a:a,b:b});</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 例：高阶函数</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    //高阶函数：如果一个函数接受一个参数以后，如果返回一个函数的话就是高阶函数，或者这个函数能够接受一个参数，这个参数是一个函数的话也是高阶函数</span><br><span class="line">    </span><br><span class="line">    //普通形式</span><br><span class="line">    function sum(x) &#123;</span><br><span class="line">    	return function(y) &#123;</span><br><span class="line">            return function (z) &#123;</span><br><span class="line">                return x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var sum1 = sum(1);</span><br><span class="line">    var sum2 = sum1(2);</span><br><span class="line">    console.log(sum2(3));</span><br><span class="line">    </span><br><span class="line">    //箭头函数形式</span><br><span class="line">    let sum = (x) =&gt; &#123;</span><br><span class="line">        return (y) =&gt; &#123;</span><br><span class="line">            return (z) =&gt; &#123;</span><br><span class="line">                return x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //当去掉return时就变为下面的形式了</span><br><span class="line">    //当箭头函数的形参只有一个时，是可以去掉参数的括号，但是当形参有一个以上的情况下，需要括上括号</span><br><span class="line">    let sum = (x) =&gt; (y) =&gt; (z) =&gt; x + y + z;</span><br><span class="line">    sum(1)(2)(3);</span><br></pre></td></tr></table></figure></li>
<li><p>不能<code>new</code></p>
<ul>
<li>```js<br>let sum = () =&gt; {<pre><code>this.a = 10;
</code></pre>
}new sum();//会报错<br>//arrow.js:33 Uncaught TypeError: sum is not a constructor at arrow.js:33<br>//sum.prototype =&gt; undefined<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 形式区分：</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    //函数形式</span><br><span class="line">    let sum = () =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    sum();</span><br><span class="line">    </span><br><span class="line">    //对象形式</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        fn: () =&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.fn();</span><br><span class="line">    </span><br><span class="line">    //数组形式</span><br><span class="line">    let arr = [() =&gt; &#123;&#125;]</span><br><span class="line">    arr[0()];</span><br><span class="line">    </span><br><span class="line">    //同时也可以返回值也可以是箭头函数</span><br><span class="line">    return () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>arguments</strong>特点</p>
<ul>
<li><p>```js<br>//内部arguments、this 由定义时外围最接近一层的非箭头函数的arguments和this决定其值，也就是说箭头函数的外围不是箭头函数才会有arguments</p>
<p>function outer() {</p>
<pre><code>//arguments
//9 10 11
let sum = (a,b) =&gt; &#123;
    console.log(arguments,a,b);
    //这个输出的argument就是outer的arguments，箭头函数本身没有arguments
&#125;;
sum(1,2);
</code></pre>
<p>}<br>outer(9,10,11);</p>
<p>//当函数需要返回外围函数的arguments时，可以使用箭头函数</p>
<p>function Curry() {</p>
<pre><code>/* 
var arg = arguments;
return function() &#123;
   console.log(arg,arguments)
    //如果不使用箭头函数，这个arguments就是这个函数本身的arguments，就需要外围声明一个变量储存arguments
&#125; 
*/
return () =&gt; &#123;
    console.log(arguments);
&#125;
</code></pre>
<p>}<br>Curry(1,2,3);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **this**特点</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    //当箭头函数外围没有非箭头函数时，则this等于window</span><br><span class="line">    var a = &#x27;outerObj&#x27;;</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        a:&quot;innserObj&quot;,</span><br><span class="line">        fn: () =&gt; &#123;</span><br><span class="line">            // this =&gt; window</span><br><span class="line">            console.log(this.a);//outerObj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.fn();</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>var a = ‘outerObj’;<br>let obj = {</p>
<pre><code>a: &#39;innerObj&#39;,
//fn() &#123;&#125;就相当于fn: function()&#123;&#125;
fn() &#123;
    let sum = () =&gt; &#123;
        //this =&gt; window，这时外围就有了非箭头函数了，this指向也就变味了obj
        console.log(this.a); //innserObj
    &#125;
    return sum;
&#125;
</code></pre>
<p>}<br>let outerSum = obj.fn();<br>outerSum();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  let obj = &#123;</span><br><span class="line">      ms: &#x27;abc&#x27;,</span><br><span class="line">      fn() &#123;</span><br><span class="line">          // var self = this;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">              console.log(this.ms);</span><br><span class="line">          &#125;,500)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  obj.fn();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="新增的对象字面量语法"><a href="#新增的对象字面量语法" class="headerlink" title="新增的对象字面量语法"></a>新增的对象字面量语法</h3><ul>
<li><p>成员速写</p>
<ul>
<li>如果对象字面量初始化时，成员的名称来自于一个变量，并且和变量的名称相同，则可以进行简写</li>
</ul>
</li>
<li><p>方法速写</p>
<ul>
<li>对象字面初始化时，方法可以省略冒号和<code>function</code>关键字</li>
</ul>
</li>
<li><p>计算属性名</p>
<ul>
<li>有的时候，初始化对象时，某些属性名可能来自于某个表达式的值，在<code>ES6</code>，可以使用中括号来表示该属性名是通过计算得到的。</li>
</ul>
</li>
<li><p>```js<br>const prop1 = “name2”;<br>const prop2 = “age2”;<br>const prop3 = “sayHello2”;</p>
<p>const user = {</p>
<pre><code>[prop1]: &quot;姬成&quot;,
[prop2]: 100,
// 方法可以省略冒号和关键字
[prop3]()&#123;
    console.log(this[prop1], this[prop2])
&#125;
</code></pre>
<p>}</p>
<p>user<a href="">prop3</a>;</p>
<p>console.log(user)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### Object的新增API</span><br><span class="line"></span><br><span class="line">- **Object.is**</span><br><span class="line">  - 用于判断两个数据是否相等，基本上跟严格相等（===）是一致的，除了以下两点：</span><br><span class="line">  - `NaN`和`NaN`相等</span><br><span class="line">  - `+0`和`-0`不相等</span><br><span class="line">- **Object.assign**</span><br><span class="line">  - 用于混合对象</span><br><span class="line">- **Object.getOwnPropertyNames** 的枚举顺序</span><br><span class="line">  - `Object.getOwnPropertyNames`方法之前就存在，只不过，官方没有明确要求，对属性的顺序如何排序，如何排序，完全由浏览器厂商决定。</span><br><span class="line">  - `ES6`规定了该方法返回的数组的排序方式如下：</span><br><span class="line">    - 先排数字，并按照升序排序</span><br><span class="line">    - 再排其他，按照书写顺序排序</span><br><span class="line">- **Object.setPrototypeOf**</span><br><span class="line">  - 该函数用于设置某个对象的隐式原型</span><br><span class="line">  - 比如： `Object.setPrototypeOf(obj1, obj2)`，相当于：  ` obj1.__proto__ = obj2 `</span><br><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    console.log(NaN === NaN); // false</span><br><span class="line">    console.log(+0 === -0);  // true</span><br><span class="line">    </span><br><span class="line">    console.log(Object.is(NaN, NaN)) //true</span><br><span class="line">    console.log(Object.is(+0, -0)) // false</span><br></pre></td></tr></table></figure>

<ul>
<li><p>```js<br>const obj1 = {</p>
<pre><code>a: 1
</code></pre>
<p>}<br>const obj2 = {</p>
<pre><code>b: 2
</code></pre>
<p>}</p>
<p>// obj1.<strong>proto</strong> = obj2<br>Object.setPrototypeOf(obj1, obj2)<br>console.log(obj1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### Object.defineProperty</span><br><span class="line"></span><br><span class="line">- 简介</span><br><span class="line"></span><br><span class="line">  - `ES5`规范开始后续版本迭代，也在致力于做一件事，就是把`js`底层已有的功能，提供给开发者使用。`Object.defineProperty`就是其中一个，此方法会可直接在一个对象上定义一个新的具有详细描述的属性，或者修改一个对象的现有属性，并返回这个对象。</span><br><span class="line">  - 在一个对象上定义一个新的具有详细描述的属性，或者修改一个对象的现有属性。</span><br><span class="line"></span><br><span class="line">- 使用：</span><br><span class="line"></span><br><span class="line">  - **Object.defineProperty**(对象,属性,描述符);</span><br><span class="line"></span><br><span class="line">  - 描述符对象的属性的进行详细描述：</span><br><span class="line"></span><br><span class="line">    - 数据描述符：</span><br><span class="line"></span><br><span class="line">      - **value**：`&#x27;xxx&#x27;` 属性值。默认~(空)</span><br><span class="line"></span><br><span class="line">      - **writable**：`true` 是否可写。默认`false`</span><br><span class="line"></span><br><span class="line">      - **configurable**：`true` 是否可配置。默认`false`</span><br><span class="line"></span><br><span class="line">      - **enumerable**：`true` 是否可枚举。默认`false`</span><br><span class="line"></span><br><span class="line">      - ```js</span><br><span class="line">        let obj = &#123;</span><br><span class="line">            name: &#x27;cst&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //value,对象中的值</span><br><span class="line">        console.log(obj.name);</span><br><span class="line">        //writable true(可写)</span><br><span class="line">        obj.name = &#x27;yz&#x27;</span><br><span class="line">        //configurable true,delete对象(可配置)</span><br><span class="line">        delete obj.name</span><br><span class="line">        //enumerable true,枚举(可枚举)</span><br><span class="line">        for(var prop in obj) &#123;</span><br><span class="line">            console.log(prop);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //writable false(不可写)</span><br><span class="line">        Function.prototype</span><br><span class="line">        //configurable false(不可配置)</span><br><span class="line">        var a = 10; window.a;//window全局变量不可被删</span><br><span class="line">        //enumerable false(不可枚举)</span><br><span class="line">        Object.prototype</span><br></pre></td></tr></table></figure>

<ul>
<li><p>存取描述符</p>
<ul>
<li><p><strong>set</strong>：<code>function()&#123;&#125;</code> 属性访问器 进行写操作时调用该方法</p>
<ul>
<li>```js<br>var obj = {<pre><code>tempValue: &#39;duyi&#39;,
//set更改时需要传入value，进行更改
set name(value) &#123;
   this.tempValue = value;
    //将原属性更改为value
&#125;
</code></pre>
}<br>obj.name = 10;//传入value<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **get**：`function()&#123;&#125;` 属性访问器 进行读操作时调用该方法</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        tempValue: &#x27;duyi&#x27;,</span><br><span class="line">        get name() &#123;</span><br><span class="line">            return this.tempValue;</span><br><span class="line">            //get取出的是方法返回的值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>如果描述中同时出现<code>value</code>、<code>writable</code>和<code>set</code>、<code>get</code>两组的话，会出现异常，切记不要同时使用</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>双向数据绑定的核心方法，主要做数据劫持操作（监控属性变化），同时是后期<code>ES6</code>中很多语法糖底层实现的核心方法</li>
</ul>
</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>```js<br>var obj = {};var tempValue = ‘’;Object.defineProperty(obj,’name’,{<pre><code>//value: &#39;cst&#39;, //value
//writable: false, //不可写
configurable: true, //可配置
enumerable: true, //可枚举
//有get和set就不能有value和writable，二者取其一
get: function() &#123;
    return tempValue;
&#125;,
set: function(value) &#123;
    tempValue = value;
&#125;
</code></pre>
});obj.name = 10;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 数据劫持</span><br><span class="line"></span><br><span class="line">- `VUE`双向数据绑定核心功能由 `Observer`、`Compile`、`Watcher`三部分实现，其中`Observer`部分功能实现有`Object.defineProperty`实现</span><br><span class="line"></span><br><span class="line">  - `Observer`:检测数据变化进行相应回调（数据劫持）</span><br><span class="line">  - 实现一个简单的数据劫持，作为`Object.defineProperty`的练习。从而引出`Proxy`&amp;`Reflect`</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;show&quot;&gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  var oDiv = document.getElementById(&#x27;show&#x27;),</span><br><span class="line">      oInput = document.getElementById(&#x27;demo&#x27;);</span><br><span class="line">  </span><br><span class="line">  var oData = &#123;</span><br><span class="line">      valueObj: &#123;</span><br><span class="line">          value:&#x27;cc&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      value: &#x27;duyi&#x27;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  oInput.oninput = function() &#123;</span><br><span class="line">      oData.value = this.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //更新显示函数</span><br><span class="line">  function upDate() &#123;</span><br><span class="line">      oDiv.innerText = oData.value;</span><br><span class="line">      // oDiv.innerText = oData.valueObj.value; //监控对象中的对象</span><br><span class="line">  &#125;</span><br><span class="line">  upDate();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //监控对象的某个属性是否发生改变</span><br><span class="line">  function Observer(data) &#123;</span><br><span class="line">      //判断是否是对象</span><br><span class="line">      if(!data || typeof data != &#x27;object&#x27;) &#123;</span><br><span class="line">          return data;</span><br><span class="line">      &#125;;</span><br><span class="line">      //循环判断</span><br><span class="line">      // for(var prop in data) &#123;&#125;</span><br><span class="line">      //Object.keys(data)，可以将对象中的每个属性都放到数组中</span><br><span class="line">      Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">          defineRective(data,key,data[key]);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //监控函数</span><br><span class="line">  function defineRective(data,key,val) &#123;</span><br><span class="line">      //AO</span><br><span class="line">      Observer(val);</span><br><span class="line">      Object.defineProperty(data,key,&#123;</span><br><span class="line">          get () &#123;</span><br><span class="line">              return val;</span><br><span class="line">          &#125;,</span><br><span class="line">          set (newValue) &#123;</span><br><span class="line">              if(newValue == val) return;</span><br><span class="line">              val = newValue;</span><br><span class="line">              upDate();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Observer(oData);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="proxy-amp-reflect"><a href="#proxy-amp-reflect" class="headerlink" title="proxy &amp; reflect"></a>proxy &amp; reflect</h3><ul>
<li><p>简介</p>
<ul>
<li>植入代理模式的思想，以简洁易懂的方式控制对外部对象的访问</li>
<li><strong>new Proxy</strong>(对象,描述符);</li>
<li><strong>Proxy</strong>是一个构造函数，需要用变量接受</li>
</ul>
</li>
<li><p>描述符对象的属性的进行详细描述：</p>
<ul>
<li>数据描述符：<ul>
<li><strong>value</strong>：<code>&#39;xxx&#39;</code> 属性值。默认~(空)</li>
<li><strong>writable</strong>：<code>true</code> 是否可写。默认<code>false</code></li>
<li><strong>configurable</strong>：<code>true</code> 是否可配置。默认<code>false</code></li>
<li><strong>enumerable</strong>：<code>true</code> 是否可枚举。默认<code>false</code></li>
</ul>
</li>
<li>存取描述符<ul>
<li><strong>set</strong>：<code>function(target,key,value,receiver)&#123;&#125;</code> 属性访问器 进行写操作时调用该方法<ul>
<li><code>target</code>：对象</li>
<li><code>key</code>：属性</li>
<li><code>value</code>：传入的值</li>
<li><code>receiver</code>：代理函数</li>
</ul>
</li>
<li><strong>get</strong>：<code>function(target,key,receiver)&#123;&#125;</code> 属性访问器 进行读操作时调用该方法<ul>
<li><code>target</code>：对象</li>
<li><code>key</code>：属性</li>
<li><code>receiver</code>：代理函数</li>
</ul>
</li>
<li><strong>has</strong>:<code>function(target,key)&#123;&#125;</code><ul>
<li><code>target</code>：对象</li>
<li><code>key</code>：属性</li>
<li><code>has</code>对应<code>in</code>操作符，返回<code>true</code>/<code>false</code>，通常用来隐藏自己的私密属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>利用内置的<code>set</code>、<code>get</code>方法控制属性的读写功能用处比较大，其余<code>has</code>、<code>deleProperty</code>…等方法不太在工作开发中使用，但是兼容性不太好</li>
</ul>
</li>
<li><p>```js<br>//初始对象<br>let oData = {</p>
<pre><code>val: &#39;duyi&#39;,
_val: &#39;zzz&#39;
</code></pre>
<p>}</p>
<p>//代理函数,oProxyData<br>let oProxyData = new Proxy(oData,{</p>
<pre><code>//进行参数读写控制
set (target,key,value,receiver) &#123;
    //传入参数
    Reflect.set(target.key,value);
    upData();
&#125;,
get (target,key,value,receiver) &#123;
    //获取对象并获取其中的属性值
    Reflect.get(target,key);
&#125;,
has (target,key) &#123;
    //判断属性是否有_，如果有则为false，否则key in oData
    return key.indexOf(&#39;_&#39;) != -1 ? false : key in oData;
&#125;
</code></pre>
<p>})</p>
<p>//读写 控制<br>console.log(‘_val’ in oProxy);<br>//读<br>console.log(oProxy.val);<br>//写<br>oProxy.val = 10;</p>
<p>function upData() {</p>
<pre><code>console.log(&#39;更新了&#39;);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 面向对象简介</span><br><span class="line"></span><br><span class="line">- 面向对象：一种编程思想，跟具体的语言</span><br><span class="line"></span><br><span class="line">- 对比面向过程：</span><br><span class="line"></span><br><span class="line">  - 面向过程：思考的切入点是功能的步骤</span><br><span class="line">  - 面向对象：思考的切入点是对象的划分</span><br><span class="line"></span><br><span class="line">  - 面向过程目的在于把功能拆分成步骤，一环扣一环的完成，但是需求复杂到一定程度后，对开发者能力的挑战也是越来越强</span><br><span class="line">  - 面向对象目的在于前期把功能拆分并抽象成不同的对象，聚焦于每个对象的能力和他们之间的配合，项目复杂后相对于面向过程来讲较为轻松一些</span><br><span class="line">  - 举个例子：【大象装冰箱】</span><br><span class="line">  - 面向对象的编程语言需要具备封装、继承、多态，`js`不是面向对象的语言，而是基于对象的语言，`js`中基本上一切皆是对象</span><br><span class="line">  - 前端变成需要面向对象的思想</span><br><span class="line">    - 相对于复杂业务为了做到功能复用，降低项目开发的复杂度，需要这种思想，比如，前端校验和写一个校验器，而不是面向过程每次需要验证都一条线的下来编写</span><br><span class="line">    - 目前前端主流框架`vue`、`react`都是采用面向对象的方式来做，以及进入公司进行高级开发，组件研发，制作功能模块，也需要采取这样的思想做事</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  /**</span><br><span class="line">   * 大象</span><br><span class="line">   */</span><br><span class="line">  function Elephant() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 冰箱</span><br><span class="line">   */</span><br><span class="line">  function Frige() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Frige.prototype.openDoor = function () &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Frige.prototype.closeDoor = function () &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Frige.prototype.join = function(something)&#123;</span><br><span class="line">      this.openDoor();</span><br><span class="line">      //装东西</span><br><span class="line">  </span><br><span class="line">      this.closeDoor();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //1. 冰箱门打开</span><br><span class="line">  // var frig = new Frige();</span><br><span class="line">  // frig.openDoor();</span><br><span class="line">  </span><br><span class="line">  // //2. 大象装进去</span><br><span class="line">  // var ele = new Elephant();</span><br><span class="line">  // frig.join(ele);</span><br><span class="line">  </span><br><span class="line">  // //3. 冰箱门关上</span><br><span class="line">  // frig.closeDoor();</span><br><span class="line">  </span><br><span class="line">  var frig = new Frige();</span><br><span class="line">  </span><br><span class="line">  frig.join(new Elephant());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类-Class"><a href="#类-Class" class="headerlink" title="类-Class"></a>类-Class</h3><h4 id="类：构造函数的语法糖"><a href="#类：构造函数的语法糖" class="headerlink" title="类：构造函数的语法糖"></a>类：构造函数的语法糖</h4><ul>
<li><p>传统的构造函数的问题</p>
<ul>
<li>属性和原型方法定义分离，降低了可读性</li>
<li>原型成员可以被枚举</li>
<li>默认情况下，构造函数仍然可以被当作普通函数使用</li>
</ul>
</li>
<li><p>类的特点</p>
<ul>
<li>类声明不会被提升，与 <code>let</code> 和 <code>const</code> 一样，存在暂时性死区</li>
<li>类中的所有代码均在严格模式下执行</li>
<li>类的所有方法都是不可枚举的</li>
<li>类的所有方法都无法被当作构造函数使用</li>
<li>类的构造器必须使用 <code>new</code> 来调用</li>
</ul>
</li>
<li><p>```js<br>// 类 class<br>// 不可以 var、let，它是一个语法糖，本质还是function<br>class Animal {</p>
<pre><code>// 私有属性 cunstructor
constructor(type, name, age, sex) &#123;
    this.type = type;
    this.name = name;
    this.age = age;
    this.sex = sex;
&#125;

// 公有属性（相当于给原型添加属性）
print() &#123;
    console.log(`【种类】：$&#123;this.type&#125;`);
    console.log(`【名字】：$&#123;this.name&#125;`);
    console.log(`【年龄】：$&#123;this.age&#125;`);
    console.log(`【性别】：$&#123;this.sex&#125;`);
&#125;
</code></pre>
<p>}</p>
<p>const a = new Animal(“狗”, “旺财”, 3, “男”);<br>a.print();</p>
<p>for (const prop in a) {</p>
<pre><code>console.log(prop)
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 类的其他书写方式</span><br><span class="line"></span><br><span class="line">- 可计算的成员名</span><br><span class="line">- **getter**和**setter**</span><br><span class="line">  - **Object.defineProperty** 可定义某个对象成员属性的读取和设置</span><br><span class="line">  - 使用`getter`和`setter`控制的属性，不在原型上</span><br><span class="line">- 静态成员</span><br><span class="line">  - 构造函数本身的成员</span><br><span class="line">  - 使用`static`关键字定义的成员即静态成员</span><br><span class="line">- 字段初始化器（**ES7**）</span><br><span class="line">  - 注意：</span><br><span class="line">  - 使用`static`的字段初始化器，添加的是静态成员</span><br><span class="line">  - 没有使用`static`的字段初始化器，添加的成员位于对象上</span><br><span class="line">  - 箭头函数在字段初始化器位置上，指向当前对象</span><br><span class="line">- 类表达式</span><br><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    // getter setter</span><br><span class="line">    </span><br><span class="line">    const printName = &quot;print&quot;;</span><br><span class="line">    </span><br><span class="line">    class Animal &#123;</span><br><span class="line">        constructor(type, name, age, sex) &#123;</span><br><span class="line">            this.type = type;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">            this.sex = sex;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        //创建一个age属性，并给它加上getter，读取该属性时，会运行该函数</span><br><span class="line">        get age() &#123;</span><br><span class="line">            return this._age + &quot;岁&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        //创建一个age属性，并给它加上setter，给该属性赋值时，会运行该函数</span><br><span class="line">        set age(age) &#123;</span><br><span class="line">            if (typeof age !== &quot;number&quot;) &#123;</span><br><span class="line">                throw new TypeError(&quot;age property must be a number&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (age &lt; 0) &#123;</span><br><span class="line">                age = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (age &gt; 1000) &#123;</span><br><span class="line">                age = 1000;</span><br><span class="line">            &#125;</span><br><span class="line">            this._age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        [printName]() &#123;</span><br><span class="line">            console.log(`【种类】：$&#123;this.type&#125;`);</span><br><span class="line">            console.log(`【名字】：$&#123;this.name&#125;`);</span><br><span class="line">            console.log(`【年龄】：$&#123;this.age&#125;`);</span><br><span class="line">            console.log(`【性别】：$&#123;this.sex&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var a = new Animal(&quot;狗&quot;, &quot;旺财&quot;, 3, &quot;男&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>```js<br>// static 静态属性class Chess {<pre><code>constructor(name) &#123;
    this.name = name;
&#125;
// static 静态属性
static width = 50;
static height = 50;
static method() &#123;

&#125;
</code></pre>
}console.log(Chess.width)<br>console.log(Chess.height)Chess.method();<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  // 类表达式</span><br><span class="line">  </span><br><span class="line">  const A = class &#123; //匿名类，类表达式</span><br><span class="line">      a = 1;</span><br><span class="line">      b = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const a = new A();</span><br><span class="line">  console.log(a)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><ul>
<li><p>如果两个类<code>A</code>和<code>B</code>，如果可以描述为：<code>B</code> 是 <code>A</code>，则，<code>A</code>和<code>B</code>形成继承关系</p>
</li>
<li><p>如果<code>B</code>是<code>A</code>，则：</p>
<ul>
<li><code>B</code>继承自A</li>
<li><code>A</code>派生<code>B</code></li>
<li><code>B</code>是<code>A</code>的子类</li>
<li><code>A</code>是<code>B</code>的父类</li>
</ul>
</li>
<li><p>如果<code>A</code>是<code>B</code>的父类，则<code>B</code>会自动拥有<code>A</code>中的所有实例成员。</p>
</li>
<li><p>新的关键字：</p>
<ul>
<li><strong>extends</strong>：继承，用于类的定义</li>
<li><strong>super</strong><ul>
<li>直接当作函数调用，表示父类构造函数</li>
<li>如果当作对象使用，则表示父类的原型</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：<code>ES6</code>要求，如果定义了<code>constructor</code>，并且该类是子类，则必须在<code>constructor</code>的第一行手动调用父类的构造函数</p>
</li>
<li><p>如果子类不写<code>constructor</code>，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器</p>
</li>
<li><p>【冷知识】</p>
<ul>
<li>用<code>JS</code>制作抽象类<ul>
<li>抽象类：一般是父类，不能通过该类创建对象</li>
</ul>
</li>
<li>正常情况下，<code>this</code>的指向，<code>this</code>始终指向具体的类的对象</li>
</ul>
</li>
<li><p>```js<br>// ES5构造函数<br>function Animal(type, name, age, sex) {</p>
<pre><code>this.type = type;
this.name = name;
this.age = age;
this.sex = sex;
</code></pre>
<p>}<br>Animal.prototype.print = function () {</p>
<pre><code>console.log(`【种类】：$&#123;this.type&#125;`);
console.log(`【名字】：$&#123;this.name&#125;`);
console.log(`【年龄】：$&#123;this.age&#125;`);
console.log(`【性别】：$&#123;this.sex&#125;`);
</code></pre>
<p>}</p>
<p>function Dog(name, age, sex) {</p>
<pre><code>//借用父类的构造函数
Animal.call(this, &quot;犬类&quot;, name, age, sex);
</code></pre>
<p>}</p>
<p>Object.setPrototypeOf(Dog.prototype, Animal.prototype);</p>
<p>const d = new Dog(“旺财”, 3, “公”);<br>d.print();<br>console.log(d);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  // ES6 class</span><br><span class="line">  class Animal &#123;</span><br><span class="line">      constructor(type, name, age, sex) &#123;</span><br><span class="line">          if (new.target === Animal) &#123;</span><br><span class="line">              throw new TypeError(&quot;你不能直接创建Animal的对象，应该通过子类创建&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">          this.type = type;</span><br><span class="line">          this.name = name;</span><br><span class="line">          this.age = age;</span><br><span class="line">          this.sex = sex;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      print() &#123;</span><br><span class="line">          console.log(`【种类】：$&#123;this.type&#125;`);</span><br><span class="line">          console.log(`【名字】：$&#123;this.name&#125;`);</span><br><span class="line">          console.log(`【年龄】：$&#123;this.age&#125;`);</span><br><span class="line">          console.log(`【性别】：$&#123;this.sex&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      jiao() &#123;</span><br><span class="line">          throw new Error(&quot;动物怎么叫的？&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 类Dog的prototype继承类Animal的prototype </span><br><span class="line">  class Dog extends Animal &#123;</span><br><span class="line">      constructor(name, age, sex) &#123;</span><br><span class="line">          // 调用父类的私有属性</span><br><span class="line">          super(&quot;犬类&quot;, name, age, sex);</span><br><span class="line">          // 子类特有的属性</span><br><span class="line">          this.loves = &quot;吃骨头&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      print() &#123;</span><br><span class="line">          // 调用父类的print</span><br><span class="line">          super.print();</span><br><span class="line">          // 自己特有的代码</span><br><span class="line">          console.log(`【爱好】：$&#123;this.loves&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      //同名方法，会覆盖父类</span><br><span class="line">      jiao() &#123;</span><br><span class="line">          console.log(&quot;旺旺！&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //下面的代码逻辑有误</span><br><span class="line">  const a = new Dog(&quot;旺财&quot;, 3, &quot;公&quot;)</span><br><span class="line">  a.print();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator(装饰器)"></a>Decorator(装饰器)</h4><ul>
<li>```js<br>class Test {<pre><code>@Obsolete
print() &#123;
    console.log(&quot;print方法&quot;)
&#125;
</code></pre>
}function Obsolete(target, methodName, descriptor) {<pre><code>// function Test
// print
// &#123; value: function print()&#123;&#125;, ... &#125;
// console.log(target, methodName, descriptor);
const oldFunc = descriptor.value
descriptor.value = function (...args) &#123;
    console.warn(`$&#123;methodName&#125;方法已过时`);
    oldFunc.apply(this, args);
&#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  //面向对象</span><br><span class="line">  //张三</span><br><span class="line">  let oInput = document.getElementById(&#x27;inp&#x27;),</span><br><span class="line">      oBtn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">  </span><br><span class="line">  @Skin //修饰类</span><br><span class="line">  class Search &#123;</span><br><span class="line">      //静态属性</span><br><span class="line">          //ES6规范 static num() &#123;return 10;&#125;</span><br><span class="line">          //ES7规范 static num = 10;</span><br><span class="line">      //私有属性</span><br><span class="line">      constructor() &#123;</span><br><span class="line">          this.keyValue = &#x27;&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">      //装饰器</span><br><span class="line">      // @名称</span><br><span class="line">      @myReadOnly //修饰url属性，给url加了装饰器</span><br><span class="line">      //私有属性</span><br><span class="line">      url = &#x27;urlA-&#x27;;</span><br><span class="line">      </span><br><span class="line">      @dealData(&#x27;张三&#x27;) //修饰原型属性，给getContent加了装饰器</span><br><span class="line">      //原型属性</span><br><span class="line">      getContent (a, b) &#123;</span><br><span class="line">          console.log(&#x27;向&#x27; + this.url + &#x27;发送网络请求，数据：&#x27; + this.keyValue,a,b);</span><br><span class="line">          return 10;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //target：类本身</span><br><span class="line">  function Skin(target) &#123;</span><br><span class="line">      target.aa = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let oS = new Search();</span><br><span class="line">  </span><br><span class="line">  oInput.oninput = function () &#123;</span><br><span class="line">      oS.keyValue = this.value;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  oBtn.onclick = function () &#123;</span><br><span class="line">      oS.getContent();</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //李四</span><br><span class="line">  //装饰器</span><br><span class="line">  //修饰私有属性的描述符属性</span><br><span class="line">      //configurable</span><br><span class="line">       //enumerable</span><br><span class="line">       //initializer</span><br><span class="line">       //writable</span><br><span class="line">  //装饰原型上的属性的描述符属性</span><br><span class="line">      //configurable</span><br><span class="line">      //enumerable</span><br><span class="line">      //initializer</span><br><span class="line">      //writable</span><br><span class="line">  </span><br><span class="line">  //装饰私有属性</span><br><span class="line">  //参数：原型 修饰属性名称 描述符属性</span><br><span class="line">  function myReadOnly(proto,key,descriptor) &#123;</span><br><span class="line">      //</span><br><span class="line">      // console.log(proto,key,descriptor);</span><br><span class="line">      //可不可写</span><br><span class="line">      descriptor.writable = false;</span><br><span class="line">      //initializer()的返回值决定了属性url的值</span><br><span class="line">      descriptor.initializer = function() &#123;</span><br><span class="line">          return &quot;urlA-&quot;;</span><br><span class="line">      &#125;;</span><br><span class="line">       //描述符属性：</span><br><span class="line">       //configurable</span><br><span class="line">       //enumerable</span><br><span class="line">       //initializer</span><br><span class="line">       //writable</span><br><span class="line">  &#125;</span><br><span class="line">  //修饰原型属性</span><br><span class="line">  function dealData (ms) &#123;</span><br><span class="line">      return function (proto,key,descriptor) &#123;</span><br><span class="line">          // console.log(proto,key,descriptor);</span><br><span class="line">          let oldValue = descriptor.value;</span><br><span class="line">          //代理思想</span><br><span class="line">          descriptor.value = function() &#123;</span><br><span class="line">      </span><br><span class="line">              var urlB = &#x27;urlB-&#x27;;</span><br><span class="line">              console.log(&quot;向&quot; + urlB + &quot;发送网络请求，数据：&quot; + this.keyValue + &quot; 发送人 &quot; + ms);</span><br><span class="line">      </span><br><span class="line">              //先把本来的getContent函数执行一遍，将arguments传给this（oS对象）</span><br><span class="line">              return oldValue.apply(this,arguments);</span><br><span class="line">          &#125;</span><br><span class="line">          //原型描述符属性：</span><br><span class="line">           //configurable</span><br><span class="line">           //enumerable</span><br><span class="line">           //value</span><br><span class="line">           //writable</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // //面向过程</span><br><span class="line">  // // 张三</span><br><span class="line">  // var keyValue = &#x27;&#x27;;</span><br><span class="line">  // oInput.oninput = function () &#123;</span><br><span class="line">  //     keyValue = this.value</span><br><span class="line">  // &#125;</span><br><span class="line">  // oBtn.onclick = function () &#123;</span><br><span class="line">  //     newGetContent(keyValue)</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line">  // function getContent (data) &#123;</span><br><span class="line">  //     //模拟发送网络请求</span><br><span class="line">  //     var url = &#x27;urlA-&#x27;;</span><br><span class="line">  //     console.log(&#x27;向&#x27; + url + &#x27;发送网络请求，数据：&#x27; + data);</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line">  // //代理</span><br><span class="line">  // var newGetContent = dealFunc(getContent);</span><br><span class="line">  </span><br><span class="line">  // //李四</span><br><span class="line">  // function dealFunc(func) &#123;</span><br><span class="line">  //     return function(data) &#123;</span><br><span class="line">  //         //</span><br><span class="line">  //         var urlB = &#x27;urlB-&#x27;;</span><br><span class="line">  //         console.log(&#x27;向&#x27; + urlB + &#x27;发送网络请求，数据：&#x27; + data)</span><br><span class="line">  //         return func.apply(this,arguments);</span><br><span class="line">  //     &#125;</span><br><span class="line">  // &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ES7之Class提案属性"><a href="#ES7之Class提案属性" class="headerlink" title="ES7之Class提案属性"></a>ES7之Class提案属性</h4><ul>
<li><p>新特性</p>
<ul>
<li><strong>static property = xxx</strong>：静态属性</li>
<li><strong>property = xxx</strong>：私有属性</li>
<li><strong>@decorator</strong>：装饰器</li>
</ul>
</li>
<li><p>提案特性需要下载</p>
<ul>
<li><code>npm install @babel/plugin-proposal-decorators</code></li>
</ul>
</li>
<li><p>需要配置</p>
<ul>
<li>```js<br>{<pre><code>&quot;plugin&quot;: [
    [&quot;@babel/plugin-proposal-decorators&quot;,&#123;&quot;legacy&quot;:true&#125;]
    [&quot;@babel/plugin-proposal-class-properties&quot;,&#123;&quot;loose&quot;:true&#125;]
]
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    class Search &#123;</span><br><span class="line">        //静态属性</span><br><span class="line">        //ES6规范</span><br><span class="line">            // static num() &#123;</span><br><span class="line">            //     return 10;</span><br><span class="line">            // &#125;</span><br><span class="line">        //ES7规范</span><br><span class="line">        static num = 10;</span><br><span class="line">    </span><br><span class="line">        //私有属性</span><br><span class="line">        constructor () &#123;</span><br><span class="line">            //私有属性</span><br><span class="line">            this.keyValue = &#x27;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        //装饰器</span><br><span class="line">        // @readOnly</span><br><span class="line">        //私有属性</span><br><span class="line">        url = &#x27;urlA-&#x27;;</span><br><span class="line">        //原型属性</span><br><span class="line">        getCount () &#123;</span><br><span class="line">            console.log(&#x27;发送请求&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var oS = new Search();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="手写Class"><a href="#手写Class" class="headerlink" title="手写Class"></a>手写Class</h4><h5 id="ES6之模拟class"><a href="#ES6之模拟class" class="headerlink" title="ES6之模拟class"></a>ES6之模拟class</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class 关键字，不可以var、let，它是一个语法糖，本质还是function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用class类，相当于Es5的构造函数，不用写function</span></span><br><span class="line"><span class="comment">//私有属性constructor</span></span><br><span class="line"><span class="comment">//公有属性(原型属性) </span></span><br><span class="line"><span class="comment">//静态属性(函数本身属性)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态属性,ES6不支持非方法的静态属性，ES7支持</span></span><br><span class="line">    <span class="comment">//静态属性在Plane中定义时，它就成为了Plane本身的方法</span></span><br><span class="line">    <span class="keyword">static</span> alive () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name || <span class="string">&#x27;普通飞机&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果想给原型添加方法，则在constructor的同级下添加函数</span></span><br><span class="line">    fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fly&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ES7 私有属性</span></span><br><span class="line">    <span class="comment">// name = 10;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//target extend origin：target的prototype继承Plane的prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttackPlane</span> <span class="keyword">extends</span> <span class="title">Plane</span></span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="comment">// Plane.call(this,name);</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="comment">//super就相当于把Plane的私有属性call了一下，将私有属性全部call到了constructor中</span></span><br><span class="line">        <span class="built_in">this</span>.logo = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有属性</span></span><br><span class="line">    dan () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;biubiubiu&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oAp = <span class="keyword">new</span> AttackPlane(<span class="string">&#x27;战斗机&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.must be new</span></span><br><span class="line"><span class="comment">// 2.class Plane.prototype 不能枚举</span></span><br><span class="line"><span class="comment">// 3.静态属性要放到Plane函数上，非原型</span></span><br></pre></td></tr></table></figure>

<h5 id="ES5模拟之Class"><a href="#ES5模拟之Class" class="headerlink" title="ES5模拟之Class"></a>ES5模拟之Class</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否以new的方式构造出来的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">_this,_constructor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断_this沿着原型链寻找，是否可以找到_this,如果不能则抛出错误，instanceof 运算符用来检测 constructor.prototype 是否存在于参数 _this 的原型链上。</span></span><br><span class="line">    <span class="keyword">if</span> (!(_this <span class="keyword">instanceof</span> _constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;TypeError: Class constructor Plane cannot be invoked without &#x27;new&#x27;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置公有属性和静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target,props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Object.defineProperty</span></span><br><span class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//ele.key ele.value</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target,ele.key,&#123; </span><br><span class="line">            <span class="attr">value</span>: ele.value,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">//可写</span></span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span><span class="comment">//可配置</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理公有属性和静态属性</span></span><br><span class="line"><span class="comment">//参数：原型、原型属性，静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span> (<span class="params">_constructor,_prototypeProperties,_staticProperties</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//如果传_prototypeProperties数组的话，给原型上赋值</span></span><br><span class="line">    <span class="keyword">if</span> (_prototypeProperties) &#123;</span><br><span class="line">        _defineProperties(_constructor.prototype, _prototypeProperties)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果传_staticProperties数组的话，给函数本身上赋值</span></span><br><span class="line">    <span class="keyword">if</span> (_staticProperties) &#123;</span><br><span class="line">        _defineProperties(_constructor,_staticProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Plane = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Plane</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否以new的方式来执行</span></span><br><span class="line">        _classCallCheck(<span class="built_in">this</span>,Plane);</span><br><span class="line">        <span class="comment">//把私有属性 公有属性 静态属性赋给Plane</span></span><br><span class="line">        <span class="built_in">this</span>.name = name || <span class="string">&quot;普通飞机&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建自身属性和静态属性</span></span><br><span class="line">    _createClass(Plane,[</span><br><span class="line">        <span class="comment">//自身方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;fly&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;fly&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ],[</span><br><span class="line">        <span class="comment">//静态属性</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;alive&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Plane;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oP = <span class="keyword">new</span> Plane(<span class="string">&quot;yzl&amp;战斗机&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型继承方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherit</span>(<span class="params">sub,sup</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(sub.prototype,sup.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AttackPlane = (<span class="function"><span class="keyword">function</span>(<span class="params">Plane</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    _inherit(AttackPlane,Plane);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">AttackPlane</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="built_in">this</span>,Plane);</span><br><span class="line">        <span class="built_in">this</span>.logo = <span class="string">&#x27;lll&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> that = Plane.call(<span class="built_in">this</span>,name);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> that == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            _this.that;</span><br><span class="line">        &#125;</span><br><span class="line">        _this.logo = <span class="string">&#x27;duyi&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//创建自身属性和静态属性</span></span><br><span class="line">    _createClass(AttackPlane,[</span><br><span class="line">        <span class="comment">//自身方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;dan&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;biubiubiu&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ],[</span><br><span class="line">        <span class="comment">//静态属性</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;alive&#x27;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> AttackPlane;</span><br><span class="line">&#125;(Plane))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oAp = <span class="keyword">new</span> AttackPlane();</span><br></pre></td></tr></table></figure>

<h2 id="解构-destructuring"><a href="#解构-destructuring" class="headerlink" title="解构(destructuring)"></a>解构(destructuring)</h2><ul>
<li><p>什么是解构</p>
<ul>
<li><p>使用<code>ES6</code>的一种语法规则，将一个对象或数组的某个属性提取到某个变量中</p>
</li>
<li><p><strong>解构不会对被解构的目标造成任何影响</strong></p>
</li>
<li><p>解构过程中，具备赋值和变量声明两个功能</p>
</li>
<li><p>目的在于把等号左右长得相似的两个东西内部的值取出来</p>
</li>
<li><p>对象数组都可以参与解构</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>在解构中使用默认值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;同名变量 = 默认值&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非同名属性解构</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;属性名:变量名&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><ul>
<li><p>```js<br>const user = {</p>
<pre><code>name: &quot;kevin&quot;,
age: 11,
sex: &quot;男&quot;,
address: &#123;
    province: &quot;四川&quot;,
    city: &quot;成都&quot;
&#125;
</code></pre>
<p>}</p>
<p>// let name, age, sex, address;<br>// name = user.name;<br>// age = user.age;<br>// sex = user.sex;<br>// address = user.address;</p>
<p>// let name, age, sex, address, abc;<br>// ({ name, age, sex, address } = user);</p>
<p>// 先定义5个变量，然后从对象中读取同名属性，放到变量中<br>let { name, age, sex, address, abc = 123 } = user</p>
<p>console.log(name, age, sex, address, abc)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const user = &#123;</span><br><span class="line">      name: &quot;kevin&quot;,</span><br><span class="line">      age: 11,</span><br><span class="line">      sex: &quot;男&quot;,</span><br><span class="line">      address: &#123;</span><br><span class="line">          province: &quot;四川&quot;,</span><br><span class="line">          city: &quot;成都&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 先定义4个变量：name、age、gender、address</span><br><span class="line">  // 再从对象user中读取同名属性赋值（其中gender读取的是sex属性）</span><br><span class="line">  let &#123; name, age, sex: gender = 123, address &#125; = user</span><br><span class="line">  </span><br><span class="line">  console.log(name, age, gender, address)</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const user = {</p>
<pre><code>name: &quot;kevin&quot;,
age: 11,
sex: &quot;男&quot;,
address: &#123;
    province: &quot;四川&quot;,
    city: &quot;成都&quot;
&#125;
</code></pre>
<p>}<br>//解构出user中的name、province<br>//定义两个变量name、province<br>//再解构<br>const { name, address: { province } } = user;</p>
<p>console.log(name, address, province)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 数组解构</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const numbers = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];</span><br><span class="line">  </span><br><span class="line">  // const &#123;</span><br><span class="line">  //     0: n1,</span><br><span class="line">  //     1: n2</span><br><span class="line">  // &#125; = numbers;</span><br><span class="line">  </span><br><span class="line">  // let n1, n2;</span><br><span class="line">  // ([n1, n2] = numbers);</span><br><span class="line">  </span><br><span class="line">  // 只获得数组前两位</span><br><span class="line">  const [n1, n2] = numbers;</span><br><span class="line">  </span><br><span class="line">  console.log(n1, n2) // a b</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const numbers = [“a”, “b”, “c”, “d”];</p>
<p>const [n1, , , n4, n5 = 123] = numbers;</p>
<p>console.log(n1, n4, n5) // a d 123</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  // const numbers = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, [1, 2, 3, 4]];</span><br><span class="line">  </span><br><span class="line">  // // 得到numbers下标为4的数组中的下标为2的数据，放到变量n中</span><br><span class="line">  // const [, , , , [, , n]] = numbers;</span><br><span class="line">  </span><br><span class="line">  // console.log(n)</span><br><span class="line">  </span><br><span class="line">  const numbers = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: 2</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  //得到numbers下标为4的数组的属性a，赋值给变量A</span><br><span class="line">  // const [, , , , &#123; a: A &#125;] = numbers;</span><br><span class="line">  </span><br><span class="line">  const &#123; a: A &#125; = numbers[4];</span><br><span class="line">  </span><br><span class="line">  console.log(A)</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const user = {</p>
<pre><code>name: &quot;kevin&quot;,
age: 11,
sex: &quot;男&quot;,
address: &#123;
    province: &quot;四川&quot;,
    city: &quot;成都&quot;
&#125;
</code></pre>
<p>}</p>
<p>//解构出name，然后，剩余的所有属性，放到一个新的对象中，变量名为obj<br>// name: kevin<br>// obj : {age:11, sex:”男”, address:{…}}</p>
<p>const { name, …obj } = user;</p>
<p>console.log(name, obj)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const numbers = [324, 7, 23, 5, 3243];</span><br><span class="line">  </span><br><span class="line">  // 得到数组前两项，分别放到变量a和b中，然后剩余的所有数据放到数组nums</span><br><span class="line">  </span><br><span class="line">  // const [a, b, ...nums] = numbers;</span><br><span class="line">  </span><br><span class="line">  const a = numbers[0], b = numbers[1], nums = numbers.slice(2);</span><br><span class="line">  </span><br><span class="line">  console.log(a, b, nums);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参数结构"><a href="#参数结构" class="headerlink" title="参数结构"></a>参数结构</h3><ul>
<li>```js<br>// function ajax(options) {<br>//     const defaultOptions = {<br>//         method: “get”,<br>//         url: “/“<br>//     }<br>//     const opt = {<br>//         …defaultOptions,<br>//         …options<br>//     }<br>//     console.log(opt)<br>// }function ajax({<pre><code>method = &quot;get&quot;,
url = &quot;/&quot;
</code></pre>
} = {}) {<pre><code>console.log(method, url)
</code></pre>
}ajax()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  // function print(user) &#123;</span><br><span class="line">  //     console.log(`姓名：$&#123;user.name&#125;`)</span><br><span class="line">  //     console.log(`年龄：$&#123;user.age&#125;`)</span><br><span class="line">  //     console.log(`性别：$&#123;user.sex&#125;`)</span><br><span class="line">  //     console.log(`身份：$&#123;user.address.province&#125;`)</span><br><span class="line">  //     console.log(`城市：$&#123;user.address.city&#125;`)</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line">  function print(&#123; name, age, sex, address: &#123;</span><br><span class="line">      province,</span><br><span class="line">      city</span><br><span class="line">  &#125; &#125;) &#123;</span><br><span class="line">      console.log(`姓名：$&#123;name&#125;`)</span><br><span class="line">      console.log(`年龄：$&#123;age&#125;`)</span><br><span class="line">      console.log(`性别：$&#123;sex&#125;`)</span><br><span class="line">      console.log(`身份：$&#123;province&#125;`)</span><br><span class="line">      console.log(`城市：$&#123;city&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const user = &#123;</span><br><span class="line">      name: &quot;kevin&quot;,</span><br><span class="line">      age: 11,</span><br><span class="line">      sex: &quot;男&quot;,</span><br><span class="line">      address: &#123;</span><br><span class="line">          province: &quot;四川&quot;,</span><br><span class="line">          city: &quot;成都&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  print(user)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h3><ul>
<li><p>符号是<code>ES6</code>新增的一个数据类型，它通过使用函数 <code>Symbol(符号描述)</code> 来创建</p>
</li>
<li><p>符号设计的初衷，是为了给对象设置私有属性</p>
</li>
<li><p>私有属性：只能在对象内部使用，外面无法使用</p>
</li>
<li><p>符号具有以下特点：</p>
</li>
<li><p>没有字面量</p>
<ul>
<li>使用 <code>typeof</code> 得到的类型是 symbol</li>
<li><strong>每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同</strong></li>
<li>符号可以作为对象的属性名存在，这种属性称之为符号属性<ul>
<li>开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问</li>
<li>符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性</li>
<li><code>Object.getOwnPropertyNames</code> 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性</li>
<li><code>ES6</code> 新增 <code>Object.getOwnPropertySymbols</code> 方法，可以读取符号</li>
</ul>
</li>
<li>符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 <code>String</code> 构造函数进行转换即可，<code>console.log</code> 之所以可以输出符号，是它在内部进行了显式转换</li>
</ul>
</li>
<li><p>创建一个符号</p>
<ul>
<li>```js<br>// 创建一个符号<br>const syb1 = Symbol();<br>const syb2 = Symbol(“abc”);<br>console.log(syb1, syb2);<br>// typeof类型<br>console.log(typeof syb1 === “symbol”, typeof syb2 === “symbol”)// 创建一个符号<br>const syb1 = Symbol(“这是随便写的一个符号”);<br>const syb2 = Symbol(“这是随便写的一个符号”);<br>console.log(syb1, syb2);<br>console.log(syb1 === syb2)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  //创建一个符号</span><br><span class="line">  </span><br><span class="line">  const syb1 = Symbol(&quot;这是用于对象的一个属性&quot;);</span><br><span class="line">  </span><br><span class="line">  const obj = &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: 2,</span><br><span class="line">      [syb1]: 3  //符号属性</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  console.log(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li><p>```js<br>// const hero = (function () {<br>//     const getRandom = Symbol();</p>
<p>//     return {<br>//         attack: 30,<br>//         hp: 300,<br>//         defence: 10,<br>//         gongji() { //攻击<br>//             //伤害：攻击力*随机数（0.8~1.1)<br>//             const dmg = this.attack * this[getRandom](0.8, 1.1);<br>//             console.log(dmg);<br>//         },<br>//         [getRandom](min, max) { //根据最小值和最大值产生一个随机数<br>//             return Math.random() * (max - min) + min;<br>//         }<br>//     }<br>// })()</p>
<p>// console.log(hero);</p>
<p>const Hero = (() =&gt; {</p>
<pre><code>const getRandom = Symbol();

return class &#123;
    constructor(attack, hp, defence) &#123;
        this.attack = attack;
        this.hp = hp;
        this.defence = defence;
    &#125;

    gongji() &#123;
        //伤害：攻击力*随机数（0.8~1.1)
        const dmg = this.attack * this[getRandom](0.8, 1.1);
        console.log(dmg);
    &#125;

    [getRandom](min, max) &#123; //根据最小值和最大值产生一个随机数
        return Math.random() * (max - min) + min;
    &#125;
&#125;
</code></pre>
<p>})();</p>
<p>const h = new Hero(3, 6, 3);<br>console.log(h);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const syb = Symbol();</span><br><span class="line">  </span><br><span class="line">  const obj = &#123;</span><br><span class="line">      [syb]: 1,</span><br><span class="line">      a: 2,</span><br><span class="line">      b: 3</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for (const prop in obj) &#123;</span><br><span class="line">      console.log(prop)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  console.log(Object.keys(obj))</span><br><span class="line">  console.log(Object.getOwnPropertyNames(obj))</span><br><span class="line">  //得到的是一个符号属性的数组</span><br><span class="line">  const sybs = Object.getOwnPropertySymbols(obj);</span><br><span class="line">  console.log(sybs, sybs[0] === syb)</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const Hero = (() =&gt; {</p>
<pre><code>const getRandom = Symbol();

return class &#123;
    constructor(attack, hp, defence) &#123;
        this.attack = attack;
        this.hp = hp;
        this.defence = defence;
    &#125;

    gongji() &#123;
        //伤害：攻击力*随机数（0.8~1.1)
        const dmg = this.attack * this[getRandom](0.8, 1.1);
        console.log(dmg);
    &#125;

    [getRandom](min, max) &#123; //根据最小值和最大值产生一个随机数
        return Math.random() * (max - min) + min;
    &#125;
&#125;
</code></pre>
<p>})();</p>
<p>const h = new Hero(3, 6, 3);<br>const sybs = Object.getOwnPropertySymbols(Hero.prototype);<br>const prop = sybs[0];<br>console.log(h[prop](3, 5))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 共享符号</span><br><span class="line"></span><br><span class="line">- 根据某个符号名称（符号描述）能够得到同一个符号</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">Symbol.for(&quot;符号名/符号描述&quot;)  //获取共享符号</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li><p>```js<br>const obj = {</p>
<pre><code>a: 1,
b: 2,
[Symbol.for(&quot;c&quot;)]: 3
</code></pre>
<p>}</p>
<p>console.log(obj[Symbol.for(“c”)]);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const syb1 = Symbol.for(&quot;abc&quot;);</span><br><span class="line">  const syb2 = Symbol.for(&quot;abc&quot;);</span><br><span class="line">  console.log(syb1 === syb2)</span><br><span class="line">  const obj1 = &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: 2,</span><br><span class="line">      [syb1]: 3</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const obj2 = &#123;</span><br><span class="line">      a: &quot;a&quot;,</span><br><span class="line">      b: &quot;b&quot;,</span><br><span class="line">      [syb2]: &quot;c&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  console.log(obj1, obj2);</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const SymbolFor = (() =&gt; {</p>
<pre><code>const global = &#123;&#125;;//用于记录有哪些共享符号
return function (name) &#123;
    console.log(global)
    if (!global[name]) &#123;
        global[name] = Symbol(name);
    &#125;
    console.log(global);
    return global[name];
&#125;
</code></pre>
<p>})();</p>
<p>const syb1 = SymbolFor(“abc”);</p>
<p>const syb2 = SymbolFor(“abc”);</p>
<p>console.log(syb1 === syb2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 知名（公共、具名）符号</span><br><span class="line"></span><br><span class="line">&gt; 知名符号是一些具有特殊含义的共享符号，通过 `Symbol` 的静态属性得到</span><br><span class="line">&gt;</span><br><span class="line">&gt; `ES6` 延续了 `ES5` 的思想：减少魔法，暴露内部实现！</span><br><span class="line">&gt;</span><br><span class="line">&gt; 因此，`ES6` 用知名符号暴露了某些场景的内部实现</span><br><span class="line"></span><br><span class="line">#### Symbol.hasInstance</span><br><span class="line"></span><br><span class="line">- 该符号用于定义构造函数的静态成员，它将影响 `instanceof` 的判定</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  obj instanceof A</span><br><span class="line">  //等效于</span><br><span class="line">  A[Symbol.hasInstance](obj) // Function.prototype[Symbol.hasInstance]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>```js<br>function A() {</p>
<p>}</p>
<p>Object.defineProperty(A, Symbol.hasInstance, {</p>
<pre><code>value: function (obj) &#123;
    return false;
&#125;
</code></pre>
<p>})</p>
<p>const obj = new A();</p>
<p>console.log(obj instanceof A);<br>// console.log(A<a href="obj">Symbol.hasInstance</a>);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### Symbol.isConcatSpreadable</span><br><span class="line"></span><br><span class="line">- 该知名符号会影响数组的 `concat` 方法</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const arr = [3];</span><br><span class="line">  const arr2 = [5, 6, 7, 8];</span><br><span class="line">  </span><br><span class="line">  arr2[Symbol.isConcatSpreadable] = false;</span><br><span class="line">  </span><br><span class="line">  const result = arr.concat(56, arr2)</span><br><span class="line">  </span><br><span class="line">  //  [3, 56, [5,6,7,8]]</span><br><span class="line">  //  [3, 56, 5, 6, 7, 8]</span><br><span class="line">  </span><br><span class="line">  console.log(result)</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const arr = [1];<br>const obj = {</p>
<pre><code>0: 3,
1: 4,
length: 2,
[Symbol.isConcatSpreadable]: true
</code></pre>
<p>}</p>
<p>const result = arr.concat(2, obj)</p>
<p>console.log(result)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### Symbol.toPrimitive</span><br><span class="line"></span><br><span class="line">- 该知名符号会影响类型转换的结果</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  class Temperature &#123;</span><br><span class="line">      constructor(degree) &#123;</span><br><span class="line">          this.degree = degree;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      [Symbol.toPrimitive](type) &#123;</span><br><span class="line">          if (type === &quot;default&quot;) &#123;</span><br><span class="line">              return this.degree + &quot;摄氏度&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (type === &quot;number&quot;) &#123;</span><br><span class="line">              return this.degree;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (type === &quot;string&quot;) &#123;</span><br><span class="line">              return this.degree + &quot;℃&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const t = new Temperature(30);</span><br><span class="line">  </span><br><span class="line">  console.log(t + &quot;!&quot;);</span><br><span class="line">  console.log(t / 2);</span><br><span class="line">  console.log(String(t));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h4><ul>
<li><p>该知名符号会影响 <code>Object.prototype.toString</code> 的返回值</p>
</li>
<li><p>```js<br>class Person {</p>
<pre><code>[Symbol.toStringTag] = &quot;Person&quot;
</code></pre>
<p>}</p>
<p>const p = new Person();</p>
<p>const arr = [32424, 45654, 32]</p>
<p>console.log(Object.prototype.toString.apply(p));<br>console.log(Object.prototype.toString.apply(arr))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 其他知名符号</span><br><span class="line"></span><br><span class="line">## 异步处理</span><br><span class="line"></span><br><span class="line">### [回顾]事件循环</span><br><span class="line"></span><br><span class="line">- `JS`运行的环境称之为宿主环境。</span><br><span class="line"></span><br><span class="line">- 执行栈：`call stack`，一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境。</span><br><span class="line"></span><br><span class="line">- `JS`引擎永远执行的是执行栈的最顶部。</span><br><span class="line"></span><br><span class="line">- 异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。</span><br><span class="line"></span><br><span class="line">- 浏览器宿主环境中包含**5**个线程：</span><br><span class="line">  - `JS`引擎：负责执行执行栈的最顶部代码</span><br><span class="line">  - `GUI`线程：负责渲染页面 </span><br><span class="line">  - 事件监听线程：负责监听各种事件</span><br><span class="line">  - 计时线程：负责计时</span><br><span class="line">  - 网络线程：负责网络通信</span><br><span class="line"></span><br><span class="line">- 当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当`JS`引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。</span><br><span class="line"></span><br><span class="line">- `JS`引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。</span><br><span class="line"></span><br><span class="line">- 事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</span><br><span class="line">  - 宏任务（队列）：`macroTask`，计时器结束的回调、事件回调、`http`回调等等绝大部分异步函数进入宏队列</span><br><span class="line">  - 微任务（队列）：`MutationObserver`，`Promise`产生的回调进入微队列</span><br><span class="line"></span><br><span class="line">&gt; `MutationObserver`函数用于监听某个`DOM`对象的变化</span><br><span class="line"></span><br><span class="line">- 当执行栈清空时，`JS`引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。</span><br><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    function a() &#123;</span><br><span class="line">        console.log(&quot;a&quot;)</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function b() &#123;</span><br><span class="line">        console.log(&quot;b&quot;);</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function c() &#123;</span><br><span class="line">        console.log(&quot;c&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;global&quot;);</span><br><span class="line">    a();</span><br><span class="line">    // global a b c</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>console.log(“a”)</p>
<p>setTimeout(() =&gt; {</p>
<pre><code>console.log(&quot;b&quot;)
</code></pre>
<p>}, 0);</p>
<p>for (let i = 0; i &lt; 1000; i++) {</p>
<pre><code>console.log(&quot;c&quot;)
</code></pre>
<p>}<br>// a c*1000 b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  &lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt;</span><br><span class="line">  &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">  </span><br><span class="line">  let count = 1;</span><br><span class="line">  const ul = document.getElementById(&quot;container&quot;);</span><br><span class="line">  document.getElementById(&quot;btn&quot;).onclick = function A() &#123;</span><br><span class="line">      setTimeout(function C() &#123;</span><br><span class="line">          console.log(&quot;添加了一个li&quot;)</span><br><span class="line">      &#125;, 0);</span><br><span class="line">      var li = document.createElement(&quot;li&quot;)</span><br><span class="line">      li.innerText = count++;</span><br><span class="line">      ul.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //监听ul</span><br><span class="line">  const observer = new MutationObserver(function B() &#123;</span><br><span class="line">      //当监听的dom元素发生变化时运行的回调函数</span><br><span class="line">      console.log(&quot;ul元素发生了变化&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">  //监听ul</span><br><span class="line">  observer.observe(ul, &#123;</span><br><span class="line">      attributes: true, //监听属性的变化</span><br><span class="line">      childList: true, //监听子元素的变化</span><br><span class="line">      subtree: true //监听子树的变化</span><br><span class="line">  &#125;)</span><br><span class="line">  //取消监听</span><br><span class="line">  // observer.disconnect();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事件和回调函数的缺陷"><a href="#事件和回调函数的缺陷" class="headerlink" title="事件和回调函数的缺陷"></a>事件和回调函数的缺陷</h3><ul>
<li><p>我们习惯于使用传统的回调或事件处理来解决异步问题</p>
</li>
<li><p>事件：某个对象的属性是一个函数，当发生某一件事时，运行该函数</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回调：运行某个函数以实现某个功能的时候，传入一个函数作为参数，当发生某件事的时候，会运行该函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>本质上，事件和回调并没有本质的区别，只是把函数放置的位置不同而已。</p>
</li>
<li><p>一直以来，该模式都运作良好。</p>
</li>
<li><p>直到前端工程越来越复杂…</p>
</li>
<li><p>目前，该模式主要面临以下两个问题：</p>
<ul>
<li>回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套</li>
<li>异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增</li>
</ul>
</li>
<li><p>回调地狱实例</p>
<ul>
<li><p>```js<br>const btn1 = document.getElementById(“btn1”),</p>
<pre><code>  btn2 = document.getElementById(&quot;btn2&quot;),
  btn3 = document.getElementById(&quot;btn3&quot;);
</code></pre>
<p>btn1.addEventListener(“click”, function() {</p>
<pre><code>//按钮1的其他事情
btn2.addEventListener(&quot;click&quot;, function() &#123;
    //按钮2的其他事情
    btn3.addEventListener(&quot;click&quot;, function() &#123;
        alert(&quot;hello&quot;);
    &#125;)
&#125;)
</code></pre>
<p>})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  /*</span><br><span class="line">  邓哥心中有三个女神</span><br><span class="line">  有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span><br><span class="line">  用代码模拟上面的场景</span><br><span class="line">  */</span><br><span class="line">  function biaobai(god, callback) &#123;</span><br><span class="line">      console.log(`邓哥向女神【$&#123;god&#125;】发出了表白短信`);</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">          if (Math.random() &lt; 0.1) &#123;</span><br><span class="line">              //女神同意拉</span><br><span class="line">              //resolve</span><br><span class="line">              callback(true);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              //resolve</span><br><span class="line">              callback(false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  biaobai(&quot;女神1&quot;, function(result) &#123;</span><br><span class="line">      if (result) &#123;</span><br><span class="line">          console.log(&quot;女神1答应了，邓哥很开心!&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          console.log(&quot;女神1拒绝了，邓哥表示无压力，然后向女神2表白&quot;);</span><br><span class="line">          biaobai(&quot;女神2&quot;, function(result) &#123;</span><br><span class="line">              if (result) &#123;</span><br><span class="line">                  console.log(&quot;女神2答应了，邓哥很开心!&quot;)</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  console.log(&quot;女神2十分感动，然后拒绝了邓哥，邓哥向女神3表白&quot;);</span><br><span class="line">                  biaobai(&quot;女神3&quot;, function(result) &#123;</span><br><span class="line">                      if (result) &#123;</span><br><span class="line">                          console.log(&quot;女神3答应了，邓哥很开心!&quot;)</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          console.log(&quot;邓哥表示生无可恋!!&quot;);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>/*</p>
<pre><code>邓哥心中有二十个女神，他决定用更加高效的办法
他同时给二十个女神表白，如果有女神同意，就拒绝其他的女神
并且，当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析
用代码模拟上面的场景
</code></pre>
<p>*/</p>
<p>function biaobai(god, callback) {</p>
<pre><code>console.log(`邓哥向女神【$&#123;god&#125;】发出了表白短信`);
setTimeout(() =&gt; &#123;
    if (Math.random() &lt; 0.05) &#123;
        //女神同意拉
        callback(true);
    &#125; else &#123;
        callback(false);
    &#125;
&#125;, Math.floor(Math.random() * (3000 - 1000) + 1000));
</code></pre>
<p>}<br>let agreeGod = null; //同意邓哥的第一个女神<br>const results = []; //用于记录回复结果的数组<br>for (let i = 1; i &lt;= 20; i++) {</p>
<pre><code>biaobai(`女神$&#123;i&#125;`, result =&gt; &#123;
    results.push(result);

    if (result) &#123;
        console.log(`女神$&#123;i&#125;同意了`)
        if (agreeGod) &#123;
            console.log(`邓哥回复女神$&#123;i&#125;: 不好意思，刚才朋友用我手机，乱发的`)
        &#125; else &#123;
            agreeGod = `女神$&#123;i&#125;`;
            console.log(`邓哥终于找到了真爱`);
        &#125;
    &#125; else &#123;
        console.log(`女神$&#123;i&#125;拒绝了`)
    &#125;


    if (results.length === 20) &#123;
        console.log(&quot;日志记录&quot;, results)
    &#125;
&#125;)
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 异步处理的通用模型</span><br><span class="line"></span><br><span class="line">- `ES`官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景。</span><br><span class="line"></span><br><span class="line">- 值得注意的是，为了兼容旧系统，`ES6` 并不打算抛弃掉过去的做法，只是基于该模型推出一个全新的 `API`，使用该`API`，会让异步处理更加的简洁优雅。</span><br><span class="line"></span><br><span class="line">- 理解该 `API`，最重要的，是理解它的异步模型</span><br><span class="line"></span><br><span class="line">1. `ES6` 将某一件可能发生异步操作的事情，分为两个阶段：**unsettled** 和 **settled**</span><br><span class="line">   1. ![](https://cdn.jsdelivr.net/gh/haodex/noteImage@master/202111111633853.png)</span><br><span class="line">   2. **unsettled**： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事</span><br><span class="line">   3. **settled**：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转</span><br><span class="line">   4. 事情总是从 未决阶段 逐步发展到 已决阶段的。并且，未决阶段拥有控制何时通向已决阶段的能力。</span><br><span class="line">2. **ES6**将事情划分为三种状态： **pending**、**resolved**、**rejected**</span><br><span class="line">   1. **pending**: 挂起，处于未决阶段，则表示这件事情还在挂起（最终的结果还没出来）</span><br><span class="line">   2. **resolved**：已处理，已决阶段的一种状态，表示整件事情已经出现结果，并是一个可以按照正常逻辑进行下去的结果</span><br><span class="line">   3. **rejected**：已拒绝，已决阶段的一种状态，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误</span><br><span class="line"></span><br><span class="line">- 既然未决阶段有权力决定事情的走向，因此，未决阶段可以决定事情最终的状态！</span><br><span class="line">- 我们将 把事情变为`resolved`状态的过程叫做：**resolve**，推向该状态时，可能会传递一些数据</span><br><span class="line">- 我们将 把事情变为`rejected`状态的过程叫做：**reject**，推向该状态时，同样可能会传递一些数据，通常为错误信息</span><br><span class="line"></span><br><span class="line">**始终记住，无论是阶段，还是状态，是不可逆的！**</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/haodex/noteImage@master/202111111634957.png)</span><br><span class="line"></span><br><span class="line">3. 当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。</span><br><span class="line">   1. **resolved**状态：这是一个正常的已决状态，后续处理表示为 **thenable**</span><br><span class="line">   2. **rejected**状态：这是一个非正常的已决状态，后续处理表示为 **catchable**</span><br><span class="line"></span><br><span class="line">后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/haodex/noteImage@master/202111111632530.png)</span><br><span class="line"></span><br><span class="line">4. 整件事称之为**Promise**</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/haodex/noteImage@master/202111111635604.png)</span><br><span class="line"></span><br><span class="line">**理解上面的概念，对学习Promise至关重要！**</span><br><span class="line"></span><br><span class="line">### Promise</span><br><span class="line"></span><br><span class="line">#### Promise的基本使用</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">const pro = new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    // 未决阶段的处理</span><br><span class="line">    // 通过调用resolve函数将Promise推向已决阶段的resolved状态</span><br><span class="line">    // 通过调用reject函数将Promise推向已决阶段的rejected状态</span><br><span class="line">    // resolve和reject均可以传递最多一个参数，表示推向状态的数据</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pro.then(data=&gt;&#123;</span><br><span class="line">    //这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行</span><br><span class="line">    //如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行</span><br><span class="line">    //data为状态数据</span><br><span class="line">&#125;, err=&gt;&#123;</span><br><span class="line">    //这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行</span><br><span class="line">    //如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行</span><br><span class="line">    //err为状态数据</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>细节</strong></p>
<ul>
<li><p>未决阶段的处理函数是同步的，会立即执行</p>
</li>
<li><p><code>thenable</code>和<code>catchable</code>函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列</p>
</li>
<li><p><code>pro.then</code>可以只添加<code>thenable</code>函数，<code>pro.catch</code>可以单独添加<code>catchable</code>函数</p>
</li>
<li><p>在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向<code>rejected</code>，并会被<code>catchable</code>捕获</p>
</li>
<li><p>一旦状态推向了已决阶段，无法再对状态做任何更改</p>
</li>
<li><p><strong>Promise并没有消除回调，只是让回调变得可控</strong></p>
</li>
<li><p>实例</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">                <span class="comment">//女神同意拉</span></span><br><span class="line">                resolve(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//resolve</span></span><br><span class="line">                resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">biaobai(<span class="string">&quot;女神1&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辅助函数,把传进来的对象拼接成url的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toData</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = i + <span class="string">&quot;=&quot;</span> + obj[i];</span><br><span class="line">        arr.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装Ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//指定提交方式的默认值</span></span><br><span class="line">        obj.type = obj.type || <span class="string">&quot;get&quot;</span>;</span><br><span class="line">        <span class="comment">//设置是否异步，默认为true(异步)</span></span><br><span class="line">        obj.async = obj.async || <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//设置数据的默认值</span></span><br><span class="line">        obj.data = obj.data || <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 根据不同的浏览器创建XHR对象</span></span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">            <span class="comment">// 非IE浏览器</span></span><br><span class="line">            xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// IE浏览器</span></span><br><span class="line">            xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区分get和post,发送HTTP请求</span></span><br><span class="line">        <span class="keyword">if</span> (obj.type === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">            xhr.open(obj.type, obj.url, obj.async);</span><br><span class="line">            xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> data = toData(obj.data);</span><br><span class="line">            xhr.send(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> url = obj.url + <span class="string">&quot;?&quot;</span> + toData(obj.data);</span><br><span class="line">            xhr.open(obj.type, url, obj.async);</span><br><span class="line">            xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收返回过来的数据</span></span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(xhr.status)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;./data/students.json?name=李华&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const pro = new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&quot;未决阶段&quot;)</span></span><br><span class="line"><span class="comment">//     resolve(123);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// pro.then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     // pro的状态是resolved</span></span><br><span class="line"><span class="comment">//     console.log(data);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// pro的状态是pending</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// pro的状态是pending</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// pro的状态是pending</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            resolve(<span class="number">123</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;asdfasdf&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//pro: resolved</span></span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// pro: rejected</span></span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    resolve(<span class="number">1</span>); <span class="comment">//无效</span></span><br><span class="line">    reject(<span class="number">2</span>); <span class="comment">//无效</span></span><br><span class="line">    resolve(<span class="number">3</span>); <span class="comment">//无效</span></span><br><span class="line">    reject(<span class="number">4</span>); <span class="comment">//无效</span></span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise的串联"><a href="#Promise的串联" class="headerlink" title="Promise的串联"></a>Promise的串联</h4><p>当后续的Promise需要用到之前的<code>Promise</code>的处理结果时，需要<code>Promise</code>的串联</p>
<p><code>Promise</code>对象中，无论是<code>then</code>方法还是<code>catch</code>方法，它们都具有返回值，返回的是一个全新的<code>Promise</code>对象，它的状态满足下面的规则：</p>
<ol>
<li>如果当前的<code>Promise</code>是未决的，得到的新的Promise是挂起状态</li>
<li>如果当前的<code>Promise</code>是已决的，会运行响应的后续处理函数，并将后续处理函数的结果（返回值）作为<code>resolved</code>状态数据，应用到新的<code>Promise</code>中；如果后续处理函数发生错误，则把返回值作为<code>rejected</code>状态数据，应用到新的<code>Promise</code>中。</li>
</ol>
<p><strong>后续的Promise一定会等到前面的Promise有了后续处理结果后，才会变成已决状态</strong></p>
<p>如果前面的<code>Promise</code>的后续处理，返回的是一个<code>Promise</code>，则返回的新的<code>Promise</code>状态和后续处理返回的<code>Promise</code>状态保持一致。</p>
<ul>
<li>实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> pro2 = pro1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result * <span class="number">2</span></span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err * <span class="number">3</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        pro1.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err * <span class="number">2</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//pro2类型：Promise对象</span></span><br><span class="line">        <span class="comment">//pro2的状态：</span></span><br><span class="line">        pro2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result * <span class="number">2</span>), <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err * <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pro2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pro1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;结果出来了，得到的是一个Promise&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> pro2;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">                <span class="comment">//女神同意拉</span></span><br><span class="line">                resolve(<span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//resolve</span></span><br><span class="line">                resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> gods = [<span class="string">&quot;女神1&quot;</span>, <span class="string">&quot;女神2&quot;</span>, <span class="string">&quot;女神3&quot;</span>, <span class="string">&quot;女神4&quot;</span>, <span class="string">&quot;女神5&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> pro;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gods.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">        pro = biaobai(gods[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pro = pro.then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resp === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resp) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;gods[i]&#125;</span>同意了`</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;gods[i]&#125;</span>拒绝了`</span>)</span><br><span class="line">            <span class="keyword">if</span> (i &lt; gods.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> biaobai(gods[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise的其他api"><a href="#Promise的其他api" class="headerlink" title="Promise的其他api"></a>Promise的其他api</h4><ul>
<li><p>原型成员 (实例成员)</p>
<ul>
<li><strong>then</strong>：注册一个后续处理函数，当<code>Promise</code>为<code>resolved</code>状态时运行该函数</li>
<li><strong>catch</strong>：注册一个后续处理函数，当<code>Promise</code>为<code>rejected</code>状态时运行该函数</li>
<li><strong>finally</strong>：[<code>ES2018</code>]注册一个后续处理函数（无参），当<code>Promise</code>为已决时运行该函数</li>
</ul>
</li>
<li><p>构造函数成员 （静态成员）</p>
</li>
<li><p><strong>resolve</strong>(数据)：该方法返回一个<code>resolved</code>状态的<code>Promise</code>，传递的数据作为状态数据</p>
<ul>
<li>特殊情况：如果传递的数据是<code>Promise</code>，则直接返回传递的<code>Promise</code>对象</li>
</ul>
</li>
<li><p><strong>reject</strong>(数据)：该方法返回一个<code>rejected</code>状态的<code>Promise</code>，传递的数据作为状态数据</p>
</li>
<li><p>**all(iterable)**：这个方法返回一个新的<code>promise</code>对象，该<code>promise</code>对象在<code>iterable</code>参数对象里所有的<code>promise</code>对象都成功的时候才会触发成功，一旦有任何一个<code>iterable</code>里面的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>iterable</code>里所有promise返回值的数组作为成功回调的返回值，顺序跟<code>iterable</code>的顺序保持一致；如果这个新的<code>promise</code>对象触发了失败状态，它会把<code>iterable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。<code>Promise.all</code>方法常被用于处理多个<code>promise</code>对象的状态集合。</p>
</li>
<li><p>**race(iterable)**：当<code>iterable</code>参数里的任意一个子<code>promise</code>被成功或失败后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promise</code>绑定的相应句柄，并返回该<code>promise</code>对象</p>
</li>
<li><p>例</p>
</li>
<li><p>```js<br>// const pro = new Promise((resolve, reject) =&gt; {<br>//     resolve(1);<br>// })<br>//等效于：<br>// const pro = Promise.resolve(1);</p>
<p>// const pro = new Promise((resolve, reject) =&gt; {<br>//     reject(1);<br>// })<br>//等效于：<br>// const pro = Promise.reject(1);</p>
<p>const p = new Promise((resolve, reject) =&gt; {</p>
<pre><code>resolve(3);
</code></pre>
<p>})<br>// const pro = Promise.resolve(p);<br>//等效于<br>const pro = p;<br>console.log(pro === p)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  function getRandom(min, max) &#123;</span><br><span class="line">      return Math.floor(Math.random() * (max - min)) + min;</span><br><span class="line">  &#125;</span><br><span class="line">  const proms = [];</span><br><span class="line">  for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">      proms.push(new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">              if (Math.random() &lt; 0.5) &#123;</span><br><span class="line">                  console.log(i, &quot;完成&quot;);</span><br><span class="line">                  resolve(i);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  console.log(i, &quot;失败&quot;)</span><br><span class="line">                  reject(i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, getRandom(1000, 5000));</span><br><span class="line">      &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  //等到所有的promise变成resolved状态后输出: 全部完成</span><br><span class="line">  const pro = Promise.all(proms)</span><br><span class="line">  pro.then(datas =&gt; &#123;</span><br><span class="line">      console.log(&quot;全部完成&quot;, datas);</span><br><span class="line">  &#125;)</span><br><span class="line">  pro.catch(err =&gt; &#123;</span><br><span class="line">      console.log(&quot;有失败的&quot;, err);</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(proms);</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>function getRandom(min, max) {</p>
<pre><code>return Math.floor(Math.random() * (max - min)) + min;
</code></pre>
<p>}<br>const proms = [];<br>for (let i = 0; i &lt; 10; i++) {</p>
<pre><code>proms.push(new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        if (Math.random() &lt; 0.5) &#123;
            console.log(i, &quot;完成&quot;);
            resolve(i);
        &#125; else &#123;
            console.log(i, &quot;失败&quot;)
            reject(i);
        &#125;
    &#125;, getRandom(1000, 5000));
&#125;))
</code></pre>
<p>}<br>//等到所有的promise变成resolved状态后输出: 全部完成<br>const pro = Promise.race(proms)<br>pro.then(data =&gt; {</p>
<pre><code>console.log(&quot;有人完成了&quot;, data);
</code></pre>
<p>})<br>pro.catch(err =&gt; {</p>
<pre><code>console.log(&quot;有人失败了&quot;, err);
</code></pre>
<p>})<br>console.log(proms);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  /*</span><br><span class="line">  邓哥心中有二十个女神，他决定用更加高效的办法</span><br><span class="line">  他同时给二十个女神表白，如果有女神同意，就拒绝其他的女神</span><br><span class="line">  并且，当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析</span><br><span class="line">  用代码模拟上面的场景</span><br><span class="line">  */</span><br><span class="line">  function biaobai(god) &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          console.log(`邓哥向女神【$&#123;god&#125;】发出了表白短信`);</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">              if (Math.random() &lt; 0.05) &#123;</span><br><span class="line">                  //女神同意拉</span><br><span class="line">                  console.log(god, &quot;同意&quot;)</span><br><span class="line">                  resolve(true);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  console.log(god, &quot;拒绝&quot;)</span><br><span class="line">                  resolve(false);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, Math.floor(Math.random() * (3000 - 1000) + 1000));</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  const proms = [];</span><br><span class="line">  let hasAgree = false; //是否有女神同意</span><br><span class="line">  </span><br><span class="line">  for (let i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">      const pro = biaobai(`女神$&#123;i&#125;`).then(resp =&gt; &#123;</span><br><span class="line">          if (resp) &#123;</span><br><span class="line">              if (hasAgree) &#123;</span><br><span class="line">                  console.log(&quot;发错了短信，邓哥很机智的拒绝了&quot;)</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  hasAgree = true;</span><br><span class="line">                  console.log(&quot;邓哥很开心，终于成功了！&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return resp;</span><br><span class="line">      &#125;)</span><br><span class="line">      proms.push(pro);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Promise.all(proms).then(results =&gt; &#123;</span><br><span class="line">      console.log(&quot;日志记录&quot;, results);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>// Promise.all可以将多个Promise实例包装成一个新的Promise实例<br>// 同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组<br>// 而失败的时候则返回最先被reject失败状态的值</p>
<p>function test(x) {</p>
<pre><code>return new Promise((reason,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        Math.random() * 100 &gt; 50 ? reason(x) : reject(x)
    &#125;,100)
&#125;)
</code></pre>
<p>}</p>
<p>let oP = Promise.all([test(‘a’),test(‘b’),test(‘c’)]);<br>oP.then((val) =&gt; {</p>
<pre><code>console.log(val);
</code></pre>
<p>},(reason) =&gt; {</p>
<pre><code>console.log(reason);
</code></pre>
<p>});</p>
<p>// 顾名思义：Promise.race就是赛跑的意思，意思就是说<br>// Promise.race([p1,p2,p3])里那个结果获得的快，就返回那个结果<br>// 不管结果本身是成功状态还是失败状态<br>Promise.race([test(‘a’),test(‘b’),test(‘c’)]).then((val) =&gt;{</p>
<pre><code>console.log(val,&#39;ok&#39;)
</code></pre>
<p>},(reason) =&gt; {</p>
<pre><code>console.log(reason,&#39;no&#39;);
</code></pre>
<p>});</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### [扩展手写Promise]</span><br><span class="line"></span><br><span class="line">##### ES6之手写Promise</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">const MyPromise = (() =&gt; &#123;</span><br><span class="line">    const PENDING = &quot;pending&quot;,</span><br><span class="line">        RESOLVED = &quot;resolved&quot;,</span><br><span class="line">        REJECTED = &quot;rejected&quot;,</span><br><span class="line">        PromiveValue = Symbol(&quot;PromiseValue&quot;), //状态数据</span><br><span class="line">        PromiseStatus = Symbol(&quot;PromiseStatus&quot;),</span><br><span class="line">        thenables = Symbol(&quot;thenables&quot;), //thenable</span><br><span class="line">        catchables = Symbol(&quot;catchbles&quot;), //catchables</span><br><span class="line">        changeStatus = Symbol(&quot;changeStatus&quot;),//当前状态</span><br><span class="line">        settleHandle = Symbol(&quot;settleHandle&quot;), //后续处理的通用函数</span><br><span class="line">        linkPromise = Symbol(&quot;linkPromise&quot;);  //创建串联的Promise</span><br><span class="line"></span><br><span class="line">    return class MyPromise &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 改变当前Promise的状态</span><br><span class="line">         * @param &#123;*&#125; newStatus </span><br><span class="line">         * @param &#123;*&#125; newValue </span><br><span class="line">         * @param &#123;*&#125; queue 执行的作业队列</span><br><span class="line">         */</span><br><span class="line">        [changeStatus](newStatus, newValue, queue) &#123;</span><br><span class="line">            if (this[PromiseStatus] !== PENDING) &#123;</span><br><span class="line">                //状态无法变更</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            this[PromiseStatus] = newStatus;</span><br><span class="line">            this[PromiveValue] = newValue;</span><br><span class="line">            //执行相应队列中的函数</span><br><span class="line">            queue.forEach(handler =&gt; handler(newValue));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * </span><br><span class="line">         * @param &#123;*&#125; executor 未决阶段（pending状态）下的处理函数</span><br><span class="line">         */</span><br><span class="line">        constructor(executor) &#123;</span><br><span class="line">            this[PromiseStatus] = PENDING;</span><br><span class="line">            this[PromiveValue] = undefined;</span><br><span class="line">            this[thenables] = []; //后续处理函数的数组 -&gt; resolved</span><br><span class="line">            this[catchables] = []; //后续处理函数的数组 -&gt; rejected</span><br><span class="line"></span><br><span class="line">            const resolve = data =&gt; &#123;</span><br><span class="line">                this[changeStatus](RESOLVED, data, this[thenables]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            const reject = reason =&gt; &#123;</span><br><span class="line">                this[changeStatus](REJECTED, reason, this[catchables]);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                executor(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">            catch (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 处理 后续处理函数</span><br><span class="line">         * @param &#123;*&#125; handler 后续处理函数</span><br><span class="line">         * @param &#123;*&#125; immediatelyStatus 需要立即执行的状态</span><br><span class="line">         * @param &#123;*&#125; queue 作业队列</span><br><span class="line">         */</span><br><span class="line">        [settleHandle](handler, immediatelyStatus, queue) &#123;</span><br><span class="line">            if (typeof handler !== &quot;function&quot;) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (this[PromiseStatus] === immediatelyStatus) &#123;</span><br><span class="line">                //直接运行</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    handler(this[PromiveValue]);</span><br><span class="line">                &#125;, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                queue.push(handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [linkPromise](thenalbe, catchable) &#123;</span><br><span class="line">            function exec(data, handler, resolve, reject) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    const result = handler(data); //得到当前Promise的处理结果</span><br><span class="line">                    if (result instanceof MyPromise) &#123;</span><br><span class="line">                        result.then(d =&gt; &#123;</span><br><span class="line">                            resolve(d)</span><br><span class="line">                        &#125;, err =&gt; &#123;</span><br><span class="line">                            reject(err);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">                this[settleHandle](data =&gt; &#123;</span><br><span class="line">                    exec(data, thenalbe, resolve, reject);</span><br><span class="line">                &#125;, RESOLVED, this[thenables])</span><br><span class="line"></span><br><span class="line">                this[settleHandle](reason =&gt; &#123;</span><br><span class="line">                    exec(reason, catchable, resolve, reject);</span><br><span class="line">                &#125;, REJECTED, this[catchables])</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        then(thenable, catchable) &#123;</span><br><span class="line">            return this[linkPromise](thenable, catchable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        catch(catchable) &#123;</span><br><span class="line"></span><br><span class="line">            return this[linkPromise](undefined, catchable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        static all(proms) &#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                const results = proms.map(p =&gt; &#123;</span><br><span class="line">                    const obj = &#123;</span><br><span class="line">                        result: undefined,</span><br><span class="line">                        isResolved: false</span><br><span class="line">                    &#125;</span><br><span class="line">                    p.then(data =&gt; &#123;</span><br><span class="line">                        obj.result = data;</span><br><span class="line">                        obj.isResolved = true;</span><br><span class="line">                        //判断是否所有的全部完成</span><br><span class="line">                        const unResolved = results.filter(r =&gt; !r.isResolved)</span><br><span class="line">                        if (unResolved.length === 0) &#123;</span><br><span class="line">                            //全部完成</span><br><span class="line">                            resolve(results.map(r =&gt; r.result));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, reason =&gt; &#123;</span><br><span class="line">                        reject(reason);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    return obj;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static race(proms) &#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                proms.forEach(p =&gt; &#123;</span><br><span class="line">                    p.then(data =&gt; &#123;</span><br><span class="line">                        resolve(data);</span><br><span class="line">                    &#125;, err =&gt; &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static resolve(data) &#123;</span><br><span class="line">            if (data instanceof MyPromise) &#123;</span><br><span class="line">                return data;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return new MyPromise(resolve =&gt; &#123;</span><br><span class="line">                    resolve(data);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static reject(reason) &#123;</span><br><span class="line">            return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">                reject(reason);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="ES5之手写Promise"><a href="#ES5之手写Promise" class="headerlink" title="ES5之手写Promise"></a>ES5之手写Promise</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生Promise特性</span></span><br><span class="line"><span class="comment">//new</span></span><br><span class="line"><span class="comment">// 参数：executor 同步执行，executor中要有两个参数(resolve,reject)</span></span><br><span class="line"><span class="comment">// 触发Fulfilled Rejected状态（成功，失败），没有触发之前是pending等待状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作</span></span><br><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line"><span class="comment">// then异步执行，抛出错误</span></span><br><span class="line"><span class="comment">// 空then</span></span><br><span class="line"><span class="comment">// 返回值是对象时</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将self事先等于window</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态：一开始为进行中pending</span></span><br><span class="line">    self.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了then可以调用函数的参数，为self声明两个参数来接收两个函数的参数</span></span><br><span class="line">    self.resolveValue = <span class="literal">null</span>;</span><br><span class="line">    self.rejectReason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调数组，当注册函数时不执行，先存入数组，当真正执行函数时，在执行</span></span><br><span class="line">    self.ResolveCallBackList = [];</span><br><span class="line">    self.RejectCallBackList = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//只有状态===pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            self.status = <span class="string">&#x27;Fulfilled&#x27;</span>; <span class="comment">//成功</span></span><br><span class="line">            <span class="comment">//将value赋值给self的resolveValue，以便then使用</span></span><br><span class="line">            self.resolveValue = value;</span><br><span class="line">            <span class="comment">// 执行回调函数中的函数</span></span><br><span class="line">            self.ResolveCallBackList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">                ele();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//只有状态===pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            self.status = <span class="string">&#x27;Rejected&#x27;</span>; <span class="comment">//失败</span></span><br><span class="line">            <span class="comment">// 将reason赋值给self的rejectReason，以便then使用</span></span><br><span class="line">            self.rejectReason = reason;</span><br><span class="line">            <span class="comment">// 执行回调函数中的函数</span></span><br><span class="line">            self.RejectCallBackList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">                ele();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用try&#123;&#125;catch&#123;&#125;判断错误，当executor抛出错误时，执行reject()来打印错误</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理返回值函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ResolutionReturnPromise</span>(<span class="params">nextPromise, returnValue, res, rej</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果返回值是Promise对象时</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        returnValue.then(</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                res(val);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">                rej(reason);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回值不是Promise对象时，执行res</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res(returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then函数，参数：onFulfilled,onRejected两个函数参数，分别代表完成、拒绝</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 空then处理方法：</span></span><br><span class="line">    <span class="comment">//若没有onFulfilled时则返回参数val</span></span><br><span class="line">    <span class="comment">//若onRejected则抛出参数reason错误</span></span><br><span class="line">    <span class="keyword">if</span> (!onFulfilled) &#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!onRejected) &#123;</span><br><span class="line">        onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将self事先等于window</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式操作</span></span><br><span class="line">    <span class="comment">// 拿到上一次函数返回结果，用于下一次then的参数</span></span><br><span class="line">    <span class="keyword">var</span> nextPromise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">res, rej</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当状态为Fulfilled时，执行onFulfilled完成</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;Fulfilled&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//异步方式执行操作：setTimeout</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 在then中抛出错误时，在下一个then中的reject函数中打印</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//拿到此次函数的返回结果，用于下一次then的参数</span></span><br><span class="line">                    <span class="keyword">var</span> nextResolveValue = onFulfilled(self.resolveValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理返回值函数</span></span><br><span class="line">                    ResolutionReturnPromise(nextPromise, nextResolveValue, res, rej);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    //拿到此次函数的返回结果，用于下一次then的参数</span></span><br><span class="line"><span class="comment">                    var nextResolveValue = onFulfilled(self.resolveValue);</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    //执行下一次函数时，使用上一次函数返回结果作为参数</span></span><br><span class="line"><span class="comment">                    res(nextResolveValue); */</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    rej(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为Rjected时，执行onRejected拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;Rejected&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> nextRejectValue = onRejected(self.rejectReason);</span><br><span class="line">                    ResolutionReturnPromise(nextPromise, nextRejectValue, res, rej);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    rej(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步操作实现</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 将函数推入回调函数</span></span><br><span class="line">            self.ResolveCallBackList.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> nextResolveValue = onFulfilled(self.resolveValue);</span><br><span class="line">                        ResolutionReturnPromise(nextPromise, nextResolveValue, res, rej);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        rej(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            self.RejectCallBackList.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> nextRejectValue = onRejected(self.rejectReason);</span><br><span class="line">                        ResolutionReturnPromise(nextPromise, nextRejectValue, res, rej);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        rej(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextPromise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 race</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (promiseArr.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">            resolve(ele).then(</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                    resolve(res);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 all</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> results = [], <span class="comment">//执行数组</span></span><br><span class="line">        promiseArrCount = <span class="number">0</span>, <span class="comment">//计算函数总执行次数</span></span><br><span class="line">        promiseArrLength = promiseArr.length; <span class="comment">//函数参数总长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">            resolve(ele).then(</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                    promiseArrCount++;</span><br><span class="line">                    results.push(res);</span><br><span class="line">                    <span class="comment">//当所有函数都正确执行了，resolve执行输出所有结果</span></span><br><span class="line">                    <span class="keyword">if</span> (promiseArrCount === promiseArrLength) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(results);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><ul>
<li><p><code>async</code>函数，是<code>Generator</code>语法糖，通过<code>babel</code>编译后可以看出它就是<code>Generator+promise+Co</code>思想实现的，配合<code>await</code>使用</p>
</li>
<li><p>目的：优雅的解决异步操作问题</p>
</li>
</ul>
<blockquote>
<p><code>async</code> 和 <code>await</code> 是 <code>ES2016</code> 新增两个关键字，它们借鉴了 <code>ES2015</code> 中生成器在实际开发中的应用，目的是简化 <code>Promise api</code> 的使用，并非是替代 <code>Promise</code>。</p>
</blockquote>
<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><ul>
<li><p>目的是简化在函数的返回值中对Promise的创建</p>
</li>
<li><p><strong>async</strong> 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 <strong>Promise</strong> 对象。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><ul>
<li><p><strong>await关键字必须出现在async函数中！！！！</strong></p>
</li>
<li><p><strong>await</strong>用在某个表达式之前，如果表达式是一个<strong>Promise</strong>，则得到的是<strong>thenable</strong>中的状态数据。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> test1();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        test1().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = data;</span><br><span class="line">            <span class="built_in">console</span>.log(result);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>await</code>的表达式不是<code>Promise</code>，则会将其使用<code>Promise.resolve</code>包装后按照规则运行</p>
<ul>
<li><p>实例</p>
<ul>
<li><p>```js<br>function biaobai(god) {</p>
<pre><code>return new Promise(resolve =&gt; &#123;
    console.log(`邓哥向$&#123;god&#125;发出了表白短信`);
    setTimeout(() =&gt; &#123;
        if (Math.random() &lt; 0.3) &#123;
            //女神同意拉
            resolve(true)
        &#125; else &#123;
            //resolve
            resolve(false);
        &#125;
    &#125;, 500);
&#125;)
</code></pre>
<p>}</p>
<p>/*</p>
<pre><code>        邓哥心中有三个女神
        有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止
        用代码模拟上面的场景
    */
</code></pre>
<p>(async () =&gt; {</p>
<pre><code>const gods = [&quot;女神1&quot;, &quot;女神2&quot;, &quot;女神3&quot;, &quot;女神4&quot;, &quot;女神5&quot;];
for (let i = 0; i &lt; gods.length; i++) &#123;
    const g = gods[i];
    // 当前循环等待的Promise没有resolve，下一次循环不运行
    const result = await biaobai(g);
    if (result) &#123;
        console.log(`$&#123;g&#125;同意了，不用再表白了！！！`);
        break;
    &#125; else &#123;
        console.log(`$&#123;g&#125;没有同意`)
    &#125;
&#125;
</code></pre>
<p>})()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  async function getPromise() &#123;</span><br><span class="line">      if (Math.random() &lt; 0.5) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          throw 2;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  async function test() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          const result = await getPromise();</span><br><span class="line">          console.log(&quot;正常状态&quot;, result)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">          console.log(&quot;错误状态&quot;, err);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  test();</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>function delay(duration) {</p>
<pre><code>return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve();
    &#125;, duration);
&#125;)
</code></pre>
<p>}</p>
<p>async function biaobai(god) {</p>
<pre><code>console.log(`邓哥向$&#123;god&#125;发出了表白短信`);
await delay(500);
return Math.random() &lt; 0.3;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### promise函数化</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">// 当使用NodeJs开始时，使用promise为中心的开发方式，带来的好处是大家都使用promise进行异步方案的解决，不用考虑回调callback，但是还是有一些库没有用promise来实现，所以就需要使用一个函数来把那些库要使用的函数来进行promise实现，不过promisify只可以把一个函数来进行promise转换</span><br><span class="line">function promisify(func) &#123;</span><br><span class="line">	return function(...arg) &#123;</span><br><span class="line">		return new Promise((res,rej) =&gt; &#123;</span><br><span class="line">			// 在node中参数基本上都是error-firstb标准形式，所以基本可以写成(err,data)形式</span><br><span class="line">			func(...arg, (err,data) =&gt; &#123;</span><br><span class="line">				if(err) &#123;</span><br><span class="line">					rej(err);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					res(data);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// let readFile = promisify(fs.readFile);</span><br><span class="line">// readFile(&#x27;./number.txt&#x27;,&#x27;utf-8&#x27;).then((val) =&gt; &#123;</span><br><span class="line">// 	console.log(val);</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// promisifyAll 函数可以把一个库中所有的函数都promise化并添加成另外一个函数，</span><br><span class="line">// promisifyAll 函数可以为一个方法中的所有函数另外添加一个Async（promise化）的函数，可以</span><br><span class="line">function promisifyAll(obj) &#123;</span><br><span class="line">	for (let key in obj) &#123;</span><br><span class="line">		let fn = obj[key];</span><br><span class="line">		if(typeof fn === &#x27;function&#x27;) &#123;</span><br><span class="line">			obj[key + &#x27;Async&#x27;] = promisify(fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">promisifyAll(fs);</span><br><span class="line">// fs.readFile -&gt; readFileAsync</span><br><span class="line">// fs.writeFile -&gt; readFileAsync</span><br><span class="line"></span><br><span class="line">fs.readFileAsync(&#x27;./number.txt&#x27;,&#x27;utf-8&#x27;).then((val) =&gt; &#123;</span><br><span class="line">	console.log(val);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// bluebird库中有这个promisify函数和promisifyArr函数</span><br><span class="line">// let bluebird = require(&#x27;bluebird&#x27;);</span><br><span class="line">// bluebird.promisify(fs.readFile);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="FetchApi"><a href="#FetchApi" class="headerlink" title="FetchApi"></a>FetchApi</h2><h3 id="Fetch-Api-概述"><a href="#Fetch-Api-概述" class="headerlink" title="Fetch Api 概述"></a>Fetch Api 概述</h3><ul>
<li><p><strong>XMLHttpRequest的问题</strong></p>
<ul>
<li>所有的功能全部集中在同一个对象上，容易书写出混乱不易维护的代码</li>
<li>采用传统的事件驱动模式，无法适配新的 <code>Promise Api</code></li>
</ul>
</li>
<li><p><strong>Fetch Api 的特点</strong></p>
<ul>
<li>并非取代 <code>AJAX</code>，而是对 <code>AJAX</code> 传统 <code>API</code> 的改进</li>
<li>精细的功能分割：头部信息、请求信息、响应信息等均分布到不同的对象，更利于处理各种复杂的 <code>AJAX</code> 场景</li>
<li>使用 <code>Promise Api</code>，更利于异步代码的书写</li>
<li><code>Fetch Api</code> 并非 <code>ES6</code> 的内容，属于 <code>HTML5</code> 新增的 <code>Web Api</code></li>
<li>需要掌握网络通信的知识</li>
</ul>
</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><blockquote>
<p>请求测试地址：<a target="_blank" rel="noopener" href="http://101.132.72.36:5100/api/local">http://101.132.72.36:5100/api/local</a></p>
<p>​            <a target="_blank" rel="noopener" href="http://jsonplaceholder.typicode.com/posts">http://jsonplaceholder.typicode.com/posts</a></p>
</blockquote>
<p>使用 <code>fetch</code> 函数即可立即向服务器发送网络请求</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>该函数有两个参数：</p>
<ol>
<li>必填，字符串，请求地址</li>
<li>选填，对象，请求配置</li>
</ol>
<p><strong>请求配置对象</strong></p>
<ul>
<li><strong>method</strong>：字符串，请求方法，默认值<code>GET</code></li>
<li><strong>headers</strong>：对象，请求头信息</li>
<li><strong>body</strong>: 请求体的内容，必须匹配请求头中的 <code>Content-Type</code></li>
<li><strong>mode</strong>：字符串，请求模式<ul>
<li><strong>cors</strong>：默认值，配置为该值，会在请求头中加入 <code>origin</code> 和 <code>referer</code></li>
<li><strong>no-cors</strong>：配置为该值，不会在请求头中加入 <code>origin</code> 和 <code>referer</code>，跨域的时候可能会出现问题</li>
<li><strong>same-origin</strong>：指示请求必须在同一个域中发生，如果请求其他域，则会报错</li>
</ul>
</li>
<li><strong>credentials</strong>: 如何携带凭据（<code>cookie</code>）<ul>
<li><strong>omit</strong>：默认值，不携带<code>cookie</code></li>
<li><strong>same-origin</strong>：请求同源地址时携带<code>cookie</code></li>
<li><strong>include</strong>：请求任何地址都携带<code>cookie</code></li>
</ul>
</li>
<li><strong>cache</strong>：配置缓存模式<ul>
<li><strong>default</strong>: 表示<code>fetch</code>请求之前将检查下<code>http</code>的缓存.</li>
<li><strong>no-store</strong>: 表示<code>fetch</code>请求将完全忽略<code>http</code>缓存的存在. 这意味着请求之前将不再检查下<code>http</code>的缓存, 拿到响应后, 它也不会更新<code>http</code>缓存.</li>
<li><strong>no-cache</strong>: 如果存在缓存, 那么<code>fetch</code>将发送一个条件查询<code>request</code>和一个正常的<code>request</code>, 拿到响应后, 它会更新<code>http</code>缓存.</li>
<li><strong>reload</strong>: 表示fetch请求之前将忽略<code>http</code>缓存的存在, 但是请求拿到响应后, 它将主动更新<code>http</code>缓存.</li>
<li><strong>force-cache</strong>: 表示<code>fetch</code>请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的<code>request</code>.</li>
<li><strong>only-if-cached</strong>: 表示<code>fetch</code>请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”<code>same-origin</code>”时有效).</li>
</ul>
</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><strong>fetch</strong> 函数返回一个 <strong>Promise</strong> 对象</p>
<ul>
<li>当收到服务器的返回结果后，Promise 进入resolved状态，状态数据为 Response 对象</li>
<li>当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息</li>
</ul>
<p><strong>Response对象</strong></p>
<ul>
<li><strong>ok</strong>：<code>boolean</code>，当响应消息码在<code>200~299</code>之间时为<code>true</code>，其他为<code>false</code></li>
<li><strong>status</strong>：<code>number</code>，响应的状态码</li>
<li>**text()**：用于处理文本格式的 <code>Ajax</code> 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 <code>string</code> 对象的 <code>Promise</code>。</li>
<li>**blob()**：用于处理二进制文件格式（比如图片或者电子表格）的 <code>Ajax</code> 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 <code>blob</code> 对象的 <code>Promise</code>。</li>
<li>**json()**：用于处理 <code>JSON</code> 格式的 <code>Ajax</code> 的响应。它将 <code>JSON</code> 数据流转换为一个被解决为 <code>JavaScript</code> 对象的promise。</li>
<li>**redirect()**：可以用于重定向到另一个 <code>URL</code>。它会创建一个新的 <code>Promise</code>，以解决来自重定向的 <code>URL</code> 的响应。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;获得信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(url)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h3><p>除了使用基本的<code>fetch</code>方法，还可以通过创建一个<code>Request</code>对象来完成请求（实际上，<code>fetch</code>的内部会帮你创建一个<code>Request</code>对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Request(url地址, 配置)</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<p>尽量保证每次请求都是一个新的<code>Request</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;获得信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        req = <span class="keyword">new</span> Request(url, &#123;&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(req);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo())</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;得到所有的省份数据&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        req = <span class="keyword">new</span> Request(url, &#123;&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(req);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// const resp = await fetch(getRequestInfo())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resp = <span class="keyword">new</span> Response(<span class="string">`[</span></span><br><span class="line"><span class="string">    &#123;&quot;id&quot;:1, &quot;name&quot;:&quot;北京&quot;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;天津&quot;&#125;</span></span><br><span class="line"><span class="string">]`</span>, &#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h3><blockquote>
<p>在<strong>Request</strong>和<strong>Response</strong>对象内部，会将传递的请求头对象，转换为<strong>Headers</strong></p>
</blockquote>
<p><strong>Headers</strong>对象中的方法：</p>
<ul>
<li>**has(key)**：检查请求头中是否存在指定的key值</li>
<li><strong>get(key)</strong>: 得到请求头中对应的key值</li>
<li>**set(key, value)**：修改对应的键值对</li>
<li>**append(key, value)**：添加对应的键值对</li>
<li>**keys()**：得到所有的请求头键的集合</li>
<li>**values()**：得到所有的请求头中的值的集合</li>
<li>**entries()**：得到所有请求头中的键值对的集合</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;获得信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCommonHeaders</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHeaders</span>(<span class="params">headers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> datas = headers.entries();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> datas) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;pair[<span class="number">0</span>]&#125;</span>，value: <span class="subst">$&#123;pair[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">&quot;http://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        <span class="keyword">const</span> headers = getCommonHeaders();</span><br><span class="line">        headers.set(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>)</span><br><span class="line">        req = <span class="keyword">new</span> Request(url, &#123;</span><br><span class="line">            headers</span><br><span class="line">        &#125;);</span><br><span class="line">        printHeaders(headers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo())</span><br><span class="line">    printHeaders(resp.headers);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getProvinces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>流程：</p>
<ol>
<li>客户端将文件数据发送给服务器</li>
<li>服务器保存上传的文件数据到服务器端</li>
<li>服务器响应给客户端一个文件访问地址</li>
</ol>
<blockquote>
<p>测试地址：<a target="_blank" rel="noopener" href="http://101.132.72.36:5100/api/upload">http://101.132.72.36:5100/api/upload</a><br>键的名称（表单域名称）：<strong>imagefile</strong></p>
</blockquote>
<p>请求方法：<code>POST</code><br>请求的表单格式：<code>multipart</code> / <code>form-data</code><br>请求体中必须包含一个键值对，键的名称是服务器要求的名称，值是文件数据</p>
<blockquote>
<p><code>HTML5</code>中，<code>JS</code>仍然无法随意的获取文件数据，但是可以获取到<code>input</code>元素中，被用户选中的文件数据<br>可以利用<code>HTML5</code>提供的<code>FormData</code>构造函数来创建请求体</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;&quot;</span> alt=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;imgAvatar&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">async function upload() &#123;</span></span><br><span class="line"><span class="xml">    const inp = document.getElementById(&quot;avatar&quot;);</span></span><br><span class="line"><span class="xml">    if (inp.files.length === 0) &#123;</span></span><br><span class="line"><span class="xml">        alert(&quot;请选择要上传的文件&quot;);</span></span><br><span class="line"><span class="xml">        return;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    const formData = new FormData(); //构建请求体</span></span><br><span class="line"><span class="xml">    formData.append(&quot;imagefile&quot;, inp.files[0]);</span></span><br><span class="line"><span class="xml">    const url = &quot;http://101.132.72.36:5100/api/upload&quot;</span></span><br><span class="line"><span class="xml">    const resp = await fetch(url, &#123;</span></span><br><span class="line"><span class="xml">        method: &quot;POST&quot;,</span></span><br><span class="line"><span class="xml">        body: formData //自动修改请求头</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">    const result = await resp.json();</span></span><br><span class="line"><span class="xml">    return result;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">document.querySelector(&quot;button&quot;).onclick = async function() &#123;</span></span><br><span class="line"><span class="xml">    const result = await upload();</span></span><br><span class="line"><span class="xml">    const img = document.getElementById(&quot;imgAvatar&quot;)</span></span><br><span class="line"><span class="xml">    img.src = result.path;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><ul>
<li><p>什么是迭代？</p>
<ul>
<li>从一个数据集合中按照一定的顺序，不断取出数据的过程</li>
</ul>
</li>
<li><p>迭代和遍历的区别？</p>
<ul>
<li>迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完</li>
<li>遍历强调的是要把整个数据依次全部取出</li>
</ul>
</li>
<li><p>迭代器</p>
<ul>
<li>对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象</li>
<li>依照与迭代模式的思想而实现，分为内部迭代器和外部迭代器</li>
<li>内部迭代器：<ul>
<li>本身是函数，该函数内部定义好迭代规则，完全接手整个迭代过程，外部迭代只需要一次初始调用</li>
<li><code> Array.prototype.forEach</code>，<code>jQuery.each</code>内部迭代器</li>
</ul>
</li>
<li>外部迭代器：<ul>
<li>本身是函数，执行返回迭代对象，迭代下一个元素必须显示调用，调用复杂度增加，但灵活性增加</li>
<li><code>function outerIterator() &#123;&#125;</code> 外部迭代器</li>
</ul>
</li>
</ul>
</li>
<li><p>迭代模式</p>
<ul>
<li><p>一种设计模式，用于统一迭代过程，并规范了迭代器规格：</p>
</li>
<li><p>迭代器应该具有得到下一个数据的能力</p>
</li>
<li><p>迭代器应该具有判断是否还有后续数据的能力</p>
</li>
<li><p>提供一种方法可以顺序获得聚合对象的各个元素，是一种最简单也最常见的设计模式，它可以让用户透过特定的接口寻访集合中的每一个元素而不用了解底层的实现</p>
</li>
</ul>
</li>
<li><p>迭代器目的：</p>
<ul>
<li>从迭代模式思想中可以看出，就是要标准化迭代操作</li>
<li>举个例子：服务端提供数组数据给前端，前端for循环遍历，但由于业务变化，使得数据结构发生变化，返回对象或者<code>set</code>、<code>map</code>，导致前端遍历代码大量重写</li>
<li>解决方案<ul>
<li><code>ES6</code>引入<code>Interator</code>，部署在<code>NodeList</code>、<code>arguments</code>、<code>Array</code>、<code>Set</code>、Map、字符串上等数据的Symbol。iterator属性</li>
<li><code>使得这些数据``iterable</code>可迭代了，能进行<code>for of</code>、<code>...</code>、、<code>Array.from</code>等操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="JS中的迭代器"><a href="#JS中的迭代器" class="headerlink" title="JS中的迭代器"></a>JS中的迭代器</h4><p>JS规定，如果一个对象具有<code>next</code>方法，并且该方法返回一个对象，该对象的格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: 值, <span class="attr">done</span>: 是否迭代完成&#125;</span><br></pre></td></tr></table></figure>

<p>则认为该对象是一个迭代器</p>
<p>含义：</p>
<ul>
<li><strong>next</strong>方法：用于得到下一个数据</li>
<li>返回的对象<ul>
<li><strong>value</strong>：下一个数据的值</li>
<li><strong>done：boolean</strong>，是否迭代完成</li>
</ul>
</li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li><p>```js<br>const arr = [1, 2, 3, 4, 5];<br>//迭代数组arr<br>const iterator = {</p>
<pre><code>i: 0, //当前的数组下标
next() &#123;
    var result = &#123;
        value: arr[this.i],
        done: this.i &gt;= arr.length
    &#125;
    this.i++;
    return result;
&#125;
</code></pre>
<p>}</p>
<p>//让迭代器不断的取出下一个数据，直到没有数据为止<br>let data = iterator.next();<br>while (!data.done) { //只要没有迭代完成，则取出数据</p>
<pre><code>console.log(data.value)
//进行下一次迭代
data = iterator.next();
</code></pre>
<p>}</p>
<p>console.log(“迭代完成”)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const arr1 = [1, 2, 3, 4, 5];</span><br><span class="line">  const arr2 = [6, 7, 8, 9];</span><br><span class="line">  </span><br><span class="line">  // 迭代器创建函数  iterator creator</span><br><span class="line">  function createIterator(arr) &#123;</span><br><span class="line">      let i = 0;//当前的数组下标</span><br><span class="line">      return &#123; </span><br><span class="line">          next() &#123;</span><br><span class="line">              var result = &#123;</span><br><span class="line">                  value: arr[i],</span><br><span class="line">                  done: i &gt;= arr.length</span><br><span class="line">              &#125;</span><br><span class="line">              i++;</span><br><span class="line">              return result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const iter1 = createIterator(arr1);</span><br><span class="line">  const iter2 = createIterator(arr2);</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br> // 依次得到斐波拉契数列前面n位的值<br>// 1 1 2 3 5 8 13 …..</p>
<p>//创建一个斐波拉契数列的迭代器<br>function createFeiboIterator() {</p>
<pre><code>let prev1 = 1,
    prev2 = 1, //当前位置的前1位和前2位
    n = 1; //当前是第几位

return &#123;
    next() &#123;
        let value;
        if (n &lt;= 2) &#123;
            value = 1;
        &#125; else &#123;
            value = prev1 + prev2;
        &#125;
        const result = &#123;
            value,
            done: false
        &#125;;
        prev2 = prev1;
        prev1 = result.value;
        n++;
        return result;
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>const iterator = createFeiboIterator();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 可迭代协议 与 for-of 循环</span><br><span class="line"></span><br><span class="line">#### 可迭代协议</span><br><span class="line"></span><br><span class="line">- **概念回顾**</span><br><span class="line">  - 迭代器(**iterator**)：一个具有`next`方法的对象，`next`方法返回下一个数据并且能指示是否迭代完成</span><br><span class="line">  - 迭代器创建函数（**iterator creator**）：一个返回迭代器的函数</span><br><span class="line"></span><br><span class="line">- **可迭代协议**</span><br><span class="line">  - **ES6**规定，如果一个对象具有知名符号属性```Symbol.iterator```，并且属性值是一个迭代器创建函数，则该对象是可迭代的（**iterable**）</span><br><span class="line"></span><br><span class="line">&gt; 思考：如何知晓一个对象是否是可迭代的？</span><br><span class="line">&gt; 思考：如何遍历一个可迭代对象？</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  //可迭代对象</span><br><span class="line">  var obj = &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: 2,</span><br><span class="line">      [Symbol.iterator]() &#123;</span><br><span class="line">          const keys = Object.keys(this);</span><br><span class="line">          let i = 0;</span><br><span class="line">          return &#123;</span><br><span class="line">              next: () =&gt; &#123;</span><br><span class="line">                  const propName = keys[i];</span><br><span class="line">                  const propValue = this[propName];</span><br><span class="line">                  const result = &#123;</span><br><span class="line">                      value: &#123;</span><br><span class="line">                          propName,</span><br><span class="line">                          propValue</span><br><span class="line">                      &#125;,</span><br><span class="line">                      done: i &gt;= keys.length</span><br><span class="line">                  &#125;</span><br><span class="line">                  i++;</span><br><span class="line">                  return result;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for (const item of obj) &#123;</span><br><span class="line">      console.log(item); // &#123;propName:&quot;a&quot;, propValue:1&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h4><p><strong>for-of</strong> 循环用于遍历可迭代对象，格式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代完成后循环结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">in</span> iterable)&#123;</span><br><span class="line">    <span class="comment">//iterable：可迭代对象</span></span><br><span class="line">    <span class="comment">//item：每次迭代得到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// const iterator = arr[Symbol.iterator]();</span></span><br><span class="line"><span class="comment">// let result = iterator.next();</span></span><br><span class="line"><span class="comment">// while (!result.done) &#123;</span></span><br><span class="line"><span class="comment">//     const item = result.value; //取出数据</span></span><br><span class="line"><span class="comment">//     console.log(item);</span></span><br><span class="line"><span class="comment">//     //下一次迭代</span></span><br><span class="line"><span class="comment">//     result = iterator.next();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// const iterator = divs[Symbol.iterator]()</span></span><br><span class="line"><span class="comment">// let result = iterator.next();</span></span><br><span class="line"><span class="comment">// while (!result.done) &#123;</span></span><br><span class="line"><span class="comment">//     const item = result.value; //取出数据</span></span><br><span class="line"><span class="comment">//     console.log(item);</span></span><br><span class="line"><span class="comment">//     //下一次迭代</span></span><br><span class="line"><span class="comment">//     result = iterator.next();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> divs) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="展开运算符与可迭代对象"><a href="#展开运算符与可迭代对象" class="headerlink" title="展开运算符与可迭代对象"></a>展开运算符与可迭代对象</h4><ul>
<li>展开运算符可以作用于可迭代对象，这样，就可以轻松的将可迭代对象转换为数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> propName = keys[i];</span><br><span class="line">                <span class="keyword">const</span> propValue = <span class="built_in">this</span>[propName];</span><br><span class="line">                <span class="keyword">const</span> result = &#123;</span><br><span class="line">                    <span class="attr">value</span>: &#123;</span><br><span class="line">                        propName,</span><br><span class="line">                        propValue</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">done</span>: i &gt;= keys.length</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...obj];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(...obj);</span><br></pre></td></tr></table></figure>

<h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 (Generator)"></a>生成器 (Generator)</h3><ul>
<li>什么是生成器？<ul>
<li>生成器是一个通过构造函数<strong>Generator</strong>创建的对象，生成器既是一个迭代器，同时又是一个可迭代对象</li>
</ul>
</li>
<li>如何创建生成器？<ul>
<li>生成器的创建，必须使用生成器函数（<strong>Generator Function</strong>）</li>
</ul>
</li>
<li>如何书写一个生成器函数呢？</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个生成器函数，该函数一定返回一个生成器，就是在function和函数名之间添加*号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>生成器函数内部是如何执行的？</p>
<ul>
<li>生成器函数内部是为了给生成器的每次迭代提供的数据</li>
<li>每次调用生成器的<code>next</code>方法，将导致生成器函数运行到下一个<code>yield</code>关键字位置</li>
<li><code>yield</code>是一个关键字，该关键字只能在生成器函数内部使用，表达“产生”一个迭代数据。</li>
<li>函数体内部<code>yield</code>表达式，产出不同的内部状态（值）</li>
<li>遇到<code>yield</code>即暂停</li>
</ul>
</li>
<li><p>有哪些需要注意的细节？</p>
<ul>
<li><p>生成器函数可以有返回值，返回值出现在第一次<code>done</code>为<code>true</code>时的<code>value</code>属性中</p>
</li>
<li><p>调用生成器的<code>next</code>方法时，可以传递参数，传递的参数会交给<code>yield</code>表达式的返回值</p>
</li>
<li><p>第一次调用<code>next</code>方法时，传参没有任何意义</p>
</li>
<li><p>在生成器函数内部，可以调用其他生成器函数，但是要注意加上<code>*</code>号</p>
</li>
<li><p><code>function</code>和函数名之间要带<code>*</code>星号</p>
</li>
</ul>
</li>
<li><p>生成器的其他<strong>API</strong></p>
<ul>
<li><strong>return</strong>方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束</li>
<li><strong>throw</strong>方法：调用该方法，可以在生成器中产生一个错误</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>```js<br>function* test() {<pre><code>console.log(&quot;第1次运行&quot;)
yield 1;
console.log(&quot;第2次运行&quot;)
yield 2;
console.log(&quot;第3次运行&quot;)
</code></pre>
}const generator = test();<br>// generator.next()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- ```js</span><br><span class="line">  const arr1 = [1, 2, 3, 4, 5];</span><br><span class="line">  const arr2 = [6, 7, 8, 9];</span><br><span class="line">  </span><br><span class="line">  // 迭代器创建函数  iterator creator</span><br><span class="line">  function* createIterator(arr) &#123;</span><br><span class="line">      for (const item of arr) &#123;</span><br><span class="line">          yield item;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const iter1 = createIterator(arr1);</span><br><span class="line">  const iter2 = createIterator(arr2);</span><br><span class="line">  // iter1/2.next()</span><br></pre></td></tr></table></figure></li>
<li>```js<br>//创建一个斐波拉契数列的迭代器<br>function* createFeiboIterator() {<pre><code>let prev1 = 1,
    prev2 = 1, //当前位置的前1位和前2位
    n = 1; //当前是第几位
while (true) &#123;
    if (n &lt;= 2) &#123;
        yield 1;
    &#125; else &#123;
        const newValue = prev1 + prev2
        yield newValue;
        prev2 = prev1;
        prev1 = newValue;
    &#125;
    n++;
&#125;
</code></pre>
}const iterator = createFeiboIterator();<br>// iterator.next()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- ```js</span><br><span class="line">  function* test() &#123;</span><br><span class="line">      console.log(&quot;第1次运行&quot;)</span><br><span class="line">      yield 1;</span><br><span class="line">      console.log(&quot;第2次运行&quot;)</span><br><span class="line">      yield 2;</span><br><span class="line">      console.log(&quot;第3次运行&quot;);</span><br><span class="line">      // 调用return，可以提前结束生成器函数，从而提前让整个迭代过程结束</span><br><span class="line">      return 10;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const generator = test();</span><br><span class="line">  // generator.next()</span><br></pre></td></tr></table></figure></li>
<li>```js<br> function* test() {<pre><code> console.log(&quot;函数开始&quot;)

 let info = yield 1;
 console.log(info)
 info = yield 2 + info;
 console.log(info)
</code></pre>
 }const generator = test();<br>// generator.next()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- ```js</span><br><span class="line">  function* t1()&#123;</span><br><span class="line">      yield &quot;a&quot;</span><br><span class="line">      yield &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function* test() &#123;</span><br><span class="line">      yield* t1();</span><br><span class="line">      yield 1;</span><br><span class="line">      yield 2;</span><br><span class="line">      yield 3;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const generator = test();</span><br><span class="line">  // generator.next()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>生成器，异步任务控制</p>
<ul>
<li>```js<br>function* task() {<pre><code>const d = yield 1;
console.log(d)
// //d : 1
const resp = yield fetch(&quot;http://101.132.72.36:5100/api/local&quot;)
const result = yield resp.json();
console.log(result);
</code></pre>
}run(task)function run(generatorFunc) {<pre><code>const generator = generatorFunc();
let result = generator.next(); //启动任务（开始迭代）, 得到迭代数据
handleResult();
//对result进行处理
function handleResult() &#123;
    if (result.done) &#123;
        return; //迭代完成，不处理
    &#125;
    //迭代没有完成，分为两种情况
    //1. 迭代的数据是一个Promise
    //2. 迭代的数据是其他数据
    if (typeof result.value.then === &quot;function&quot;) &#123;
        //1. 迭代的数据是一个Promise
        //等待Promise完成后，再进行下一次迭代
        result.value.then(data =&gt; &#123;
            result = generator.next(data)
            handleResult();
        &#125;)
    &#125; else &#123;
        //2. 迭代的数据是其他数据，直接进行下一次迭代
        result = generator.next(result.value)
        handleResult();
    &#125;
&#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 更多的集合类型</span><br><span class="line"></span><br><span class="line">### set 集合</span><br><span class="line"></span><br><span class="line">&gt; 一直以来，`JS`只能使用数组和对象来保存多个数据，缺乏像其他语言那样拥有丰富的集合类型。因此，`ES6`新增了两种集合类型（`set` 和 `map`），用于在不同的场景中发挥作用。</span><br><span class="line"></span><br><span class="line">**set用于存放不重复的数据**</span><br><span class="line"></span><br><span class="line">- 简介：`Set`是`ES6`提供给我们的构造函数，能够造出一种新的存储数据的结构</span><br><span class="line">- 特点：只有属性值，成员值唯一（不重复）</span><br><span class="line">- 用途：可以转成数组，其本身具备去重、交集、并集，差集的作用等</span><br><span class="line"></span><br><span class="line">- 如何创建**set**集合</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    new Set(); //创建一个没有任何内容的set集合</span><br><span class="line">    </span><br><span class="line">    new Set(iterable); //创建一个具有初始内容的set集合，内容来自于可迭代对象每一次迭代的结果</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如何对<code>set</code>集合进行后续操作</p>
<ul>
<li><strong>add(数据)</strong>: 添加一个数据到<code>set</code>集合末尾，如果数据已存在，则不进行任何操作<ul>
<li><code>set</code>使用<code>Object.is</code>的方式判断两个数据是否相同，但是，针对<code>+0</code>和<code>-0</code>，<code>set</code>认为是相等</li>
</ul>
</li>
<li><strong>has(数据)</strong>: 判断<code>set</code>中是否存在对应的数据</li>
<li>**delete(数据)**：删除匹配的数据，返回是否删除成功</li>
<li>**clear()**：清空整个<code>set</code>集合</li>
<li><strong>size</strong>: 获取<code>set</code>集合中的元素数量，只读属性，无法重新赋值</li>
</ul>
</li>
<li><p>如何与数组进行相互转换</p>
<ul>
<li><p>```js<br>const s = new Set([x,x,x,x,x]);<br>// set本身也是一个可迭代对象，每次迭代的结果就是每一项的值<br>const arr = […s];</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如何遍历</span><br><span class="line">  - 使用`for-of`循环</span><br><span class="line">  - 使用`set`中的实例方法`forEach`</span><br><span class="line"></span><br><span class="line">- 注意：`set`集合中不存在下标，因此`forEach`中的回调的第二个参数和第一个参数是一致的，均表示`set`中的每一项</span><br><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    const s1 = new Set();</span><br><span class="line">    console.log(s1);</span><br><span class="line">    </span><br><span class="line">    const s2 = new Set(&quot;asdfasfasf&quot;);</span><br><span class="line">    console.log(s2);</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const s1 = new Set();</p>
<p>s1.add(1);<br>s1.add(2);<br>s1.add(3);<br>s1.add(1); //无效<br>s1.add(+0);<br>s1.add(-0); //无效</p>
<p>// for (const item of s1) {<br>//     console.log(item)<br>// }</p>
<p>s1.forEach((item, index, s) =&gt; {</p>
<pre><code>console.log(item, index, s);
</code></pre>
<p>})<br>console.log(s1);<br>console.log(“总数为：”, s1.size);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const arr = [45, 7, 2, 2, 34, 46, 6, 57, 8, 55, 6, 46];</span><br><span class="line">  const result = [...new Set(arr)];</span><br><span class="line">  console.log(result);</span><br><span class="line">  </span><br><span class="line">  const str = &quot;asf23sdfgsdgfsafasdfasfasfasfsafsagfdsfg&quot;;</span><br><span class="line">  const s = [...new Set(str)].join(&quot;&quot;);</span><br><span class="line">  console.log(s);</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>// 两个数组的并集、交集、差集 （不能出现重复项），得到的结果是一个新数组<br>const arr1 = [33, 22, 55, 33, 11, 33, 5];<br>const arr2 = [22, 55, 77, 88, 88, 99, 99];</p>
<p>//并集<br>// const result = […new Set(arr1.concat(arr2))];<br>console.log(“并集”, […new Set([…arr1, …arr2])]);</p>
<p>const cross = […new Set(arr1)].filter(item =&gt; arr2.indexOf(item) &gt;= 0);<br>//交集<br>console.log(“交集”, cross)</p>
<p>//差集<br>// console.log(“差集”, […new Set([…arr1, …arr2])].filter(item =&gt; arr1.indexOf(item) &gt;= 0 &amp;&amp; arr2.indexOf(item) &lt; 0 || arr2.indexOf(item) &gt;= 0 &amp;&amp; arr1.indexOf(item) &lt; 0))<br>console.log(“差集”, […new Set([…arr1, …arr2])].filter(item =&gt; cross.indexOf(item) &lt; 0))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 手写Set</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">class MySet &#123;</span><br><span class="line">    constructor(iterator = []) &#123;</span><br><span class="line">        //验证是否是可迭代的对象</span><br><span class="line">        if (typeof iterator[Symbol.iterator] !== &quot;function&quot;) &#123;</span><br><span class="line">            throw new TypeError(`你提供的$&#123;iterator&#125;不是一个可迭代的对象`)</span><br><span class="line">        &#125;</span><br><span class="line">        this._datas = [];</span><br><span class="line">        for (const item of iterator) &#123;</span><br><span class="line">            this.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get size() &#123;</span><br><span class="line">        return this._datas.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(data) &#123;</span><br><span class="line">        if (!this.has(data)) &#123;</span><br><span class="line">            this._datas.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has(data) &#123;</span><br><span class="line">        for (const item of this._datas) &#123;</span><br><span class="line">            if (this.isEqual(data, item)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete(data) &#123;</span><br><span class="line">        for (let i = 0; i &lt; this._datas.length; i++) &#123;</span><br><span class="line">            const element = this._datas[i];</span><br><span class="line">            if (this.isEqual(element, data)) &#123;</span><br><span class="line">                //删除</span><br><span class="line">                this._datas.splice(i, 1);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clear() &#123;</span><br><span class="line">        this._datas.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *[Symbol.iterator]() &#123;</span><br><span class="line">        for (const item of this._datas) &#123;</span><br><span class="line">            yield item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forEach(callback) &#123;</span><br><span class="line">        for (const item of this._datas) &#123;</span><br><span class="line">            callback(item, item, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断两个数据是否相等</span><br><span class="line">     * @param &#123;*&#125; data1 </span><br><span class="line">     * @param &#123;*&#125; data2 </span><br><span class="line">     */</span><br><span class="line">    isEqual(data1, data2) &#123;</span><br><span class="line">        if (data1 === 0 &amp;&amp; data2 === 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return Object.is(data1, data2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><blockquote>
<p>键值对（key value pair）数据集合的特点：键不可重复</p>
</blockquote>
<ul>
<li><p><strong>map</strong>集合专门用于存储多个键值对数据。</p>
</li>
<li><p>在<strong>map</strong>出现之前，我们使用的是对象的方式来存储键值对，键是属性名，值是属性值。</p>
</li>
<li><p>使用对象存储有以下问题：</p>
<ul>
<li>键名只能是字符串</li>
<li>获取数据的数量不方便</li>
<li>键名容易跟原型上的名称冲突</li>
</ul>
</li>
<li><p>如何创建<strong>Map</strong></p>
<ul>
<li><p>```js<br>new Map(); //创建一个空的map<br>new Map(iterable); //创建一个具有初始内容的map，初始内容来自于可迭代对象每一次迭代的结果，但是，它要求每一次迭代的结果必须是一个长度为2的数组，数组第一项表示键，数组的第二项表示值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如何进行后续操作</span><br><span class="line">  - **size**：只读属性，获取当前`map`中键的数量</span><br><span class="line">  - set(键, 值)：设置一个键值对，键和值可以是任何类型</span><br><span class="line">    - 如果键不存在，则添加一项</span><br><span class="line">    - 如果键已存在，则修改它的值</span><br><span class="line">    - 比较键的方式和`set`相同</span><br><span class="line">  - **get(键)**: 根据一个键得到对应的值</span><br><span class="line">  - has(键)：判断某个键是否存在</span><br><span class="line">  - **delete(键)**：删除指定的键</span><br><span class="line">  - **clear()**: 清空`map`</span><br><span class="line"></span><br><span class="line">- 数组互相转换和**set**一样</span><br><span class="line"></span><br><span class="line">- 遍历</span><br><span class="line">  - **for-of**，每次迭代得到的是一个长度为2的数组</span><br><span class="line">  - **forEach**，通过回调函数遍历</span><br><span class="line">    - 参数`1`：每一项的值</span><br><span class="line">    - 参数`2`：每一项的键</span><br><span class="line">    - 参数`3`：**map**本身</span><br><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">     const mp1 = new Map([[&quot;a&quot;, 3], [&quot;b&quot;, 4], [&quot;c&quot;, 5]]);</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    mp1.set(obj, 6456);</span><br><span class="line">    mp1.set(&quot;a&quot;, &quot;abc&quot;);</span><br><span class="line">    mp1.set(obj, 111);</span><br><span class="line">    </span><br><span class="line">    console.log(mp1)</span><br><span class="line">    console.log(&quot;总数：&quot;, mp1.size);</span><br><span class="line">    console.log(&quot;get(&#x27;a&#x27;)&quot;, mp1.get(&quot;a&quot;));</span><br><span class="line">    console.log(&quot;has(&#x27;a&#x27;)&quot;, mp1.has(&quot;a&quot;));</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>const mp = new Map([</p>
<pre><code>[&quot;a&quot;, 3],
[&quot;c&quot;, 10],
[&quot;b&quot;, 4],
[&quot;c&quot;, 5]
</code></pre>
<p>]);<br>const result = […mp]<br>console.log(result);</p>
<p>// for (const [key, value] of mp) {<br>//     console.log(key, value)<br>// }</p>
<p>mp.forEach((value, key, mp) =&gt; {</p>
<pre><code>console.log(value, key, mp)
</code></pre>
<p>})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 手写Map</span><br><span class="line"></span><br><span class="line">#### ES6之实现Map</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">class MyMap &#123;</span><br><span class="line">    constructor(iterable = []) &#123;</span><br><span class="line">        //验证是否是可迭代的对象</span><br><span class="line">        if (typeof iterable[Symbol.iterator] !== &quot;function&quot;) &#123;</span><br><span class="line">            throw new TypeError(`你提供的$&#123;iterable&#125;不是一个可迭代的对象`)</span><br><span class="line">        &#125;</span><br><span class="line">        this._datas = [];</span><br><span class="line">        for (const item of iterable) &#123;</span><br><span class="line">            // item 也得是一个可迭代对象</span><br><span class="line">            if (typeof item[Symbol.iterator] !== &quot;function&quot;) &#123;</span><br><span class="line">                throw new TypeError(`你提供的$&#123;item&#125;不是一个可迭代的对象`);</span><br><span class="line">            &#125;</span><br><span class="line">            const iterator = item[Symbol.iterator]();</span><br><span class="line">            const key = iterator.next().value;</span><br><span class="line">            const value = iterator.next().value;</span><br><span class="line">            this.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set(key, value) &#123;</span><br><span class="line">        const obj = this._getObj(key);</span><br><span class="line">        if (obj) &#123;</span><br><span class="line">            //修改</span><br><span class="line">            obj.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            this._datas.push(&#123;</span><br><span class="line">                key,</span><br><span class="line">                value</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get(key) &#123;</span><br><span class="line">        const item = this._getObj(key);</span><br><span class="line">        if (item) &#123;</span><br><span class="line">            return item.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return undefined;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get size() &#123;</span><br><span class="line">        return this._datas.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete(key) &#123;</span><br><span class="line">        for (let i = 0; i &lt; this._datas.length; i++) &#123;</span><br><span class="line">            const element = this._datas[i];</span><br><span class="line">            if (this.isEqual(element.key, key)) &#123;</span><br><span class="line">                this._datas.splice(i, 1);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clear() &#123;</span><br><span class="line">        this._datas.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据key值从内部数组中，找到对应的数组项</span><br><span class="line">     * @param &#123;*&#125; key </span><br><span class="line">     */</span><br><span class="line">    _getObj(key) &#123;</span><br><span class="line">        for (const item of this._datas) &#123;</span><br><span class="line">            if (this.isEqual(item.key, key)) &#123;</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has(key) &#123;</span><br><span class="line">        return this._getObj(key) !== undefined;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断两个数据是否相等</span><br><span class="line">     * @param &#123;*&#125; data1 </span><br><span class="line">     * @param &#123;*&#125; data2 </span><br><span class="line">     */</span><br><span class="line">    isEqual(data1, data2) &#123;</span><br><span class="line">        if (data1 === 0 &amp;&amp; data2 === 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return Object.is(data1, data2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *[Symbol.iterator]() &#123;</span><br><span class="line">        for (const item of this._datas) &#123;</span><br><span class="line">            yield [item.key, item.value];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forEach(callback) &#123;</span><br><span class="line">        for (const item of this._datas) &#123;</span><br><span class="line">            callback(item.value, item.key, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const mp1 = new MyMap([</span><br><span class="line">    [&quot;a&quot;, 3],</span><br><span class="line">    [&quot;b&quot;, 4],</span><br><span class="line">    [&quot;c&quot;, 5]</span><br><span class="line">]);</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">mp1.set(obj, 6456);</span><br><span class="line">mp1.set(&quot;a&quot;, &quot;abc&quot;);</span><br><span class="line">mp1.set(obj, 111);</span><br><span class="line"></span><br><span class="line">// for (const item of mp1) &#123;</span><br><span class="line">//     console.log(item)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// const result = [...mp1];</span><br><span class="line">// console.log(result)</span><br><span class="line">mp1.forEach((a1, a2, a3) =&gt; &#123;</span><br><span class="line">    console.log(a1, a2, a3);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="ES5之实现Map"><a href="#ES5之实现Map" class="headerlink" title="ES5之实现Map"></a>ES5之实现Map</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原生Map特性</span></span><br><span class="line"><span class="comment">//1.不重复</span></span><br><span class="line"><span class="comment">//2.属性不只是字符串，还可以是 &#123;&#125; null [] function number</span></span><br><span class="line"><span class="comment">//3.实现方法 delete set get has clear </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myMap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//桶长度 = 8</span></span><br><span class="line">    <span class="built_in">this</span>.bucketLength = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">myMap.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//初始化 桶 长度8</span></span><br><span class="line">    <span class="built_in">this</span>.bucket = <span class="keyword">new</span> <span class="built_in">Array</span>( <span class="built_in">this</span>.bucketLength );</span><br><span class="line">    <span class="comment">//循环遍历桶添加初始化值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="built_in">this</span>.bucket.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.bucket[i] = &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;bucket&#x27;</span> + i,</span><br><span class="line">            <span class="attr">next</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash算法</span></span><br><span class="line"><span class="comment">//1. [0,8]</span></span><br><span class="line"><span class="comment">//2. 重复算值固定</span></span><br><span class="line">myMap.prototype.makeHash = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// key 可能是 string number boolean null  NaN [] &#123;&#125; function()&#123;&#125; undefine</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> key !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为数字，hash直接等于key</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> key == <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//number NaN</span></span><br><span class="line">            <span class="comment">//判断key是否等于NaN</span></span><br><span class="line">            hash = <span class="built_in">Object</span>.is(key,<span class="literal">NaN</span>) ? <span class="number">0</span> : key;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> key == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//null &#123;&#125; [] </span></span><br><span class="line">            hash = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> key == <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//true 1  |  false 0</span></span><br><span class="line">            hash += key;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//undefine function() &#123;&#125;</span></span><br><span class="line">            hash = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//string</span></span><br><span class="line">        <span class="comment">//&#x27;a&#x27; &#x27;ab&#x27; &#x27;....很多个字符&#x27;</span></span><br><span class="line">        <span class="comment">//长度大于等于3，取字符串前三个字符的ascii，累加 取余 变为0-8（规则由自己定义）</span></span><br><span class="line">        <span class="comment">//长度不大于3时，就取长度位数进行计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//判断如果字符没有第三位时返回0，有时就返回该位的ascii码</span></span><br><span class="line">            hash += key[i] ? key[i].charCodeAt(<span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">8</span>; <span class="comment">//生成0-8范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line">myMap.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line">    <span class="comment">//循环条件，oTempBucket.next是否有值</span></span><br><span class="line">    <span class="keyword">while</span>(oTempBucket.next) &#123;</span><br><span class="line">        <span class="comment">//如果next中的值与传入的值相同，那么就让next的value等于传入的value</span></span><br><span class="line">        <span class="keyword">if</span> (oTempBucket.next.key == key) &#123;</span><br><span class="line">            oTempBucket.next.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果在key不等于next.key，就让oTempBucket自己等于自己的下一个，再次循环比较</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//给最后一个oTempBucket添加值</span></span><br><span class="line">    oTempBucket.next = &#123;</span><br><span class="line">        <span class="attr">key</span>: key,</span><br><span class="line">        <span class="attr">value</span>: value,</span><br><span class="line">        <span class="attr">next</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line">myMap.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line">    <span class="comment">//循环条件，oTempBucket.next是否有值</span></span><br><span class="line">    <span class="keyword">while</span>(oTempBucket.next) &#123;</span><br><span class="line">        <span class="comment">//如果next中的值与传入的值相同，那么就返回next中的value</span></span><br><span class="line">        <span class="keyword">if</span>(oTempBucket.next.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> oTempBucket.next.value;</span><br><span class="line">        <span class="comment">//如果在key不等于next.key，就让oTempBucket自己等于自己的下一个，再次循环比较</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果oTempBucket.next没有值，直接返回undefine</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delete方法</span></span><br><span class="line">myMap.prototype.delete = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line">    <span class="comment">//循环条件，oTempBucket.next是否有值</span></span><br><span class="line">    <span class="keyword">while</span> (oTempBucket.next) &#123;</span><br><span class="line">        <span class="comment">//如果next中的值与传入的值相同，那么就将next的指向改变为next.next</span></span><br><span class="line">        <span class="keyword">if</span>(oTempBucket.next.key == key) &#123;</span><br><span class="line">            oTempBucket.next = oTempBucket.next.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果传入的key不等于next.key，就让oTempBucket自己等于自己的下一个，再次循环比较</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//has方法</span></span><br><span class="line">myMap.prototype.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="built_in">this</span>.makeHash(key);</span><br><span class="line">    <span class="comment">//获取桶的序号</span></span><br><span class="line">    <span class="keyword">let</span> oTempBucket = <span class="built_in">this</span>.bucket[hash];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(oTempBucket.next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(oTempBucket.next.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oTempBucket = oTempBucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear方法</span></span><br><span class="line">myMap.prototype.clear = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oMp = <span class="keyword">new</span> myMap();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;yzl&#x27;</span>&#125;;</span><br><span class="line">oMp.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;yzl&#x27;</span>);</span><br><span class="line">oMp.set(<span class="string">&#x27;name1&#x27;</span>,<span class="string">&#x27;yzl&#x27;</span>);</span><br><span class="line">oMp.set(obj,<span class="string">&#x27;----&#x27;</span>);</span><br><span class="line">oMp.set(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="string">&#x27;----&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="WeakSet-和-WeakMap"><a href="#WeakSet-和-WeakMap" class="headerlink" title="WeakSet 和 WeakMap"></a>WeakSet 和 WeakMap</h3><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>使用该集合，可以实现和<strong>set</strong>一样的功能，不同的是：</p>
<ol>
<li><p><strong>它内部存储的对象地址不会影响垃圾回收</strong></p>
</li>
<li><p>只能添加对象</p>
</li>
<li><p>不能遍历（不是可迭代的对象）、没有<code>size</code>属性、没有<code>forEach</code>方法</p>
</li>
<li><p>```js<br> let obj = {</p>
<pre><code> name: &quot;yj&quot;,
 age: 18
</code></pre>
<p> };<br>let obj2 = obj;<br>const set = new WeakSet();<br>set.add(obj);</p>
<p>obj = null;<br>obj2 = null;<br>console.log(set)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### WeakMap</span><br><span class="line"></span><br><span class="line">类似于**map**的集合，不同的是：</span><br><span class="line"></span><br><span class="line">1. **它的键存储的地址不会影响垃圾回收**</span><br><span class="line"></span><br><span class="line">2. 它的键只能是对象</span><br><span class="line"></span><br><span class="line">3. 不能遍历（不是可迭代的对象）、没有`size`属性、没有`forEach`方法</span><br><span class="line"></span><br><span class="line">4. ```html</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">   &lt;!-- &#123; id:&quot;1&quot;, name:&quot;姓名1&quot; &#125; --&gt;</span><br><span class="line">       &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">   &lt;!-- &#123; id:&quot;2&quot;, name:&quot;姓名2&quot; &#125; --&gt;</span><br><span class="line">       &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">   &lt;!-- &#123; id:&quot;3&quot;, name:&quot;姓名3&quot; &#125; --&gt;</span><br><span class="line">       &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;script&gt;</span><br><span class="line">       const wmap = new WeakMap();</span><br><span class="line">       let lis = document.querySelectorAll(&quot;li&quot;);</span><br><span class="line">       for (const li of lis) &#123;</span><br><span class="line">           wmap.set(li, &#123;</span><br><span class="line">               id: li.innerHTML,</span><br><span class="line">               name: `姓名$&#123;li.innerHTML&#125;`</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       lis[0].remove();</span><br><span class="line">       lis = null;</span><br><span class="line">   </span><br><span class="line">       console.log(wmap);</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h2><h3 id="【回顾】属性描述符"><a href="#【回顾】属性描述符" class="headerlink" title="【回顾】属性描述符"></a>【回顾】属性描述符</h3><ul>
<li><p><strong>Property Descriptor</strong> 属性描述符  是一个普通对象，用于描述一个属性的相关信息</p>
</li>
<li><p>通过<code>Object.getOwnPropertyDescriptor(对象, 属性名)</code>可以得到一个对象的某个属性的属性描述符</p>
<ul>
<li><strong>value</strong>：属性值</li>
<li><strong>configurable</strong>：该属性的描述符是否可以修改</li>
<li><strong>enumerable</strong>：该属性是否可以被枚举</li>
<li><strong>writable</strong>：该属性是否可以被重新赋值</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如果需要为某个对象添加属性时 或 修改属性时， 配置其属性描述符，可以使用下面的代码:</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">Object.defineProperty(对象, 属性名, 描述符);</span><br><span class="line">Object.defineProperties(对象, 多个属性的描述符)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h4><ul>
<li><p>属性描述符中，如果配置了 <code>get</code> 和 <code>set</code> 中的任何一个，则该属性，不再是一个普通属性，而变成了存取器属性。</p>
</li>
<li><p><code>get</code> 和 <code>set</code>配置均为函数，如果一个属性是存取器属性，则读取该属性时，会运行<code>get</code>方法，将<code>get</code>方法得到的返回值作为属性值；如果给该属性赋值，则会运行<code>set</code>方法。</p>
</li>
<li><p>存取器属性最大的意义，在于可以控制属性的读取和赋值。</p>
</li>
</ul>
<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><ul>
<li><p>```js<br> const obj = {</p>
<pre><code> a: 1,
 b: 2
</code></pre>
<p> }</p>
<p> // Object.defineProperty(obj, “a”, {<br> //     value: 3,<br> //     configurable: false,<br> //     enumerable: false,<br> //     writable: false<br> // })</p>
<p> Object.defineProperties(obj, {</p>
<pre><code> a: &#123;
     value: 3,
     configurable: false,
     enumerable: false,
     writable: false
 &#125;
</code></pre>
<p> })</p>
<p>obj.a = 10;<br>console.log(obj);</p>
<p>// console.log(obj)<br>// // for (const prop in obj) {<br>// //     console.log(prop);<br>// // }</p>
<p>// const props = Object.keys(obj)<br>// console.log(props)</p>
<p>// const values = Object.values(obj);<br>// console.log(values);</p>
<p>// const desc = Object.getOwnPropertyDescriptor(obj, “a”)</p>
<p>// console.log(desc);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const obj = &#123;</span><br><span class="line">      b: 2</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(obj, &quot;a&quot;, &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">          console.log(&quot;运行了属性a的get函数&quot;)</span><br><span class="line">          return obj._a;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(val)&#123;</span><br><span class="line">          console.log(&quot;运行了属性a的set函数&quot;, val)</span><br><span class="line">          obj._a = val;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // obj.a = 20 + 10; // set(20 + 10)</span><br><span class="line">  // console.log(obj.a); // console.log(get())</span><br><span class="line">  </span><br><span class="line">  // obj.a = obj.a + 1; // set(obj.a + 1)   set(get() + 1)</span><br><span class="line">  // console.log(obj.a);</span><br><span class="line">  </span><br><span class="line">  // console.log(obj.a)</span><br><span class="line">  </span><br><span class="line">  obj.a = 10;</span><br><span class="line">  console.log(obj.a);</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>obj = {</p>
<pre><code>name: &quot;adsf&quot;
</code></pre>
<p>}</p>
<p>Object.defineProperty(obj, “age”, {</p>
<pre><code>get() &#123;
    return obj._age;
&#125;,
set(val) &#123;
    if (typeof val !== &quot;number&quot;) &#123;
        throw new TypeError(&quot;年龄必须是一个数字&quot;)
    &#125;
    if (val &lt; 0) &#123;
        val = 0;
    &#125; else if (val &gt; 200) &#123;
        val = 200;
    &#125;
    obj._age = val;
&#125;
</code></pre>
<p>})</p>
<p>obj.age = “Asdfasasdf”;<br>console.log(obj.age);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">      &lt;span&gt;姓名：&lt;/span&gt;</span><br><span class="line">  &lt;span id=&quot;name&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">      &lt;span&gt;年龄：&lt;/span&gt;</span><br><span class="line">  &lt;span id=&quot;age&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">      const spanName = document.getElementById(&quot;name&quot;)</span><br><span class="line">  const spanAge = document.getElementById(&quot;age&quot;)</span><br><span class="line">  </span><br><span class="line">  const user = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  Object.defineProperties(user, &#123;</span><br><span class="line">      name: &#123;</span><br><span class="line">          get() &#123;</span><br><span class="line">              return spanName.innerText;</span><br><span class="line">          &#125;,</span><br><span class="line">          set(val) &#123;</span><br><span class="line">              spanName.innerText = val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      age: &#123;</span><br><span class="line">          get() &#123;</span><br><span class="line">              return +spanAge.innerText;</span><br><span class="line">          &#125;,</span><br><span class="line">          set(val) &#123;</span><br><span class="line">              if (typeof val !== &quot;number&quot;) &#123;</span><br><span class="line">                  throw new TypeError(&quot;年龄必须是一个数字&quot;)</span><br><span class="line">              &#125;</span><br><span class="line">              if (val &lt; 0) &#123;</span><br><span class="line">                  val = 0;</span><br><span class="line">              &#125; else if (val &gt; 200) &#123;</span><br><span class="line">                  val = 200;</span><br><span class="line">              &#125;</span><br><span class="line">              spanAge.innerText = val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul>
<li><p><strong>Reflect</strong>是什么？</p>
<ul>
<li><code>Reflect</code>是一个内置的<code>JS</code>对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些<code>JS</code>底层功能</li>
<li>由于它类似于其他语言的<strong>反射</strong>，因此取名为<code>Reflect</code></li>
</ul>
</li>
<li><p>它可以做什么？</p>
<ul>
<li>使用<code>Reflect</code>可以实现诸如 属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中  等等功能</li>
</ul>
</li>
<li><p>这些功能不是已经存在了吗？为什么还需要用<code>Reflect</code>实现一次？</p>
<ul>
<li>有一个重要的理念，在<code>ES5</code>就被提出：减少魔法、让代码更加纯粹</li>
<li>这种理念很大程度上是受到函数式编程的影响</li>
<li><code>ES6</code>进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的<code>API</code>，并高度聚合到某个对象中，于是，就造就了<code>Reflect</code>对象</li>
<li>因此，你可以看到<code>Reflect</code>对象中有很多的<code>API</code>都可以使用过去的某种语法或其他<code>API</code>实现。</li>
</ul>
</li>
<li><p>它里面到底提供了哪些<code>API</code>呢？</p>
<ul>
<li><strong>Reflect.set(target, propertyKey, value)</strong>: 设置对象<code>target</code>的属性<code>propertyKey</code>的值为<code>value</code>，等同于给对象的属性赋值</li>
<li><strong>Reflect.get(target, propertyKey)</strong>: 读取对象<code>target</code>的属性<code>propertyKey</code>，等同于读取对象的属性值</li>
<li>**Reflect.apply(target, thisArgument, argumentsList)**：调用一个指定的函数，并绑定this和参数列表。等同于函数调用</li>
<li>**Reflect.deleteProperty(target, propertyKey)**：删除一个对象的属性</li>
<li>**Reflect.defineProperty(target, propertyKey, attributes)**：类似于<code>Object.defineProperty</code>，不同的是如果配置出现问题，返回false而不是报错</li>
<li>**Reflect.construct(target, argumentsList)**：用构造函数的方式创建一个对象</li>
<li><strong>Reflect.has(target, propertyKey)</strong>: 判断一个对象是否拥有一个属性</li>
<li>其他<strong>API</strong>：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>```js<br>const obj = {<pre><code>a: 1,
b: 2
</code></pre>
}// obj.a = 10;Reflect.set(obj, “a”, 10);console.log(Reflect.get(obj, “a”))<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  // function method(a, b)&#123;</span><br><span class="line">  //     console.log(&quot;method&quot;, a, b);</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line">  // // method(3, 4);</span><br><span class="line">  </span><br><span class="line">  // Reflect.apply(method, null, [3, 4])</span><br><span class="line">  </span><br><span class="line">  // const obj = &#123;</span><br><span class="line">  //     a: 1,</span><br><span class="line">  //     b: 2</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line">  // // delete obj.a;</span><br><span class="line">  </span><br><span class="line">  // Reflect.deleteProperty(obj, &quot;a&quot;);</span><br><span class="line">  </span><br><span class="line">  // console.log(obj);</span><br><span class="line">  </span><br><span class="line">  // function Test(a, b) &#123;</span><br><span class="line">  //     this.a = a;</span><br><span class="line">  //     this.b = b;</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line">  // // const t = new Test(1, 3);</span><br><span class="line">  // const t = Reflect.construct(Test, [1, 3]);</span><br><span class="line">  // console.log(t)</span><br><span class="line">  </span><br><span class="line">  const obj = &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: 2</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // console.log(&quot;a&quot; in obj);</span><br><span class="line">  console.log(Reflect.has(obj, &quot;a&quot;));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><blockquote>
<p>代理：提供了修改底层实现的方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理一个目标对象</span></span><br><span class="line"><span class="comment">//target：目标对象</span></span><br><span class="line"><span class="comment">//handler：是一个普通对象，其中可以重写底层实现</span></span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, propertyKey, value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(target, propertyKey, value);</span></span><br><span class="line">        <span class="comment">// target[propertyKey] = value;</span></span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, propertyKey, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, propertyKey</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(target, propertyKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propertyKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">target, propertyKey</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// console.log(proxy);</span></span><br><span class="line"><span class="comment">// proxy.a = 10;</span></span><br><span class="line"><span class="comment">// console.log(proxy.a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.d);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> proxy);</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>有一个对象，是观察者，它用于观察另外一个对象的属性值变化，当属性值变化后会收到一个通知，可能会做一些事。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.container</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> ob = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="built_in">Object</span>.keys(target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> props) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(ob, prop, &#123;</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> target[prop];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">                target[prop] = val;</span><br><span class="line">                render();</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(ob)) &#123;</span><br><span class="line">            html += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;span&gt;<span class="subst">$&#123;prop&#125;</span>：&lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;ob[prop]&#125;</span>&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        div.innerHTML = html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = observer(target)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.container</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target, prop, value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">Reflect</span>.set(target, prop, value);</span><br><span class="line">            render();</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    render();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(target)) &#123;</span><br><span class="line">            html += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;span&gt;<span class="subst">$&#123;prop&#125;</span>：&lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;target[prop]&#125;</span>&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        div.innerHTML = html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = observer(target)</span><br></pre></td></tr></table></figure>

<h3 id="偷懒的构造函数"><a href="#偷懒的构造函数" class="headerlink" title="偷懒的构造函数"></a>偷懒的构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorProxy</span>(<span class="params">Class, ...propNames</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(Class, &#123;</span><br><span class="line">        <span class="function"><span class="title">construct</span>(<span class="params">target, argumentsList</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> obj = <span class="built_in">Reflect</span>.construct(target, argumentsList)</span><br><span class="line">            propNames.forEach(<span class="function">(<span class="params">name, i</span>) =&gt;</span> &#123;</span><br><span class="line">                obj[name] = argumentsList[i];</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserProxy = ConstructorProxy(User, <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> UserProxy(<span class="string">&quot;袁&quot;</span>, <span class="string">&quot;进&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MonsterProxy = ConstructorProxy(Monster, <span class="string">&quot;attack&quot;</span>, <span class="string">&quot;defence&quot;</span>, <span class="string">&quot;hp&quot;</span>, <span class="string">&quot;rate&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MonsterProxy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">30</span>, <span class="string">&quot;怪物&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>

<h3 id="可验证的函数参数"><a href="#可验证的函数参数" class="headerlink" title="可验证的函数参数"></a>可验证的函数参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validatorFunction</span>(<span class="params">func, ...types</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, &#123;</span><br><span class="line">        <span class="function"><span class="title">apply</span>(<span class="params">target, thisArgument, argumentsList</span>)</span> &#123;</span><br><span class="line">            types.forEach(<span class="function">(<span class="params">t, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> arg = argumentsList[i]</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== t) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`第<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>个参数<span class="subst">$&#123;argumentsList[i]&#125;</span>不满足类型<span class="subst">$&#123;t&#125;</span>`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target, thisArgument, argumentsList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = validatorFunction(sum, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validatorFunction</span>(<span class="params">func, ...types</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...argumentsList</span>) </span>&#123;</span><br><span class="line">        types.forEach(<span class="function">(<span class="params">t, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> arg = argumentsList[i]</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`第<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>个参数<span class="subst">$&#123;argumentsList[i]&#125;</span>不满足类型<span class="subst">$&#123;t&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> func(...argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = validatorFunction(sum, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="增强的数组功能"><a href="#增强的数组功能" class="headerlink" title="增强的数组功能"></a>增强的数组功能</h2><h3 id="新增的数组API"><a href="#新增的数组API" class="headerlink" title="新增的数组API"></a>新增的数组API</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul>
<li><strong>Array.of(…args)</strong>: 使用指定的数组项创建一个新数组</li>
<li><strong>Array.from(arg)</strong>: 通过给定的类数组或可迭代对象 创建一个新的数组。</li>
</ul>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul>
<li><strong>find(callback)</strong>: 用于查找满足条件的第一个元素</li>
<li>**findIndex(callback)**：用于查找满足条件的第一个元素的下标</li>
<li>**fill(data)**：用指定的数据填充满数组所有的内容</li>
<li><strong>copyWithin(target, start?, end?)</strong>: 在数组内部完成复制</li>
<li>**includes(data)**：判断数组中是否包含某个值，使用<code>Object.is</code>匹配</li>
</ul>
<h3 id="扩展-类型化数组"><a href="#扩展-类型化数组" class="headerlink" title="[扩展]类型化数组"></a>[扩展]类型化数组</h3><h4 id="数字存储的前置知识"><a href="#数字存储的前置知识" class="headerlink" title="数字存储的前置知识"></a>数字存储的前置知识</h4><ul>
<li>计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的。</li>
<li><code>n</code>位的无符号整数能表示的数字是<code>2^n</code>个，取值范围是：<code>0 ~ 2^n - 1</code></li>
<li><code>n</code>位的有符号整数能表示的数字是<code>2^n</code>个，取值范围是：<code>-2^(n-1) ~ 2^(n-1) - 1</code></li>
<li>浮点数表示法可以用于表示整数和小数，目前分为两种标准：<ul>
<li><code>32</code>位浮点数：又称为单精度浮点数，它用<code>1</code>位表示符号，<code>8</code>位表示阶码，<code>23</code>位表示尾数</li>
<li><code>64</code>位浮点数：又称为双精度浮点数，它用<code>1</code>位表示符号，<code>11</code>位表示阶码，<code>52</code>位表示尾数</li>
</ul>
</li>
<li><code>JS</code>中的所有数字，均使用双精度浮点数保存</li>
</ul>
<h4 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h4><p>类型化数组：用于优化多个数字的存储</p>
<p>具体分为：</p>
<ul>
<li><p><strong>Int8Array</strong>： <code>8</code>位有符号整数（<code>-128 ~ 127</code>）</p>
</li>
<li><p><strong>Uint8Array</strong>： <code>8</code>位无符号整数（<code>0 ~ 255</code>）</p>
</li>
<li><p><strong>Int16Array</strong>: …</p>
</li>
<li><p><strong>Uint16Array</strong>: …</p>
</li>
<li><p><strong>Int32Array</strong>: …</p>
</li>
<li><p><strong>Uint32Array</strong>: …</p>
</li>
<li><p><strong>Float32Array</strong>:</p>
</li>
<li><p><strong>Float64Array</strong></p>
</li>
<li><p>如何创建数组</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(长度)</span><br><span class="line"></span><br><span class="line">数组构造函数.of(元素...)</span><br><span class="line"></span><br><span class="line">数组构造函数.from(可迭代对象)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(其他类型化数组)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>得到长度</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组.length   <span class="comment">//得到元素数量</span></span><br><span class="line">数组.byteLength <span class="comment">//得到占用的字节数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他的用法跟普通数组一致，但是：<ul>
<li>不能增加和删除数据，类型化数组的长度固定</li>
<li>一些返回数组的方法，返回的数组是同类型化的新数组</li>
</ul>
</li>
</ul>
<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const arr = new Int32Array(10);</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Uint8Array</span>.of(<span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// console.log(arr.length);</span></span><br><span class="line"><span class="comment">// console.log(arr.byteLength);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Int32Array</span>.of(<span class="number">35111</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(arr1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1, arr2);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Int8Array</span>.of(<span class="number">125</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">const</span> arr2 = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[1] = 100;</span></span><br><span class="line"><span class="comment">// console.log(arr);</span></span><br><span class="line"><span class="comment">// console.log(arr[1])</span></span><br><span class="line"><span class="comment">// for (const item of arr) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(item)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[4] = 1000; //无效</span></span><br><span class="line"><span class="comment">// delete arr[0]; //无效</span></span><br><span class="line"><span class="comment">// console.log(arr)</span></span><br></pre></td></tr></table></figure>

<h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><blockquote>
<p><strong>ArrayBuffer</strong>：一个对象，用于存储一块固定内存大小的数据。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(字节数)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过属性<code>byteLength</code>得到字节数，可以通过方法<code>slice</code>得到新的<code>ArrayBuffer</code></li>
</ul>
<h4 id="读写ArrayBuffer"><a href="#读写ArrayBuffer" class="headerlink" title="读写ArrayBuffer"></a>读写ArrayBuffer</h4><ul>
<li><p>使用<strong>DataView</strong></p>
<ul>
<li>通常会在需要混用多种存储格式时使用<code>DataView</code></li>
</ul>
</li>
<li><p>使用类型化数组</p>
</li>
<li><p>实际上，每一个类型化数组都对应一个<code>ArrayBuffer</code>，如果没有手动指定<code>ArrayBuffer</code>，类型化数组创建时，会新建一个<code>ArrayBuffer</code></p>
</li>
<li><p>练习</p>
<ul>
<li><p>```js<br>//创建了一个用于存储10个字节的内存空间<br>const bf = new ArrayBuffer(10);</p>
<p>const bf2 = bf.slice(3, 5);</p>
<p>console.log(bf, bf2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  //创建了一个用于存储10个字节的内存空间</span><br><span class="line">  const bf = new ArrayBuffer(10);</span><br><span class="line">  </span><br><span class="line">  const view = new DataView(bf, 3, 4);</span><br><span class="line">  </span><br><span class="line">  // console.log(view);</span><br><span class="line">  </span><br><span class="line">  view.setInt16(1, 3);</span><br><span class="line">  console.log(view);</span><br><span class="line">  </span><br><span class="line">  console.log(view.getInt16(1));</span><br></pre></td></tr></table></figure></li>
<li><p>```js<br> const bf = new ArrayBuffer(10); //10个字节的内存</p>
<p>const arr1 = new Int8Array(bf);<br>const arr2 = new Int16Array(bf);<br>console.log(arr1 === arr2);<br>console.log(arr1.buffer === arr2.buffer);</p>
<p>arr1[0] = 10;</p>
<p>console.log(arr1)<br>console.log(arr2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  const bf = new ArrayBuffer(10); //10个字节的内存</span><br><span class="line">  const arr = new Int16Array(bf);</span><br><span class="line">  arr[0] = 2344; //操作了两个字节</span><br><span class="line">  console.log(arr);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      </div>
    
  </div>

</article>

<button class="assist-btn2 circle" id="assist_btn2" title="点亮屏幕" style="left: 27px; top: 152px;">
  <i class="iconfont" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
</button>
<button class="assist-btn1 circle" id="assist_btn1" title="关闭屏幕亮度" style="left: 27px; top: 152px;">
  <i class="iconfont toc-title" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
</button>


<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>	


<!-- 微信公众号引流 openwrite.cn -->
<!-- 
<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
  const btw = new BTWPlugin();
  btw.init({
    id: "container",
    blogId: "",
    name: "前端之旅",
    qrcode: "https://poetries1.gitee.io/img-repo/2020/06/qrcode.jpg",
    keyword: "3a3b3c",
  });
</script> -->

<script type="text/javascript">

// white theme
var body = {color: "#555", background: "#000"};
var a_tag = {color: "#222"};
var header = { background: "#222"};
var logo_line_i = {background: "#222"};
// var post_code = {background: "#eee", color: "#222"};

function switch_theme() {
 $("body").css(body);
 $("a:not('.links-of-author-item a, .site-state-item a, .site-state-posts a, .feed-link a, .motion-element a, .post-tags a, .show-commit-cls a, #donate_board a')").css(a_tag);
 $(".header, .footer").css(header);
 $(".logo-line-before i, .logo-line-after i").css(logo_line_i);
 //$(".post code").css(post_code);
 $("#idhyt-surprise-ball #idhyt-surprise-ball-animation .drag").css(a_tag);
 $(".post-title-link, .posts-expand .post-meta, .post-comments-count, .disqus-comment-count, .post-category a, .post-nav-next a, .post-nav-item a").css(a_tag);
 
 // $("code").css({color: '#c5c8c6', background: '#1d1f21'});
 //$("#assist_btn1").hide(1500);
}

$(function () {
$("#assist_btn2").css("display","none");
 $("#assist_btn1").click(function() {
     switch_theme();
$("div#toc.toc-article").css({
 "background":"#eaeaea",
 "opacity":1
});
$(".toc-article ol").show();
$("#toc.toc-article .toc-title").css("color","#a98602");
$("#assist_btn1").css("display","none");
$("#assist_btn2").css("display","block");
 });
$("#assist_btn2").click(function() {
$("#assist_btn2").css("display","none");
$("#assist_btn1").css("display","block");
$("body").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
     $(".header, .footer").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
$(".toc-article ol").toggle(1000);
 });
});


//背景随机

var Y, O, E, L, B, C, T, z, N, S, A, I;
!function() {
var e = function() {
for (O.clearRect(0, 0, L, B), T = [{
x: 0,
y: .7 * B + C
}, {
x: 0,
y: .7 * B - C
}]; T[1].x < L + C;) t(T[0], T[1])
}, t = function(e, t) {
O.beginPath(), O.moveTo(e.x, e.y), O.lineTo(t.x, t.y);
var n = t.x + (2 * I() - .25) * C,
 r = a(t.y);
O.lineTo(n, r), O.closePath(), N -= S / -50, O.fillStyle = "#" + (127 * A(N) + 128 << 16 | 127 * A(N + S / 3) + 128 << 8 | 127 * A(N + S / 3 * 2) + 128).toString(16), O.fill(), T[0] = T[1], T[1] = {
 x: n,
 y: r
}
}, a = function n(e) {
var t = e + (2 * I() - 1.1) * C;
return t > B || t < 0 ? n(e) : t
};
Y = document.getElementById("evanyou"), O = Y.getContext("2d"), E = window.devicePixelRatio || 1, L = window.innerWidth, B = window.innerHeight, C = 90, z = Math, N = 0, S = 2 * z.PI, A = z.cos, I = z.random, Y.width = L * E, Y.height = B * E, O.scale(E, E), O.globalAlpha = .6, document.onclick = e, document.ontouchstart = e, e()
}()

   
$("#toc-eye").click(function(){
$("#toc.toc-article").toggle(1000);
});

</script>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持Haodex</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/weixin.jpg" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/zhifubao.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2021/11/08/PackageManager/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2021/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment" ></div>
    <script>
        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "nkvLdnK5xBRTBnMkXqpCq3Ie-gzGzoHsz",
            appKey: "r2K6NaTBu6ebcvjzHlNUFKWR",
            avatar:'mm',
            placeholder: "有什么问题，欢迎留言指正与交流...",
            guest_info:guest_info,
            pageSize:'10'
        });
    </script>
  
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>

  <!-- 爆炸红心效果 -->
  <!-- <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
  <script type="text/javascript" src="/js/firework.js"></script> -->
 
  
</body>
</html>
